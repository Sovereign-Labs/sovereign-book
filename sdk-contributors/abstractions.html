<!DOCTYPE HTML>
<html lang="en" class="sovereign-dark" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Main Abstractions - The Sovereign SDK Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="..//assets/sovereign-dark-highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "sovereign-dark" : "sovereign-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('sovereign-dark')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="rollup-devs.html"><strong aria-hidden="true">3.</strong> Rollup Devs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rollup-devs/build-a-module.html"><strong aria-hidden="true">3.1.</strong> Building a Module</a></li><li class="chapter-item expanded "><a href="rollup-devs/gas.html"><strong aria-hidden="true">3.2.</strong> Gas</a></li></ol></li><li class="chapter-item expanded "><a href="sdk-contributors.html"><strong aria-hidden="true">4.</strong> SDK Contributors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sdk-contributors/transaction-lifecycle.html"><strong aria-hidden="true">4.1.</strong> Transaction Lifecyle</a></li><li class="chapter-item expanded "><a href="sdk-contributors/abstractions.html"><strong aria-hidden="true">4.2.</strong> Main Abstractions</a></li><li class="chapter-item expanded "><a href="forced-sequencer-registration.html"><strong aria-hidden="true">4.3.</strong> Forced Sequencer Registration</a></li><li class="chapter-item expanded "><a href="sdk-contributors/gas.html"><strong aria-hidden="true">4.4.</strong> Gas</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="sovereign-dark">Sovereign Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sovereign SDK Book</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="main-abstractions"><a class="header" href="#main-abstractions">Main Abstractions</a></h1>
<blockquote>
<p>This document provides an overview of the major abstractions offered by the
SDK.</p>
<ul>
<li>Rollup Interface (STF + DA service + DA verifier)</li>
<li>sov-modules (<code>Runtime</code>, <code>Module</code>, stf-blueprint w/ account abstraction,
state abstractions)</li>
<li>sov-sequencer</li>
<li>sov-db</li>
<li>Rockbound</li>
</ul>
</blockquote>
<p>One of the most important principles in the Sovereign SDK is modularity. We
believe strongly in separating rollups into their component parts and
communicating through abstract interfaces. This allows us to iterate more
quickly (since components are unaware of the implementation details of other
components), and it also allows us to reuse components in contexts which are
often quite different from the ones in which they were orginally designed.</p>
<p>In this chapter, we'll give a brief overview of the core abstractions of the
Sovereign SDK</p>
<h2 id="native-vs-zk-execution"><a class="header" href="#native-vs-zk-execution">Native vs. ZK Execution</a></h2>
<p>Perhaps the most fundamental abstraction in Sovereign is the separation between
<code>"native"</code> code execution (which computes a new rollup state) and zero-knowledge
<em>verification</em> of that state. Native execution is the experience you're used to.
In native execution, you have full access to networking, disk, etc. In native
mode, you typically trust data that you read from your own database, but not
data that comes over the network.</p>
<p>Zero-knowledge execution looks similar. You write normal-looking Rust code to do
CPU and memory operations - but under the hood, the environment is alien. In
zero-knowledge execution, disk and network operations are impossible. Instead,
all input is received from the (untrusted) machine generating the proof via a
special syscall. So if you make a call that looks like a network access, you
might not get a response from <code>google.com</code>. Instead, the prover will pick some
arbitrary bytes to give back to you. The bytes might correspond to an actual
response (i.e. if the prover is honest and made the network request for you) -
but they might also be specially crafted to deceive you. So, in zero-knowledge
mode, great care must be taken to avoid relying on unverified data from the
prover.</p>
<p>In the Sovereign SDK, we try to share code between the <code>"native"</code> full node
implementation and the zero-knowledge environment to the greatest extent
possible. This minimizes surface area for bugs. However, a full node necessarily
needs a lot of logic which is unnecessary (and undesirable) to execute in
zero-knowledge. In the SDK, such code is gated behind a <code>cargo</code> feature called
<code>"native"</code>. This code includes RPC implementations, as well as logic to
pre-process some data into formats which are easier for the zero-knowledge code
to verify.</p>
<h2 id="the-rollup-interface"><a class="header" href="#the-rollup-interface">The Rollup Interface</a></h2>
<p>If you squint hard enough, a zk-rollup is made of three separate components.
There's an underlying blockchain ("Data Availability layer"), a set of
transaction execution rules ("a State Transition Function") and a zero-knowledge
proof system (a "ZKVM" for zero-knowledge virtual machine). In the abstract, it
seems like it should be possible to take the same transaction processing logic
(i.e. the EVM) and deploy it on top of many different DA layers. Similarly, you
<em>should</em> be able to take the same execution logic and compile it down to several
different proof systems - in the same way that you can take the same code an run
it on Risc0 or SP1.</p>
<p>Unfortunately, separating these components can be tricky in practice. For
example, the OP Stack relies on an Ethereum smart contract to enforce its
censorship resistance guarantees - so, you can't easily take an OP stack rollup
and deploy it on a non-EVM chain.</p>
<p>In the Sovereign SDK, flexibility is a primary design goal. So we take care to
codify this separation of concerns into the framework from the very beginning.
With Sovereign, it's possible to run any <code>State Transition Function</code> alongside
any <code>Da Service</code> on top of any (rust-compatible) proof system and get a
functional rollup. The <code>rollup-interface</code> crate is what makes this possible.
Every other crate in the SDK depends on it, because it defines the core
abstractions that are shared between all SDK rollups.</p>
<p><img src="../assets/dependency-graph.png" alt="A digram showing how the rollup interface supports the entire Sovereign SDK" /></p>
<p>Inside of the rollup interface, the <code>native</code> vs zero-knowledge distinction
appears in numerous places. For example, the <code>DA layer</code> abstraction has two
components - a <code>DaService</code>, which runs as part of <code>native</code> full node execution
and provides methods for fetching data from the underlying blockchain; and
<code>DaVerifier</code>, which runs in zero-knowledge and verifies that the data being
executed matches the provided DA block header.</p>
<h3 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h3>
<p>Essentially, the Sovereign SDK is just a generic function that does this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rollup&lt;Da: DaService, Zk: Zkvm, Stf: StateTransitionFunction&gt;(self, da: Da, zkvm: Zk, business_logic: Stf) {
	loop {
		// Run some `native` code to get the data for execution
		let (block_data, block_header) = da.get_next_block();
		let (input_state, input_state_root) = self.db.get_state();
		// Run some zero-knowledge code to execute the block
		let proof = zkvm.prove(|| {
			// Check that the inputs match the provided commitments
			if !da.verify(block_data, block_header) || !input_state.verify(input_state_root) {
				panic!()
			};
			// Make the data commitments part of the public proof
			output!(block_header.hash(), input_state_root)
			let output_state_root = business_logic.run(block_data, input_state);
			// Add the output root to the public proof
			output!(output_state_root)
		});
		// Publish the proof onto the DA layer
		da.publish(proof);
	}
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, most of the heavy lifting is done by the DA layer, the <code>Zkvm</code>
and the rollup's business logic. The full node implementation is basically just
glue holding these components together.</p>
<h3 id="da"><a class="header" href="#da">DA</a></h3>
<p>As discussed above, the role of the DA layer is to order and publish data. To
integrate with the Sovereign SDK, a DA layer needs to provide implementations of
two core traits: <code>DaService</code> and <code>DaVerifier</code>.</p>
<h4 id="da-service"><a class="header" href="#da-service">DA Service</a></h4>
<p>The <code>DaService</code> trait is usually just a thin wrapper around a DA layer's
standard RPC client. This trait provides standardized methods for fetching data,
generating merkle proofs, and publishing data. Because it interacts with the
network, correct execution of this trait is <em>not</em> provable in zero-knowledge.</p>
<p>Instead, the work of verifying of the data provided by the <code>DaService</code> is
offloaded to the <code>DaVerifier</code> trait. Since the <code>DaService</code> runs only in <code>native</code>
code, its implementation is less concerned about efficiency than zero-knowledge
code. It's also easier to patch, since updating the <code>DaService</code> does <em>not</em>
require any light clients or bridges to update.</p>
<p>The <code>DaService</code> is the only component of the SDK responsible for publishing and
fetching data. The SDK's node does not currently have a peer-to-peer network of
its own. This dramatically simplifies the full node and reduces bandwidth
requirements.</p>
<h3 id="da-verifier"><a class="header" href="#da-verifier">DA Verifier</a></h3>
<p>The <code>DaVerifier</code> is the zero-knowledge-provable counterpart of the <code>DaService</code>.
It is responsible for checking that the (untrusted) private inputs to a proof
match the public commitment <em>as efficiently as possible</em>. It's common for the
<code>DaVerifier</code> to offload some work to the <code>DaService</code> (i.e. as computing extra
metadata) in order to reduce the amount of computation required by the
<code>DaVerifier</code>.</p>
<p>At the level of <code>Rust</code> code, we encode the relationship between the <code>DaVerifier</code>
and the <code>DaService</code> using a helper trait called <code>DaSpec</code> - which specifies the
types on which both interfaces operate.</p>
<h4 id="zero-knowledge-virtual-machine-zkvm"><a class="header" href="#zero-knowledge-virtual-machine-zkvm">Zero Knowledge Virtual Machine ("<code>Zkvm</code>")</a></h4>
<p>The <code>Zkvm</code> traits make a zk-snark system (like <code>Risc0</code> or <code>Sp1</code>) compatible with
the Sovereign SDK. Like the <code>DA layer</code>, we separate <code>Zkvm</code> traits into a
<code>native</code> and zk version, plus a shared helper.</p>
<p>The <code>ZkvmHost</code> trait describes how a <code>native</code> computer executes an <code>elf</code> file
(generated from <code>Rust</code> code) and generates a zero-knowledge proof. It also
describes how the <code>native</code> machine passes private inputs (the "witness") into
the execution.</p>
<p>The <code>ZkvmGuest</code> trait describes how a program running in zero-knowledge mode
accepts inputs from the host machine.</p>
<p>Finally, the <code>ZkVerifier</code> trait describes how a proof generated by the host is
verified. This trait is implemented by both the <code>Host</code> and the <code>Guest</code>, which is
how we represent that proofs must be verifiable <code>native</code>ly and recursively (i.e.
inside another SNARK.)</p>
<h4 id="state-transition"><a class="header" href="#state-transition">State Transition</a></h4>
<p>A <code>StateTransitionFunction</code> ("STF") is a trait which describes:</p>
<ol>
<li>
<p>How to initialize a rollup's state at genesis</p>
</li>
<li>
<p>How to apply the data from the DA layer to generate a new state</p>
</li>
</ol>
<p>In other words, the implementation of <code>StateTransitionFunction</code> is what defines
the rollup's "business logic".</p>
<p>In the Sovereign SDK, we define a generic full node which can run any STF. As
long as your logic implements the interface, we should be able to run it.</p>
<p>However, implementing the business logic of a rollup is <em>extremely</em> complicated.
While it's relatively easy to roll your own implementation of the <code>Da</code> or <code>Zkvm</code>
traits, building a secure STF from scratch is a massive undertaking. It's so
complex, in fact, that we assume no one will ever do it - andthe vast majority
of the Sovereign SDK's code is devoted to providing a generic implementation of
an STF that developers can customize. (This STF is what we call the Sovereign
module system, or sov-modules).</p>
<p>So if no one is ever going to implement the <code>StateTransitionFunction</code> interface,
why bother maintaining it at all? One reason is for flexibility. Just because we
don't expect anyone to roll their own STF doesn't mean that they won't. But a
bigger motivation is to keep concerns separate. By hiding the implementation
details of the rollup behind the STF interface, we build a firm abstraction
barrier between it and the full node. This means that we're free to make
breaking changes on either side of the wall (either in the node, or in the STF)
without worrying about breaking the other component.</p>
<h2 id="sov-modules"><a class="header" href="#sov-modules">Sov Modules</a></h2>
<p>Outside of the rollup interface, the most important abstraction is
<code>sov-modules</code>. <code>sov-modules</code> is a pre-built STF with pluggable... modules. It
does the heavy lifting of implementing a secure STF so that you can focus on the
core logic of your application.</p>
<h3 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h3>
<p>At the heart of any sov-modules rollup is the <code>Runtime</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An example runtime similar to the one used in our "standard" demo rollup
pub struct Runtime&lt;S: Spec&gt; {
    /// The Bank module implements fungible tokens, which are needed to charge `gas`
    pub bank: sov_bank::Bank&lt;S&gt;,
    /// The Sequencer Registry module is where we track which addresses can send batches to the rollup
    pub sequencer_registry: sov_sequencer_registry::SequencerRegistry&lt;S&gt;,
    /// The Prover Incentives module is where we reward provers who do useful work
    pub prover_incentives: sov_prover_incentives::ProverIncentives&lt;S&gt;,
    /// The Accounts module implements identities on the rollup. All of the other modules rely on it
	/// to link cryptographic keys to logical accounts
    pub accounts: sov_accounts::Accounts&lt;S&gt;,
	/// The NFT module provides an implementation of a non-fungible token standard. It's totally optional.
    pub nft: sov_nft_module::NonFungibleToken&lt;S&gt;,
    #[cfg_attr(feature = "native", cli_skip)]
    /// The EVM module lets the rollup run Ethereum smart contracts. It's totally optional.
    pub evm: sov_evm::Evm&lt;S, Da&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>At the highest level, a runtime is "just" a collection of all the modules which
are included in your rollup. Its job is to take <code>Transaction</code>s and dispatch them
to the appropriate module for execution.</p>
<p>Pretty much all rollups built with the <code>sov-modules</code> include the bank, the
sequencer registry, and the accounts module in their <code>Runtime</code>. They also
usually include one of <code>sov_prover_incentives</code> (if they're a zk-rollup) or
<code>sov_attester_incentives</code> (if they're an Optimistic rollup).</p>
<p>You may also have noticed that the <code>Runtime</code> is generic over a <code>Spec</code>. This
<code>Spec</code> describe the core types (addresses, hashers, cryptography) used by the
rollup and the DA layer. Making your runtime generic over a Spec means that you
can easily change DA layers, or swap any of the core primitives of your rollup.
For example, a rollup can trivially switch from Ed25519 to secp256k1 for its
signature scheme by changing the implementation of its <code>Spec</code> trait.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>"Modules" are the things that process transactions. For example, the <code>Bank</code>
module lets users transfer tokens to each other. And the <code>EVM</code> module implements
a full Ethereum Virtual Machine that can process any valid Ethereum transaction.</p>
<p>A <code>Module</code> is just a rust <code>struct</code> that implements two traits called <code>Module</code>
and <code>ModuleInfo</code>.</p>
<h4 id="the-module-trait"><a class="header" href="#the-module-trait">The <code>Module</code> trait</a></h4>
<p>The <code>Module</code> trait is like a simplified version of the
<code>StateTransitionFunction</code>. It describes how to initialize the module at the
rollup's genesis, and how the module processes <code>CallMessage</code>s received from
users (i.e. how it processes transactions)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Module {
	// -- Some associated type definitions are omitted here --
	/// Module defined argument to the call method.
    type CallMessage: Debug;

    /// Genesis is called when a rollup is deployed and can be used to set initial state values in the module.
    fn genesis(
        &amp;self,
        _config: &amp;Self::Config,
        _working_set: &amp;mut WorkingSet&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;

    /// Processes a transaction, updating the rollup state.
    fn call(&amp;self,
        _message: Self::CallMessage,
        _context: &amp;Context&lt;Self::Spec&gt;,
        _state: &amp;mut impl TxState&lt;S&gt;,
    ) -&gt; Result&lt;CallResponse, ModuleError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>You'll notice that the <code>call</code> function takes three arguments: an associated
<code>CallMessage</code> type, a <code>Context</code>, and a <code>WorkingSet</code>.</p>
<ul>
<li>
<p>The <code>CallMessage</code> type is the deserialized content of the user's transaction -
and the module can pick any type to be its <code>CallMessage</code>. In most cases,
modules use an <code>enum</code> with one variant for each action a user might want to
take. For example, the <code>Bank::CallMessage</code> type has variants for minting,
transferring, and burning tokens.</p>
</li>
<li>
<p>The <code>Context</code> type is relatively straightforward. It simply contains the
address of the sequencer, who published the transaction, the identity of the
transaction's signer, and the current block height.</p>
</li>
<li>
<p>The <code>TxState</code> is the most interesting of the three, but it needs a little bit
of explanation. In the Sovereign SDK, the rust <code>struct</code> which implements a
<code>Module</code> doesn't actually contain any state. Rather than holding actual
values, the module simply defines the <em>structure</em> of some items in state. All
of the actual state of the rollup is stored in the <code>State</code> object, which is
in-memory layer on top of the rollup's database (in native mode) or merkle
tree (in zk mode). The <code>State</code> abstraction handles commit/revert semantics for
you, as well as taking responsibility for caching, deduplication, and
automatic witness generation/checking. It also provides utilities for charging
<code>gas</code> and emitting <code>event</code>s.</p>
</li>
</ul>
<p>The <code>Accounts</code> module provides a good example of a standard <code>Module</code> trait
implementation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CallMessage&lt;S: Spec&gt; {
    /// Updates a public key for the corresponding Account.
    /// The sender must be in possession of the new key.
    UpdatePublicKey(
        /// The new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::PublicKey,
        /// A valid signature from the new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::Signature,
    ),
}

impl&lt;S: Spec&gt; sov_modules_api::Module for Accounts&lt;S&gt; {
	// -- Some items ommitted here --
    fn call(
        &amp;self,
        msg: Self::CallMessage,
        context: &amp;Context&lt;S&gt;,
        working_set: &amp;mut WorkingSet&lt;S&gt;,
    ) -&gt; Result&lt;sov_modules_api::CallResponse, Error&gt; {
        match msg {
            call::CallMessage::UpdatePublicKey(new_pub_key, sig) =&gt; {
				// Find the account of the sender
				let pub_key = self.public_keys.get(context.sender(), working_set)?;
				let account = self.accounts.get(&amp;pub_key, working_set);
				// Update the public key
				self.accounts.set(&amp;new_pub_key, &amp;account, working_set);
				self.public_keys
					.set(context.sender(), &amp;new_pub_key, working_set);
				Ok(Default::default())
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="the-moduleinfo-trait"><a class="header" href="#the-moduleinfo-trait">The <code>ModuleInfo</code> trait</a></h4>
<p>The <code>ModuleInfo</code> trait describes how the module interacts with the broader
module <em>system</em>. Each module has a unique ID and stores its state under a unique
<code>prefix</code> of the global key-value store provided by <code>sov-modules</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ModuleInfo {
    /// Returns id of the module.
    fn id(&amp;self) -&gt; &amp;ModuleId;

    /// Returns the prefix where module state is stored.
    fn prefix(&amp;self) -&gt; ModulePrefix;

    /// Returns addresses of all the other modules this module is dependent on
    fn dependencies(&amp;self) -&gt; Vec&lt;&amp;ModuleId&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike the <code>Module</code> trait, its incredibly rare for developers to implement
<code>ModuleInfo</code> by hand. Instead, it's strongly recommended to derive the
<code>ModuleInfo</code> using our handy macro. A typical usage looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(ModuleInfo, Clone)]
pub struct Bank&lt;S: sov_modules_api::Spec&gt; {
    /// The id of the sov-bank module.
    #[id]
    pub(crate) id: ModuleId,

    /// The gas configuration of the sov-bank module.
    #[gas]
    pub(crate) gas: BankGasConfig&lt;S::Gas&gt;,

    /// A mapping of [`TokenId`]s to tokens in the sov-bank.
    #[state]
    pub(crate) tokens: sov_modules_api::StateMap&lt;TokenId, Token&lt;S&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This code automatically generates a unique ID for the bank module and stores it
in the field of the module called <code>id</code>. It also initializes the <code>StateMap</code>
"<code>tokens</code>" so that any keys stored in the map will be prefixed the with module's
<code>prefix</code>. This prevents collisions in case a different module also declares a
<code>StateMap</code> where the keys are <code>TokenId</code>s.</p>
<h3 id="module-state"><a class="header" href="#module-state">Module State</a></h3>
<p>The Sovereign SDK provides three core abstractions for managing module state. A
<code>StateMap&lt;K, V&gt;</code> maps arbitrary keys of type <code>K</code> to arbitrary values of type
<code>V</code>. A <code>StateValue&lt;V&gt;</code> stores a value of type <code>V</code>. And a <code>StateVec&lt;V&gt;</code> store an
arbitrary length vector of type <code>V</code>. All three types require their arguments to
be serializable, since the values are stored in a merkle tree under the hood.</p>
<p>All three abstractions support changing the underlying encoding scheme but
default to <code>Borsh</code> if no alternative is specified. To override the default,
simply add an extra type parameter which implements the <code>StateCodec</code> trait. (i.e
you might write <code>StateValue&lt;Da::BlockHeader, BcsCodec&gt;</code> to use the <code>Bcs</code>
serialization scheme for block headers, since your library for DA layer types
might only support serde-compatible serializers).</p>
<p>All state values are accessed through <code>TxState</code>. For example, you always write
<code>my_state_value.get(&amp;mut state)</code> to fetch a value. It's also important to
remember that modifying a value that you read from state doesn't have any effect
unless you call <code>my_value.set(new, &amp;mut working_set)</code>.</p>
<h4 id="merkle-tree-layout"><a class="header" href="#merkle-tree-layout">Merkle Tree Layout</a></h4>
<p><code>sov-modules</code> currently uses a generic
<a href="https://github.com/penumbra-zone/jmt">Jellyfish Merkle Tree</a> for its
authenticated key-value store. (Generic because it can be configured to use any
32-byte hash function). In the near future, this JMT will be replaced with the
<a href="https://sovereign.mirror.xyz/jfx_cJ_15saejG9ZuQWjnGnG-NfahbazQH98i1J3NN8">Nearly Optimal Merkle Tree</a>
that is currently under development.</p>
<p>In the current implementation, the SDK implements storage by generating a unique
(human-readable) key for each <code>StateValue</code>, using the hash of that key as a path
in the merkle tree. For <code>StateMap</code>s, the serialization of the key is appended to
that path. And for <code>StateVec</code>s, the index of the value is appended to the path.</p>
<p>For example, consider the following module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Suppose we're in the file my_crate/lib.rs
#[derive(ModuleInfo, Clone)]
pub struct Example&lt;S: sov_modules_api::Spec&gt; {
    #[id]
    pub(crate) id: ModuleId,
    #[state]
    pub(crate) some_value: sov_modules_api::StateValue&lt;u8&gt;,
    #[state]
    pub(crate) some_vec: sov_modules_api::StateVec&lt;u64&gt;,
    #[state]
    pub(crate) some_map: sov_modules_api::StateMap&lt;String, String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The value of <code>some_value</code> would be stored at the path
<code>hash(b"my_crate/Example/some_value")</code>. The value of the key "hello" in
<code>some_map</code> would be stored at <code>hash(b"my_crate/Example/some_map/⍰hello")</code> (where
<code>⍰hello</code> represents the borsh encoding of the string "hello") etc.</p>
<p>However, this layout may change in future to provide better locality. For more
details... ask Preston, I guess.</p>
<h4 id="exotic-state-variants"><a class="header" href="#exotic-state-variants">Exotic State Variants</a></h4>
<p>In addition to the standard state store, we support two other kinds of state:</p>
<p><code>KernelStateValue</code>s or (maps/vecs) act identically to regular <code>StateValues</code>, but
they're stored in a separate merkle tree which is more tightly access
controlled. This mechanism allows the rollup to store data that is inaccessible
during transaction execution, which is necessary to enable soft-confirmations
without sacrificing censorship resistance. For more details, see the section on
soft-confirmations in the <a href="./transaction-lifecycle.html">transaction lifecycle</a>
documentation. The global "state root" returned by the <code>sov-modules</code> from the
<code>StateTransitionFunction</code> implementation is the hash of the kernel state root
with the regular state root. We do our best to hide this detail from users of
the SDK, though. Merkle proofs are automatically generated against the global
root, so users don't need to worry about which state trie there values are in.</p>
<p><code>AccessoryStateValue</code> or (map/vec) types are similar to <code>Kernel</code> types except
that their values are not <em>readable</em> from inside the state transition function
at all. Under the hood, these value are stored in the rollup's database <em>but not
in either merkle tree</em>. This is useful for creating data that will be served via
RPC but never accessed again during execution - for example, the transaction
receipts from an Ethereum block.</p>
<h3 id="the-stf-blueprint"><a class="header" href="#the-stf-blueprint">The STF Blueprint</a></h3>
<p>The last key component of a <code>sov-modules</code> rollup is the <code>stf-blueprint</code>. This
"blueprint" provides a generic implementation of a <code>StateTransitionFunction</code> in
terms of a <code>Runtime</code> (described above) and a <code>Kernel</code> (which provides
security-critical functionality like censorship resistance in a way that's
isolated from the transaction execution logic).</p>
<p>The STF blueprint implements the following high-level workflow:</p>
<ol>
<li>Take all of the new data <code>Blob</code>s read from the DA layer and send them to the
<code>Kernel</code>. The <code>Kernel</code> will return a list of deserialized <code>Batch</code>es of
transactions as well as the current <code>gas</code> price. (A "<code>Batch</code>" is a "<code>Blob</code>"
sent by a registered sequencer that has been succesfully deserialized into a
list of <code>Transaction</code>s)</li>
</ol>
<ul>
<li>Note that the list of <code>Batch</code>es returned by the <code>Kernel</code> does <em>not</em>
necessarily correspond exactly to the incoming <code>Blob</code>s. The <code>Kernel</code> might
decide to ignore some Blobs, or to store some in its internal state for
"deferred" execution. It might also add some <code>Batch</code>es saved from a previous
slot.</li>
</ul>
<ol start="2">
<li>
<p>Run the <code>begin_slot</code> hook, allowing modules to execute any initialization
logic</p>
</li>
<li>
<p>For each batch initialize the sequencer reward to zero and run the
<code>begin_batch</code> hook. Apply the transactions, rewarding or penalizing the
sequencer as appropriate. Finally, run the <code>end_batch</code> hook</p>
</li>
<li>
<p>Run the <code>end_slot</code> hook to allow modules to execute any final logic.</p>
</li>
<li>
<p>Compute the state change set and state root based on the transactions that
were executed.</p>
</li>
<li>
<p>Execute the <code>finalize</code> hook, which allows modules to compute any summary
information from the change set and make it available via RPC.</p>
</li>
</ol>
<p>For more details on the process of applying individual transactions, see the
<a href="./transaction-lifecycle.html">transaction lifecycle</a> document.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../sdk-contributors/transaction-lifecycle.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../forced-sequencer-registration.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../sdk-contributors/transaction-lifecycle.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../forced-sequencer-registration.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
