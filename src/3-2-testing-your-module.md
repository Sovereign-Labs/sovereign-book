# Testing Your Module

Having implemented your module, the next critical step is to test it thoroughly. The Sovereign SDK provides a comprehensive testing framework that allows you to simulate a rollup environment and assert that your module's logic is correct.

In this section, we'll walk you through writing tests for the `ValueSetter` module.

## Step 1: Setting Up the Test Environment

All module tests follow a similar pattern. First, we need an isolated test environment. This involves creating a temporary runtime that includes our module, defining the initial ("genesis") state, and initializing a `TestRunner` to execute transactions.

Let's create our test runtime and a `setup` helper function.

```rust
use sov_modules_api::Spec;
use sov_test_utils::runtime::genesis::optimistic::HighLevelOptimisticGenesisConfig;
use sov_test_utils::runtime::TestRunner;
use sov_test_utils::{generate_optimistic_runtime, TestUser};

use value_setter::{ValueSetter, ValueSetterConfig};

type S = sov_test_utils::TestSpec;

// 1. Create a temporary Test Runtime.
// This runtime includes our ValueSetter module and the core modules of a Sovereign SDK rollup (e.g. Bank).
generate_optimistic_runtime!(
    TestRuntime <=
    value_setter: ValueSetter<S>
);

// 2. Define a helper struct to hold convenient handles to our test users.
pub struct TestData<S: Spec> {
    pub admin: TestUser<S>,
    pub regular_user: TestUser<S>,
}

// 3. Create the `setup` function to initialize the test environment.
pub fn setup() -> (TestData<S>, TestRunner<TestRuntime<S>, S>) {
    // Create two users, the first of which will be our admin.
    let genesis_config = HighLevelOptimisticGenesisConfig::generate()
        .add_accounts_with_default_balance(2);
    
    let mut users = genesis_config.additional_accounts().to_vec();
    let regular_user = users.pop().unwrap();
    let admin = users.pop().unwrap();

    let test_data = TestData {
        admin: admin.clone(),
        regular_user,
    };

    // Configure the genesis state for our ValueSetter module.
    let value_setter_config = ValueSetterConfig {
        admin: admin.address(),
    };

    // Build the final genesis config.
    let genesis = GenesisConfig::from_minimal_config(
        genesis_config.into(),
        value_setter_config,
    );
    
    // Initialize the TestRunner with the genesis state.
    let runner = TestRunner::new_with_genesis(
        genesis.into_genesis_params(),
        TestRuntime::default(),
    );
    
    (test_data, runner)
}
```

This `setup` function now correctly initializes our `ValueSetter` module, making the `admin` address known at the start of every test.

## Step 2: Writing a "Happy Path" Test

Now, let's write our first test to ensure the admin can successfully set the value. We use a `TransactionTestCase` to bundle the transaction input with a set of assertions to run after execution.

```rust
use sov_test_utils::{AsUser, TransactionTestCase};
use value_setter::{CallMessage, Event};

#[test]
fn test_admin_can_set_value() {
    // 1. Setup
    let (test_data, mut runner) = setup();
    let admin = &test_data.admin;

    let new_value = 42;

    // 2. Execute the transaction
    runner.execute_transaction(TransactionTestCase {
        // The transaction input, created by the admin user.
        input: admin.create_plain_message::<TestRuntime<S>, ValueSetter<S>>(
            CallMessage::SetValue(new_value),
        ),
        // The assertions to run after execution.
        assert: Box::new(move |result, state| {
            // 3. Assert the outcome
            assert!(result.tx_receipt.is_successful());

            // Assert that the correct event was emitted.
            // The event enum name (`TestRuntimeEvent`) is auto-generated by our `generate_optimistic_runtime!` macro.
            assert_eq!(result.events.len(), 1);
            let event = &result.events[0];
            assert_eq!(
                event,
                // The runtime wraps our module's event in a variant named after the module field.
                &TestRuntimeEvent::ValueSetter(Event::ValueUpdated(new_value))
            );

            // Assert that the state was updated correctly by querying the module.
            let value_setter = ValueSetter::<S>::default();
            let current_value = value_setter.value.get(state).unwrap();
            assert_eq!(current_value, Some(new_value));
        }),
    });
}
```

## Step 3: Testing a Failure Case

It's equally important to test that our module fails when it should. Let's add a test to ensure a regular user *cannot* set the value.

```rust
#[test]
fn test_regular_user_cannot_set_value() {
    // 1. Setup
    let (test_data, mut runner) = setup();
    let regular_user = &test_data.regular_user;

    // 2. Execute the transaction from the non-admin user
    runner.execute_transaction(TransactionTestCase {
        // This time we're sending the transaction from the regular_user
        input: regular_user.create_plain_message::<TestRuntime<S>, ValueSetter<S>>(
            CallMessage::SetValue(99),
        ),
        assert: Box::new(move |result, state| {
            // 3. Assert that the transaction was reverted
            assert!(result.tx_receipt.is_reverted());
            
            // Optional: Check for the specific error message
            if let sov_modules_api::TxEffect::Reverted(err) = result.tx_receipt {
                assert!(err.reason.to_string().contains("Only the admin can set the value."));
            }

            // Assert that the state was NOT changed.
            let value_setter = ValueSetter::<S>::default();
            let current_value = value_setter.value.get(state).unwrap();
            assert_eq!(current_value, None); // It should remain un-set.
        }),
    });
}
```

## Step 4: Running Your Tests

Execute your tests from your module's root directory using the standard Cargo command:

```bash
cargo test
```

## Additional Testing Capabilities

The `TestRunner` provides methods for more advanced scenarios, all documented in the [`sov-test-utils` crate](fix-link-https://docs.rs/sov-test-utils). Key capabilities include:

*   **Batch Execution:** Execute and assert on a sequence of transactions with `runner.execute_batch(...)`.
*   **Time Advancement:** Test time-sensitive logic (like in `Hooks`) by advancing the slot count with `runner.advance_slots(...)`.
*   **Historical Queries:** Query state at a specific block height with `runner.query_state_at_height(...)`.
*   **API Testing:** Run an integrated REST API server for off-chain testing with `runner.query_api_unwrap_data(...)`.

### What's Next?

With a thoroughly tested module, you can be confident that your on-chain logic is correct. The next step is to understand how users will interact with it from the outside world.

In the next chapter, **"Wallets and Accounts,"** we'll take a closer look at how users create accounts, sign transactions, and submit them to your rollup.