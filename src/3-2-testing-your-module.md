# Testing Your Module

Having implemented your module, the next critical step is to test it thoroughly. The Sovereign SDK provides a comprehensive testing framework that allows you to simulate a rollup environment and assert that your module's logic is correct.

In this section, we'll walk you through writing tests for the `ValueSetter` module we just built.

## Anatomy of a Module Test

Before we write code, let's understand the key components we'll be using:

-   **Test Runtime:** A temporary, isolated rollup runtime that includes your module and any dependencies. We'll use the `generate_optimistic_runtime!` macro to create one.
-   **`TestRunner`:** The main test harness. It manages the runtime's state and allows us to execute transactions.
-   **`setup` function:** A helper function that configures the initial ("genesis") state of our test runtime, such as setting up the `ValueSetter`'s admin address.
-   **`TransactionTestCase`:** A struct that bundles a transaction with an assertion block, creating a clean and readable test case.

## Step 1: Setting Up the Test Environment

Now, let's create our test runtime and `setup` function.

```rust
use sov_modules_api::Spec;
use sov_test_utils::runtime::genesis::optimistic::HighLevelOptimisticGenesisConfig;
use sov_test_utils::runtime::TestRunner;
use sov_test_utils::{generate_optimistic_runtime, TestUser};

use value_setter::{ValueSetter, ValueSetterConfig};

type S = sov_test_utils::TestSpec;

// 1. Create the Test Runtime
// This runtime includes our ValueSetter module and the core modules it depends on.
generate_optimistic_runtime!(
    TestRuntime <=
    value_setter: ValueSetter<S>
);

// 2. Define TestData
// A helper struct to hold convenient handles to our test users.
pub struct TestData<S: Spec> {
    pub admin: TestUser<S>,
    pub regular_user: TestUser<S>,
}

// 3. Create the setup function
pub fn setup() -> (TestData<S>, TestRunner<TestRuntime<S>, S>) {
    // Create two users, the first of which will be our admin.
    let genesis_config = HighLevelOptimisticGenesisConfig::generate()
        .add_accounts_with_default_balance(2);
    
    let mut users = genesis_config.additional_accounts().to_vec();
    let regular_user = users.pop().unwrap();
    let admin = users.pop().unwrap();

    let test_data = TestData {
        admin: admin.clone(),
        regular_user,
    };

    // Configure the genesis state for our ValueSetter module.
    let value_setter_config = ValueSetterConfig {
        initial_value: 0,
        admin: admin.address(),
    };

    // Build the final genesis config.
    let genesis = GenesisConfig::from_minimal_config(
        genesis_config.into(),
        value_setter_config,
    );
    
    // Initialize the TestRunner
    let runner = TestRunner::new_with_genesis(
        genesis.into_genesis_params(),
        TestRuntime::default(),
    );
    
    (test_data, runner)
}
```
This `setup` function now correctly initializes our `ValueSetter` module, making the `admin` address known at the start of every test.

## Step 2: Writing a "Happy Path" Test

Now, let's write our first test to ensure the admin can successfully set the value.

```rust
use sov_test_utils::{AsUser, TransactionTestCase};
use value_setter::{CallMessage, Event};

#[test]
fn test_admin_can_set_value() {
    // 1. Setup
    let (test_data, mut runner) = setup();
    let admin = &test_data.admin;

    let new_value = 42;

    // 2. Execute the transaction
    runner.execute_transaction(TransactionTestCase {
        // The transaction input
        input: admin.create_plain_message::<TestRuntime<S>, ValueSetter<S>>(
            CallMessage::SetValue(new_value),
        ),
        // The assertions to run after execution
        assert: Box::new(move |result, state| {
            // 3. Assert the outcome
            assert!(result.tx_receipt.is_successful());

            // Assert that the correct event was emitted.
            // The event enum name (`TestRuntimeEvent`) is auto-generated by our `generate_optimistic_runtime!` macro.
            assert_eq!(result.events.len(), 1);
            let event = &result.events[0];
            assert_eq!(
                event,
                // The runtime wraps our module's event in a variant named after the module field.
                &TestRuntimeEvent::ValueSetter(Event::ValueChanged(new_value))
            );

            // Assert that the state was updated correctly by querying the module.
            let value_setter = ValueSetter::<S>::default();
            let current_value = value_setter.value.get(state).unwrap();
            assert_eq!(current_value, Some(new_value));
        }),
    });
}
```

## Step 3: Testing a Failure Case

It's equally important to test that our module fails when it should. Let's add a test to ensure a regular user *cannot* set the value.

```rust
#[test]
fn test_regular_user_cannot_set_value() {
    // 1. Setup
    let (test_data, mut runner) = setup();
    let regular_user = &test_data.regular_user;

    // 2. Execute the transaction from the non-admin user
    runner.execute_transaction(TransactionTestCase {
        input: regular_user.create_plain_message::<TestRuntime<S>, ValueSetter<S>>(
            CallMessage::SetValue(99),
        ),
        assert: Box::new(move |result, state| {
            // 3. Assert that the transaction was reverted
            assert!(result.tx_receipt.is_reverted());
            
            // Optional: Check for the specific error message
            // if let sov_modules_api::TxEffect::Reverted(err) = result.tx_receipt {
            //     assert!(err.reason.to_string().contains("Only the admin can set the value."));
            // }

            // Assert that the state was NOT changed.
            let value_setter = ValueSetter::<S>::default();
            let current_value = value_setter.value.get(state).unwrap();
            assert_eq!(current_value, Some(0)); // It should remain the initial value
        }),
    });
}
```

## Step 4: Running Your Tests

Execute your tests from your module's root directory using standard Rust commands:

```bash
cargo test
```

## Additional Resources

For more advanced testing scenarios, the [`sov-test-utils` crate](fix-link-https://docs.rs/sov-test-utils) is your primary resource. It contains all the testing components covered in this guide and much more.

Specifically the **[`TestRunner`](fix-link-https://docs.rs/sov-test-utils/latest/sov_test_utils/runtime/struct.TestRunner.html)** struct provides methods for testing more complex scenarios, including:

*   Executing and asserting on batches of transactions. `runner.execute_batch(..)`
*   Advancing time (which is particularly useful for testing logic in `hooks`. More on hooks later.) `runner.advance_slots(num)`
*   Querying historical state at specific block heights. `runner.query_state_at_height(..)`
*   Running an integrated REST API server for off-chain testing. `runner.query_api_unwrap_data(..)`

### Ready for Primetime

With a thoroughly tested module, you can be confident in your logic's correctness. It's now time to bring your module to life by integrating it into a live rollup runtime.

In the next section, **"Integrating Your Module,"** we'll guide you through adding your module to the Runtime struct, configuring its genesis state, and making it a live component of your application.