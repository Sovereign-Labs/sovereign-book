<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Advanced Topics - The Sovereign SDK Book</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="/assets/sovereign-dark-highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1-intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="2-running-starter.html"><strong aria-hidden="true">2.</strong> Running the Starter Rollup</a></li><li class="chapter-item expanded "><a href="3-quickstart.html"><strong aria-hidden="true">3.</strong> Quickstart: Your First Module</a></li><li class="chapter-item expanded "><a href="4-0-build-for-production-intro.html"><strong aria-hidden="true">4.</strong> Building for Production</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-1-anatomy-of-a-module.html"><strong aria-hidden="true">4.1.</strong> Anatomy of a Module</a></li><li class="chapter-item expanded "><a href="4-2-testing-your-module.html"><strong aria-hidden="true">4.2.</strong> Testing Your Module</a></li><li class="chapter-item expanded "><a href="4-3-wallets-and-accounts.html"><strong aria-hidden="true">4.3.</strong> Wallets and Accounts</a></li><li class="chapter-item expanded "><a href="4-4-advanced-topics.html"><strong aria-hidden="true">4.4.</strong> Advanced Topics</a></li><li class="chapter-item expanded "><a href="4-5-performance.html"><strong aria-hidden="true">4.5.</strong> Performance</a></li><li class="chapter-item expanded "><a href="4-6-prebuilt-modules.html"><strong aria-hidden="true">4.6.</strong> Prebuilt Modules</a></li></ol></li><li class="chapter-item expanded "><a href="5-additional-capabilities.html"><strong aria-hidden="true">5.</strong> Additional Capabilities</a></li><li class="chapter-item expanded "><a href="6-0-intro.html"><strong aria-hidden="true">6.</strong> Instrumenting Your Rollup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6-1-metrics.html"><strong aria-hidden="true">6.1.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="6-2-logging.html"><strong aria-hidden="true">6.2.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="7-0-intro.html"><strong aria-hidden="true">7.</strong> SDK Contributors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7-1-transaction-lifecycle.html"><strong aria-hidden="true">7.1.</strong> Transaction Lifecyle</a></li><li class="chapter-item expanded "><a href="7-2-abstractions.html"><strong aria-hidden="true">7.2.</strong> Main Abstractions</a></li><li class="chapter-item expanded "><a href="7-3-forced-sequencer-registration.html"><strong aria-hidden="true">7.3.</strong> Forced Sequencer Registration</a></li><li class="chapter-item expanded "><a href="7-4-gas.html"><strong aria-hidden="true">7.4.</strong> Gas</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="sovereign-dark">Sovereign Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sovereign SDK Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>This section covers advanced module development features that go beyond basic functionality.</p>
<p>Need to run logic on every block? Want to build custom APIs or integrate with off-chain services? Need configurable delays to reduce MEV for your application? You'll find the answers here.</p>
<p>Each of these features is optional, designed to be adopted as your application's needs evolve.</p>
<h2 id="hooks-responding-to-on-chain-events"><a class="header" href="#hooks-responding-to-on-chain-events">Hooks: Responding to On-Chain Events</a></h2>
<p>While the <code>call</code> method allows your module to react to direct user transactions, sometimes
you need your module to execute logic in response to broader onchain events. This is where <code>Hooks</code> come in.
They allow your module to "hook into" the lifecycle of a block or transaction, enabling
powerful automation.</p>
<h3 id="blockhooks-running-logic-at-block-boundaries"><a class="header" href="#blockhooks-running-logic-at-block-boundaries"><code>BlockHooks</code>: Running Logic at Block Boundaries</a></h3>
<p><code>BlockHooks</code> are triggered at the beginning and end of every block. They are ideal for logic that
needs to run periodically, independent of any specific transaction. For example, you could use
a <code>BlockHook</code> to:</p>
<ul>
<li>Distribute rewards once per block.</li>
<li>Update funding rate looking at the number of open positions at the end of every N blocks.</li>
</ul>
<p><strong>A word of caution</strong>: BlockHook computation is not paid for by any single user, so it's a "public good" of your rollup.
Be mindful of performance here; heavy computation in a BlockHook can make your rollup vulnerable to Denial-of-Service (DoS) attacks.</p>
<h3 id="txhooks-monitoring-all-transactions"><a class="header" href="#txhooks-monitoring-all-transactions">TxHooks: Monitoring All Transactions</a></h3>
<p>TxHooks run before and after every single transaction processed by the rollup. This makes them perfect for:</p>
<ul>
<li><strong>Global Invariant Checks</strong>: Ensuring a global property (like total supply of a token) is never violated by any module.</li>
<li><strong>Monitoring and Reactions</strong>: Allowing a compliance module to monitor all transfers and flag suspicious activity.</li>
</ul>
<p>Unlike <code>BlockHooks</code>, the gas for <code>TxHooks</code> is paid by the user who submitted the transaction.</p>
<h3 id="finalizehook-cheap-off-chain-indexing"><a class="header" href="#finalizehook-cheap-off-chain-indexing"><code>FinalizeHook</code>: Cheap Off-Chain Indexing</a></h3>
<p>The <code>FinalizeHook</code> runs at the very end of a block's execution and can only write to <code>AccessoryState</code>. This makes it
cheap to run and perfect for storing data that are only meant to be read by off-chain APIs, not used by on-chain logic.</p>
<h3 id="implementing-hooks"><a class="header" href="#implementing-hooks">Implementing Hooks</a></h3>
<p>To use a hook, you simply import the corresponding trait from <code>sov_modules_api</code> and implement it for your module. The SDK automatically detects this implementation and will call the appropriate methods at the correct time during block processing.</p>
<p><strong>Example: Implementing</strong> <code>BlockHooks</code></p>
<p>To run logic at the beginning of each block, import the <code>BlockHooks</code> trait and implement it for your module:</p>
<pre><code class="language-rust">use sov_modules_api::{BlockHooks, Spec, StateCheckpoint};
// ... other imports

impl&lt;S: Spec&gt; BlockHooks for MyModule&lt;S&gt; {
    type Spec = S;

    // This method will be called at the beginning of every block.
    fn begin_rollup_block_hook(
        &amp;mut self,
        _pre_state_user_root: &amp;&lt;S::Storage as Storage&gt;::Root,
        _state: &amp;mut StateCheckpoint&lt;S&gt;,
    ) {
        // Your custom logic here...
    }
}</code></pre>
<p><strong>Note:</strong> Since the <code>FinalizeHook</code> only runs <em>natively</em>, it should be implemented under the <a href="#the-native-feature-flag"><code>native</code></a> flag. More on that later.</p>
<h2 id="error-handling-user-errors-vs-system-bugs"><a class="header" href="#error-handling-user-errors-vs-system-bugs">Error Handling: User Errors vs. System Bugs</a></h2>
<p>In a blockchain context, handling failure correctly is critical. Your module must clearly distinguish between two types of failures: expected <strong>user errors</strong> (which should gracefully revert a transaction) and unexpected <strong>system bugs</strong> (which may require halting the chain to prevent state corruption). The Sovereign SDK provides a clear pattern for this distinction.</p>
<h3 id="1-user-errors-returning-anyhowresult"><a class="header" href="#1-user-errors-returning-anyhowresult">1. User Errors: Returning <code>anyhow::Result</code></a></h3>
<p>For all expected, business-logic-level failures, your <code>call</code> method should return an <code>Err</code> containing an <code>anyhow::Error</code>. These are the errors you anticipate, such as a user attempting to transfer more tokens than they own, calling a method without the proper permissions, or providing invalid parameters.</p>
<p>When you return an <code>Err</code>, the SDK automatically reverts all state changes from the transaction. The goal is to safely reject the invalid transaction while providing a clear error message to the user and developer.</p>
<p>The <code>anyhow</code> crate provides several convenient macros for this. While you can always construct an error with <code>anyhow::anyhow!()</code>, the <code>bail!</code> and <code>ensure!</code> macros are generally preferred for their conciseness.</p>
<ul>
<li><code>bail!(message)</code>: Immediately returns an <code>Err</code>. It's a direct shortcut for <code>return Err(anyhow::anyhow!(message))</code>.</li>
<li><code>ensure!(condition, message)</code>: Checks a condition. If it's false, it returns an <code>Err</code> with the given message. This is perfect for validating inputs and permissions at the start of a function.</li>
</ul>
<p>Here’s how they look in practice, using the <code>Bank</code> module as an example:</p>
<pre><code class="language-rust">// From the Bank module's `create_token` method
fn create_token(
    // ...
) -&gt; Result&lt;TokenId&gt; {
    // Using `ensure!` to validate an input parameter.
    anyhow::ensure!(
        token_decimals &lt;= MAX_DECIMALS,
        "Too many decimal places."
    );

    // Using `bail!` to return an error after a more complex check.
    if initial_balance &gt; supply_cap {
        bail!(
            "Initial balance {} is greater than the supply cap {}",
            initial_balance,
            supply_cap
        );
    }
    // ...
    Ok(token_id)
}</code></pre>
<p><strong>Note:</strong> Because transaction reverts are a normal part of operation, they should be logged at a <code>debug</code> level if necessary, not as warnings or errors.</p>
<h3 id="2-system-bugs-panic"><a class="header" href="#2-system-bugs-panic">2. System Bugs: <code>panic!</code></a></h3>
<p>A <code>panic!</code> is an emergency stop. It should only be used for critical, unrecoverable bugs where a core assumption or invariant of your system has been violated.</p>
<ul>
<li><strong>When:</strong> An impossible state is reached (e.g., total supply becomes negative).</li>
<li><strong>What it does:</strong> Shuts down the rollup node to prevent state corruption.</li>
<li><strong>Goal:</strong> Alert the node operator to a critical software bug that needs immediate attention.</li>
</ul>
<p>Use <code>panic!</code> as your last line of defense. It signals that your module's integrity is compromised and continuing execution would be dangerous.</p>
<h2 id="node-side-logic-with-native-features"><a class="header" href="#node-side-logic-with-native-features">Node-Side Logic with Native Features</a></h2>
<p>A crucial architectural concept in the Sovereign SDK is the distinction between logic that is part of the verifiable state transition and logic that only runs natively on the full node or sequencer. The former must be deterministic and provable in a zkVM, while the latter is used for off-chain tooling like APIs, metrics, and transaction scheduling.</p>
<h3 id="the-native-feature-flag"><a class="header" href="#the-native-feature-flag">The <code>native</code> Feature Flag</a></h3>
<p>Any code that is <strong>not</strong> part of the core state transition must be gated with <code>#[cfg(feature = "native")]</code>:</p>
<pre><code class="language-rust">#[cfg(feature = "native")]
impl&lt;S: Spec&gt; MyModule&lt;S&gt; {
    // This code only compiles natively, not in zkVM
    pub fn debug_state(&amp;self, state: &amp;impl StateAccessor&lt;S&gt;) {
        // ...
    }
}</code></pre>
<p>This ensures that your zk-proofs remain small and your onchain logic remains deterministic. Common use cases for native-only code include:</p>
<ul>
<li>Custom REST APIs and RPC methods</li>
<li>Metrics and logging integration</li>
<li>Debugging tools</li>
<li>Integrations with external services</li>
</ul>
<h3 id="adding-custom-rest-apis"><a class="header" href="#adding-custom-rest-apis">Adding Custom REST APIs</a></h3>
<p>You can easily add custom APIs to your module by implementing the <code>HasCustomRestApi</code> trait. This trait has two methods - one which actually implements the routes, and an optional one which provides an <code>OpenApi</code> spec. You can see a good example in the <code>Bank</code> module:</p>
<pre><code class="language-rust">#![cfg(feature = "native")]
impl&lt;S: Spec&gt; HasCustomRestApi for Bank&lt;S&gt; {
    type Spec = S;

    fn custom_rest_api(&amp;self, state: ApiState&lt;S&gt;) -&gt; axum::Router&lt;()&gt; {
        axum::Router::new()
            .route(
                "/tokens/:tokenId/total-supply",
                get(Self::route_total_supply),
            )
            .with_state(state.with(self.clone()))
    }

    fn custom_openapi_spec(&amp;self) -&gt; Option&lt;OpenApi&gt; {
        let mut open_api: OpenApi =
            serde_yaml::from_str(include_str!("../openapi-v3.yaml")).expect("Invalid OpenAPI spec");
        for path_item in open_api.paths.paths.values_mut() {
            path_item.extensions = None;
        }
        Some(open_api)
    }
}

async fn route_balance(
    state: ApiState&lt;S, Self&gt;,
    mut accessor: ApiStateAccessor&lt;S&gt;,
    Path((token_id, user_address)): Path&lt;(TokenId, S::Address)&gt;,
) -&gt; ApiResult&lt;Coins&gt; {
    let amount = state
        .get_balance_of(&amp;user_address, token_id, &amp;mut accessor)
        .unwrap_infallible() // State access can't fail because no one has to pay for gas.
        .ok_or_else(|| errors::not_found_404("Balance", user_address))?;

    Ok(Coins { amount, token_id }.into())
}</code></pre>
<p>REST API methods get access to an <code>ApiStateAccessor</code>. This accessor provides a read-only view of the latest committed state. While it allows you to call state mutation methods (e.g., <code>set</code>, <code>delete</code>), these changes are temporary and are discarded at the end of the request. This design allows you to reuse view-logic from your module without the risk of accidentally modifying persistent state.</p>
<p>If you implement a custom REST API, your new routes will be automatically nested under your module's router. So, in the following example, the <code>tokens/:tokenId/total-supply</code> function can be found at <code>/modules/bank/tokens/:tokenId/total-supply</code>. Similarly, your OpenApi spec will get combined with the auto-generated one automatically.</p>
<p>Note that for for custom REST APIs, you'll need to manually write an <code>OpenApi</code> specification if you want client support.</p>
<h3 id="adding-legacy-rpc-support"><a class="header" href="#adding-legacy-rpc-support">Adding Legacy RPC Support</a></h3>
<p>In addition to custom RESTful APIs, the Sovereign SDK lets you create JSON-RPC methods. This is useful to provide API compatibility with existing chains like Ethereum and Solana, but we recommend using REST APIs whenever compatibility isn't a concern.</p>
<p>To implement RPC methods, simply annotate an <code>impl</code> block on your module with the <code>#[rpc_gen(client, server)]</code> macro, and then write methods which accept an <code>ApiStateAcessor</code> as their final argument and return an <code>RpcResult</code>. You can see some examples in the <a href="https://github.com/Sovereign-Labs/sovereign-sdk-wip/blob/nightly/crates/module-system/module-implementations/sov-evm/src/rpc/mod.rs#L187"><code>Evm</code> module</a>.</p>
<pre><code class="language-rust">#![cfg(feature = "native")]
#[rpc_gen(client, server)]
impl&lt;S: Spec&gt; Evm&lt;S&gt; {
    /// Handler for `net_version`
    #[rpc_method(name = "eth_getStorageAt")]
    pub fn get_storage_at(
        &amp;self,
        address: Address,
        index: U256,
        state: &amp;mut ApiStateAccessor&lt;S&gt;,
    ) -&gt; RpcResult&lt;U256&gt; {
        let storage_slot = self
            .account_storage
            .get(&amp;(&amp;address, &amp;index), state)
            .unwrap_infallible()
            .unwrap_or_default();
        Ok(storage_slot)
    }
}</code></pre>
<h3 id="transaction-scheduling-for-mev-mitigation"><a class="header" href="#transaction-scheduling-for-mev-mitigation">Transaction Scheduling for MEV Mitigation</a></h3>
<p>For latency-sensitive financial applications, managing transaction order and mitigating Maximum Extractable Value (MEV) is critical. The Sovereign SDK provides a powerful, sequencer-level tool to combat toxic orderflow by allowing developers to introduce fine-grained processing delays for specific transaction types.</p>
<p>This is a powerful technique for applications like on-chain Central Limit Orderbooks (CLOBs). By introducing a small, artificial delay on aggressive "take" orders, a rollup can implicitly prioritize "cancel" orders. This gives market makers a crucial window to pull stale quotes before they can be exploited by low-latency arbitrageurs, leading to fairer and more liquid markets.</p>
<p>This functionality is implemented via the <code>get_transaction_delay_ms</code> method on your <code>Runtime</code> struct. Because this is a sequencer-level scheduling feature and not part of the core state transition logic, it must be gated behind the <code>native</code> feature flag.</p>
<p>The method receives a decoded <code>CallMessage</code> and returns the number of milliseconds the sequencer should wait before processing it. A return value of <code>0</code> means the transaction should be processed immediately.</p>
<h4 id="example-prioritizing-cancels-in-a-clob"><a class="header" href="#example-prioritizing-cancels-in-a-clob">Example: Prioritizing Cancels in a CLOB</a></h4>
<pre><code class="language-rust">// In your-rollup/stf/src/runtime.rs

// In the `impl&lt;S&gt; sov_modules_stf_blueprint::Runtime&lt;S&gt; for Runtime&lt;S&gt;` block:

#[cfg(feature = "native")]
fn get_transaction_delay_ms(&amp;self, call: &amp;Self::Decodable) -&gt; u64 {
    // `Self::Decodable` is the auto-generated `RuntimeCall` enum for your runtime.
    // It has one variant for each module in your `Runtime` struct.
    match call {
        // Introduce a small 50ms delay on all "take" orders to give
        // market makers time to cancel stale orders.
        // (Here, `Clob` is the variant corresponding to the `clob` field in your `Runtime` struct,
        // and `PlaceTakeOrder` is the variant of the `clob` module's `CallMessage` enum.)
        Self::Decodable::Clob(clob::CallMessage::PlaceTakeOrder { .. }) =&gt; 50,

        // All other CLOB operations, like placing or cancelling "make" orders,
        // are processed immediately with zero delay.
        Self::Decodable::Clob(..) =&gt; 0,
        
        // All other transactions in other modules are also processed immediately.
        _ =&gt; 0,
    }
}</code></pre>
<p>This feature gives you precise control over your sequencer's processing queue, enabling sophisticated MEV mitigation strategies without altering your onchain business logic.</p>
<h2 id="mastering-your-module"><a class="header" href="#mastering-your-module">Mastering Your Module</a></h2>
<p>With a solid grasp of module implementation, it's time to focus on performance. The next chapter, <strong>"Understanding Performance,"</strong> dives into the key considerations for building a fast and efficient rollup.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="4-3-wallets-and-accounts.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="4-5-performance.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="4-3-wallets-and-accounts.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="4-5-performance.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
