<!DOCTYPE HTML>
<html lang="en" class="sovereign-dark" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sovereign SDK Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="/assets/sovereign-dark-highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "sovereign-dark" : "sovereign-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('sovereign-dark')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="rollup-devs.html"><strong aria-hidden="true">3.</strong> Rollup Devs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rollup-devs/gas.html"><strong aria-hidden="true">3.1.</strong> Gas</a></li></ol></li><li class="chapter-item expanded "><a href="da-layer.html"><strong aria-hidden="true">4.</strong> DA Layer</a></li><li class="chapter-item expanded "><a href="forced-sequencer-registration.html"><strong aria-hidden="true">5.</strong> Forced Sequencer Registration</a></li><li class="chapter-item expanded "><a href="sdk-contributors.html"><strong aria-hidden="true">6.</strong> SDK Contributors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sdk-contributors/transaction-lifecycle.html"><strong aria-hidden="true">6.1.</strong> Transaction Lifecyle</a></li><li class="chapter-item expanded "><a href="sdk-contributors/abstractions.html"><strong aria-hidden="true">6.2.</strong> Main Abstractions</a></li><li class="chapter-item expanded "><a href="sdk-contributors/gas.html"><strong aria-hidden="true">6.3.</strong> Gas</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="sovereign-dark">Sovereign Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sovereign SDK Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sovereign-sdk-book"><a class="header" href="#the-sovereign-sdk-book">The Sovereign SDK Book</a></h1>
<p>The Sovereign SDK is a modular framework for building rollups. It is designed to
be flexible enough to support <em>any</em> application without sacrificing performance
or ease-of-use.</p>
<p><a href="https://discord.gg/kbykCcPrcA" ><img alt="Discord" src="https://img.shields.io/discord/1050059327626555462?label=discord"/></a></p>
<img src="https://github.com/Sovereign-Labs/sovereign-sdk/blob/nightly/assets/banner.jpg?raw=true" style="border-radius: 10px">
<h2 id="why-rollups"><a class="header" href="#why-rollups">Why Rollups?</a></h2>
<p>As a developer, building your application as a rollup has several advantages:</p>
<ol>
<li><strong>Dedicated throughput:</strong> your users won't pay more just because another app
is generating a lot of transactions.</li>
<li><strong>Scalability:</strong> Sovereign SDK nodes scale seamlessly to thousands of
transactions per second on commodity hardware, and can achieve substantially
higher throughput on optimized hardware.</li>
<li><strong>Incentive alignment:</strong> the vast majority of the rollup fees can be
distributed to users and developers of the rollup, rather than subsidizing
token holders on L1.</li>
<li><strong>MEV mitigation:</strong> since you have full control over your rollup logic, you
can design your protocol to minimize MEV and capture the portions that can't
be eliminated.</li>
<li><strong>Flexibility:</strong> rollups enable you to express whatever logic you want,
without worrying about the needs of other applications. Enable cutting edge
EIPs and account abstraction, or ditch the EVM entirely and build an
app-specific chain. <strong>With a rollup, you're in the driver's seat.</strong></li>
</ol>
<h2 id="why-sovereign"><a class="header" href="#why-sovereign">Why Sovereign?</a></h2>
<p>The Sovereign SDK is the most flexible framework for building rollups. Unlike
other rollup frameworks, the Sovereign SDK supports rollups without a settlement
layer. That means that you can deploy your rollup anywhere - including on
Bitcoin and Celestia. The SDK also provides top-tier scalability and a seamless
user experience, all without sacrificing flexibility. Teams are already using
the Sovereign SDK to build...</p>
<ul>
<li>An EVM chain on Bitcoin</li>
<li>A MoveVM chain on Celestia</li>
<li>Appchains on Solana</li>
</ul>
<p>... and much more.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h2>
<p>Developers write the business logic of their rollup in Rust, and the SDK handles
all of the complexity of creating a rollup on their behalf. Under the hood, the
SDK compiles the chain's business logic to a zero-knowledge circuit, which it
uses to prove correct execution (if the rollup is running in "zk mode") or to
resolve disputes about execution (if the rollup is running in "optimistic
mode"). It also generates a complete <em>full node</em> implementation which can
reproduce the state of the blockchain and serve data to users.</p>
<p>Once the rollup is deployed, users post their <em>transactions</em> onto an underlying
blockchain called a <em>Data Availability Layer</em> ("DA Layer") for ordering. After
transactions are ordered, the <em>full nodes</em> of the rollup execute them to compute
the new rollup <em>state</em>.</p>
<p>Finally, specialized actors called "provers" or "attesters" generate a proof
that the new rollup state was computed correctly and post the proof back onto
the DA layer. This enables clients of the rollup to verify claims about the
rollup state without running a full node for themselves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p><em>TODO. In the meantime, use the <code>sov-rollup-starter</code> repo</em></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollup-devs"><a class="header" href="#rollup-devs">Rollup Devs</a></h1>
<p>This section will provide an overview of the Sovereign SDK aimed at rollup
developers. It will describe the <code>Runtime</code>, <code>Capabilities</code>,
<code>StateValue/Map/Vec</code>, the <code>Module</code> trait, the <code>Gas</code> mechanisms, etc.</p>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gas-overview-and-blessed-values"><a class="header" href="#gas-overview-and-blessed-values">Gas overview and blessed values</a></h2>
<p>Sovereign's SDK transactions should specify gas parameters in a similar way to
Ethereum. When submitting a transaction, you need to specify a handful of gas
parameters (that are stored in a structure called <code>TxDetails</code>) that depend on
the rollup settings but also on the type of call message to execute. We also
have to make sure that the sender holds enough gas tokens in its bank balance to
make sure that the transaction is not rejected due to insufficient funds.
Finally, sequencers need to stake enough tokens to pay for the transaction
pre-execution checks (like signature verification, deserialization, etc.).</p>
<p>This can be quite overwhelming at first glance, hence we provide here a quick
summary of the gas parameters with their respective blessed values (this should
be enough to execute most transactions that are not compute/storage intensive),</p>
<p>First, let's look at the gas parameters that are required to submit a
transaction (in the <code>TxDetails</code> structure):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sov_modules_api::Spec;
use sov_modules_api::transaction::PriorityFeeBips;

/// Contains details related to fees and gas handling.
pub struct TxDetails&lt;S: Spec&gt; {
    /// The maximum priority fee that can be paid for this transaction expressed as a basis point percentage of the gas consumed by the transaction.
    /// Ie if the transaction has consumed `100` gas tokens, and the priority fee is set to `100_000` (10%), the
    /// gas tip will be `10` tokens.
    pub max_priority_fee_bips: PriorityFeeBips,
    /// The maximum fee that can be paid for this transaction expressed as a the gas token amount
    pub max_fee: u64,
    /// The gas limit of the transaction.
    /// This is an optional field that can be used to provide a limit of the gas usage of the transaction
    /// across the different gas dimensions. If provided, this quantity will be used along
    /// with the current gas price (`gas_limit *_scalar gas_price`) to compute the transaction fee and compare it to the `max_fee`.
    /// If the scalar product of the gas limit and the gas price is greater than the `max_fee`, the transaction will be rejected.
    /// Then up to `gas_limit *_scalar gas_price` gas tokens can be spent on gas execution in the transaction execution - if the
    /// transaction spends more than that amount, it will run out of gas and be reverted.
    pub gas_limit: Option&lt;S::Gas&gt;,
    /// The ID of the target chain.
    pub chain_id: u64,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>max_fee</code> parameter is the maximum amount of gas expressed in gas tokens
that can be charged for the transaction execution.</li>
<li>The <code>max_priority_fee</code> parameter is the maximum percentage (expressed in basis
points) of the total gas consumed by the transaction execution that should be
paid to reward the sequencer. This parameter can have any value because there
is a safety mechanism that prevents the user from paying more than the
<code>max_fee</code> in total.</li>
<li>The <code>gas_limit</code> parameter is the maximum amount of gas (expressed in
multidimensional gas units) that can be consumed by the transaction execution.
This parameter is optional and can be left unspecified. In the future, we will
add support for automatically computing this parameter from transaction
simulation.</li>
<li>The <code>user_balance</code> parameter is the balance of the sender's account (for the
gas token) in the rollup's bank.</li>
<li>The <code>sequencer_balance</code> parameter is the balance of the sequencer's account
(for the gas token) in the rollup's bank.</li>
<li>The <code>sequencer_stake</code> parameter is the staked amount of the sequencer in the
<code>sequencer_registry</code> module.</li>
</ul>
<p><em>Blessed gas parameters:</em></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>
<tr><td>max_fee</td><td>100_000_000</td></tr>
<tr><td>max_priority_fee</td><td>any (50_000 is a reasonable choice)</td></tr>
<tr><td>gas_limit</td><td>None</td></tr>
<tr><td>user_balance</td><td>1_000_000_000</td></tr>
<tr><td>sequencer_balance</td><td>1_000_000_000</td></tr>
<tr><td>sequencer_stake</td><td>100_000_000</td></tr>
</tbody></table>
</div>
<p>Note also that:</p>
<ul>
<li>The <code>base_fee_per_gas</code> parameter (whose initial value <code>INITIAL_GAS_LIMIT</code> is
set by the rollup in the <code>constants.toml</code>) roughtly corresponds to the
rollup's gas price and is an internal parameter of the rollup.</li>
<li>A batch can consume up to <code>INITIAL_GAS_LIMIT</code> gas units of gas, and the gas
target is <code>1/ELASTICITY_MULTIPLIER</code> times that value (for each dimension).</li>
<li>The <code>base_fee_per_gas</code> is dynamically adjusted based on the gas consumption of
the batch. The adjustment follows the EIP-1559 which makes it goes down if the
batch consumes more gas than the target (and respectively up if the batch
consumes less gas than the target).</li>
</ul>
<p>The <a href="rollup-devs/../sdk-contributors/gas.html">gas specification</a> provides a detailed
description of the gas mechanisms used within the SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="da-layer"><a class="header" href="#da-layer">DA Layer</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequencer-registration-via-forced-inclusion"><a class="header" href="#sequencer-registration-via-forced-inclusion">Sequencer Registration via Forced Inclusion</a></h1>
<p>Forced inclusion is a strategic mechanism in rollups designed to circumvent
sequencers that censor user transactions. It allows users to directly submit
transaction batches to the <a href="./da-layer.html">Data Availability Layer</a> instead of
going through a sequencer.</p>
<p>The Sovereign SDK supports this feature under specific conditions and
guidelines. Crucially, only "Register Sequencer" transactions are accepted for
forced inclusion; all other types will be ignored. For more details, see the
<a href="forced-sequencer-registration.html#rules">Rules</a> section.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The Sovereign SDK limits the number of batches from unregistered sequencers
processed per rollup slot. This measure limits the use of this mechanism
as a denial-of-service (DOS) attack vector.</p>
<h3 id="process-for-forced-registration"><a class="header" href="#process-for-forced-registration">Process for Forced Registration</a></h3>
<ol>
<li>Create a batch containing a valid "Register Sequencer" transaction.</li>
<li>Submit the batch to the Data Availability layer.</li>
<li>Rollup nodes collect and execute the transaction.</li>
<li>If the transaction complies with all rules, the user is registered as a
sequencer and can submit regular transaction batches.</li>
</ol>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<p>To ensure forced inclusion requests are processed correctly, the following rules
apply:</p>
<ul>
<li><strong>Transaction Limit</strong>: Only the first transaction in each batch is taken into account. Any
additional transactions will be discarded.</li>
<li><strong>Transaction Type</strong>: The transaction must be a "Register Sequencer"
transaction.</li>
<li><strong>Transaction Construction</strong>: The transaction must be properly formatted and
comply with standard transaction rules.</li>
<li><strong>Financial Requirements</strong>: Users must have enough funds to cover:
<ul>
<li>Pre-execution checks (including signature validation, deserialization
and transaction type checks).</li>
<li>Transaction execution costs.</li>
<li>A bond required for sequencer registration.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-contributors"><a class="header" href="#sdk-contributors">SDK Contributors</a></h1>
<p>This section provides an overview of the Sovereign SDK aimed at core
contributors to the framework. It describes the primary components of the SDK at
the level of Rust crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-lifecyle-overview"><a class="header" href="#transaction-lifecyle-overview">Transaction Lifecyle Overview</a></h1>
<p>The transaction lifecycle begins with a <em>user</em>. First, the user opens a frontend
and gets some information about the current state of the blockchain. Then, they
open their wallet and sign a message indicating what action they want to take.</p>
<p>Once a message is signed, it needs to be ordered before full nodes can execute
it, so the user's next step is to contact a <em>sequencer</em> to post the transaction
onto the DA layer.</p>
<p>The sequencer accepts a number of transactions and bundles them into a single
<em><code>Blob</code></em>, which he sends to the DA layer for inclusion. This <code>Blob</code> is
ultimately sent to a <code>Proposer</code> on the DA layer, who includes it in his block
and gets it approved by the DA layer's validator set. Once consensus is reached
on the DA layer block containing the sequencer's <code>Blob</code>, the full nodes of the
rollup parse its contents and execute the transactions, computing a new rollup
state.</p>
<p>Next, specialized actors ("provers" or "attesters") generate a proof of the new
rollup state and post it onto the <code>DA layer</code>. Finally, light clients of the
rollup (end-users and/or bridges on other blockchains) verify the proof and see
the results of the transaction.</p>
<p><img src="sdk-contributors/../assets/tx-lifecycle.png" alt="Diagram of the Transaction Lifecycle" /></p>
<h1 id="sdk-design-philosophy"><a class="header" href="#sdk-design-philosophy">SDK Design Philosophy</a></h1>
<p>Now that we've established the basic transaction lifecycle, we have the
background we need to really dig into the design of the Sovereign SDK.</p>
<p>At a high level, the design process for the SDK was essentially just tracing the
transaction lifecycle diagram and asking two questions at each step:</p>
<ul>
<li>"How do we implement this step so that we really 'inherit the security of the
L1'?"</li>
<li>"Within those constraints, how do we build the SDK to accommodate the broadest
range of use cases?"</li>
</ul>
<h2 id="step-1-retrieving-information"><a class="header" href="#step-1-retrieving-information">Step 1: Retrieving Information</a></h2>
<p>Before doing anything, users need to find out about the current state of the
rollup. How can we enable that?</p>
<p>At this step, we have several conflicting goals and constraints:</p>
<ul>
<li>We want the user's view of the rollup to be as up-to-date as possible</li>
<li>We want to provide the strongest possible guarantees that the user's view of
state is correct</li>
<li>We want to minimize costs for the rollup</li>
<li>Users may not be willing/able to download more than a few hundred kilobytes of
data or do any significant computation</li>
</ul>
<p>Obviously, it's not possible to optimize all of these constraints
simultaneously. So, in the Sovereign SDK, we allow developers some flexibility
to pick the appropriate tradeoffs for their rollups - and we give end-users
additional flexibility to choose the setup that works best for them.</p>
<p>In practice, that means that...</p>
<ul>
<li>Developers can choose between Optimistic and ZK rollups, trading transaction
cost for time-to-finality.</li>
<li>Users can choose between running a full node (instant state access, but
expensive), running a light client (slower state access, but much cheaper and
trustless) and trusting a full node (instant state access)</li>
</ul>
<h2 id="step-2-signing-transactions"><a class="header" href="#step-2-signing-transactions">Step 2: Signing Transactions</a></h2>
<p>The crypto community has fifteen years of experience building wallets for L1
blockchains. That means that existing wallets are much better than anything we
could build in a couple of weeks. But at the same time, the user experience
is... not great. Users lose all of their funds pretty regularly, and they still
have to deal with complexity like storing seed phrases and inspecting
transaction hashes.</p>
<p>So, we've made the pragmatic choice to be as compatible as possible with
existing crypto wallets, while leaving the door open for future improvements.</p>
<p>In rollups built with <code>sov-modules</code>, this is enabled by the
<code>RuntimeAuthenticator</code> abstraction built into the
<a href="sdk-contributors/module-system/sov-modules-stf-blueprint/src/lib.rs"><code>stf-blueprint</code></a>. Using
this trait, we allow rollup developers to bring their own transaction
deserialization and authorization logic. Even better, we allow rollups to
support several different <code>Authenticator</code> implementations simultaneously. This
allows developers to retain backward compatibility with existing wallets,
without giving up the freedom to create specialized transaction formats that
integrate more deeply with the rollup's logic and the wallet interface.</p>
<h2 id="step-3-sequencing"><a class="header" href="#step-3-sequencing">Step 3: Sequencing</a></h2>
<p>Once a user has signed a transaction, we need to broadcast it to all full nodes
of the rollup.</p>
<p>Since a primary design goal is to inherit the security of the underlying
blockchain, we want to ensure that users are always able to fall back on the
censorship resistance of the L1 if necessary. At the same time, we don't expect
users to interact directly with the underlying blockchain in the normal case.
The underlying blockchain will charge fees in its own token, and we don't need
or want users of the rollup to be thinking about exchange rates and L1 gas
limits.</p>
<p>We also need to protect the rollup from spam. In a standard blockchain, spam is
handled by ensuring that everyone pays for the computation that the network does
on their behalf. Transactions with invalid signatures are filtered out at the
peer-to-peer layer and never get included in blocks. This means that an attacker
wanting to spam the rollup has no asymmetric advantage. He can send invalid
transactions to the few nodes he happens to be directly connected to, but they
will just disconnect. The only way to get the <em>entire blockchain network</em> to
process a transaction is to provide a valid signature and pay enough gas fees to
cover the cost of execution.</p>
<p>In a rollup, things are different. Rollups <em>inherit</em> the consensus of an
underlying blockchain <em>which doesn't know about the transaction validity rules
of the rollup</em>. Since the underlying chain doesn't know the rules, it can't
enforce them. So, we need to be prepared to deal with the fact that the rollup's
ledger is <em>dirty</em>. This is bad news, because checking transaction signatures is
expensive - especially in zero-knowledge. If we aren't careful, an attacker
could flood the rollup's ledger with malformed transactions and force the entire
network to pay to check thousands of invalid signatures.</p>
<p>This is where the sequencer comes in. Sequencers accept transactions from users
and bundle them into <code>Blob</code>s, which get posted onto the L1. At the rollup level,
we force all sequencers to register by locking up some tokens - and we ignore
any transactions which aren't posted by a registered sequencer. If a sequencer's
bundle includes any transactions which have invalid signatures, we slash his
deposit and remove him from the registry. This solves two problems at once.
<em>Users</em> don't need to worry about obtaining tokens to pay for inclusion on the
DA layer, and <em>the rollup</em> gets builtin spam protection.</p>
<p>Unfortunately, this setup also gives sequencers a lot of power. Since the
sequencer handles transactions before they've gone through the DA layer's
consensus mechanism, he can re-order transactions - and potentially even halt
the rollup by refusing to publish new transactions.</p>
<p>To mitigate this power, we need to make a couple of adjustments to the protocol.</p>
<p>First, we allow anyone to register as a sequencer depositing tokens into the
sequencer registry. This is a significant departure from most existing rollups,
which rely on a single trusted sequencer.</p>
<p>Second, we allow sequencers to register <em>without sending a transaction through
an existing sequencer</em>. Specifically, we add a rule that the rollup will
consider up to <code>K</code> extra blobs from unregisterd sequencers in each rollup block.
If any of the first <code>K</code> "unregistered" blobs conform to a special format, then
the rollup will interpret them as requests to register a new sequencer. By
capping the number of unregistered blobs that we look at, we limit the
usefulness of unregistered blobs as a DOS vector while still ensuring that
honest sequencers can register relatively quickly in case of censorship.</p>
<p>Finally, we try to make sequencing competitive by distributing some of the fees
from each transaction to the sequencer who included it. This incentivizes new
sequencers to register if the quality of service is low.</p>
<hr />
<p>Ok, that was a lot of information. Let's recap.</p>
<p>In the Sovereign SDK, sequencers are middlemen who post transactions onto the DA
layer, but it's the DA layer which ultimately decides on the ordering of
transactions. Anyone can register as a sequencer, but sequencers expose
themselves to slashing if they include transactions with invalid signatures (or
certain other kinds of obvious spam).</p>
<p>That covers a huge chunk of sequencing. But there are still two topics we
haven't touched on: stateful validation, and soft confirmations.</p>
<h3 id="stateful-validation"><a class="header" href="#stateful-validation">Stateful Validation</a></h3>
<p>Up to this point, we've been talking about transactions as if they're always
either valid or invalid for all time, regardless of what's happening on the
rollup. But in the real world (especially when there are many sequencers),
that's not the case. To give just one example, it's entirely possible for an
account to burn through all of its funds with a single transaction, leaving
nothing to pay gas with the next time around. So, if two sequencers publish
blobs at about the same time, it's very possible that the first blob will cause
some tranasactions in the second one to become invalid.</p>
<p>This complicates our analysis. Previously, we assumed that a sequencer was
malicious if he caused any invalid transactions to be processed. That meant that
we could safely slash his deposit and move on whenever we encountered a
validation error. But now, we can't make that assumption. Otherwise, sequencers
would have to be extremely conservative about which transactions they included -
since a malicious (or confused) user could potentially cause a sequencer to get
slashed by sending conflicting transactions to two different sequencers at the
same time.</p>
<p>On the other hand, we don't want to let sequencers get away with including
transactions that they <em>know</em> are invalid. Otherwise, a malicious sequencer
could include invalid transactions "for free", causing the rollup to do a bunch
of wasted computation.</p>
<p>We address these issues by splitting transasction validation into two
categories. Stateless validation (i.e. signature checks) happens first, and
transactions which fail stateless validation are invalid <em>forever</em>. If a
sequencer includes a transaction which is statelessly invalid, then we know he's
malicious. After a transaction has passed stateless validation, we proceed to
make some stateful checks (i.e. checking that the transaction isn't a duplicate,
and that the account has enough funds to pay for gas). If these checks fail, we
charge the sequencer a small fee - just enough to cover the cost of the
signature check.</p>
<p>This ensures that sequencers are incentivized to do their best to filter out
invalid transactions, and that the rollup never does any computation without
getting paid for it without being unfairly punitive.</p>
<h3 id="soft-confirmations"><a class="header" href="#soft-confirmations">Soft Confirmations</a></h3>
<p>Now that we've talked about the minimum requirements for sequencer, we move on
to soft-confirmations.</p>
<p>One of the biggest selling points of rollups today is the ability to tell users
the outcome of the tranaction instantly. Under the hood, this experience is
enabled by giving a single trusted sequencer a "lock" on the rollup state.
Because he holds the lock, the sequencer can run a local simulation to determine
the exact effect of a transaction <em>before</em> he posts it on the DA layer.</p>
<p>Unfortunately, this introduces a load bearing point of centralization. If the
centralized sequencer becomes unavailable (or is malicious), the rollup halts
and users have little recourse.</p>
<p>On existing rollups, this issue is somewhat mitigated by providing an "inbox" on
the DA layer where users can send special "forced withdrawal" transactions.
However, in most existing rollups these "forced" transactions are significantly
less powerful than ordinary ones. (Users are often limited to only withdrawing
funds) and the delay period before they are processed is long.</p>
<p>In the Sovereign SDK, we try to do better. Unfortunately, there's no way to
enable soft confirmations without giving some entity a lock on (some subset of)
the rollup state. So, this is exactly what we do. We allow rollup deployers to
specify some special "preferred sequencer", which has a partial lock on the
rollup state.</p>
<p>In order to protect users in case of a malicious sequencer, though, we make a
few additional changes to the rollup.</p>
<p>First, we separate the rollup state into two subsets, "user" space and "kernel"
space. The kernel state of the rollup is maintained programatically, and it
depends directly on the headers of the latest DA layer blocks. Inside of the
protected kernel state, the rollup maintains a list of all the blobs that have
appeared on the DA layer, and the block number in which they appeared.</p>
<p>Second, we prevent access to the kernel state of the rollup during transaction
execution. This prevents users from creating transactions that could
accidentally invalidate soft-confirmations given by the sequencer, as well as
preventing the sequencer from deleting forced transactions before they can be
processsed.</p>
<p>Finally, we add two new invariants:</p>
<ol>
<li>
<p>Every blob which appears on the (canonical) DA chain will be processed within
some fixed number of blocks</p>
</li>
<li>
<p>All "forced" (non-preferred) transactions will be processed in the order they
appeared on the DA layer</p>
</li>
</ol>
<p>To help enforce these invariants, we add a concept of a "virtual" slot number.
The virtual slot number is a nondecreasing integer which represents block number
that the preferred sequencer observed when he started building his current
bundle. Any "forced" blobs which appear on the DA layer are processed when the
virtual slot number advances beyond the number of the <em>real</em> slot in which they
appeared.</p>
<p>Inside the rollup, we enforce that...</p>
<ul>
<li>
<p>The virtual slot number never lags behind the real slot number by more than
some constant <code>K</code> slots</p>
<ul>
<li>This ensures that "forced" transactions are always processed in a reasonable
time frame</li>
</ul>
</li>
<li>
<p>The virtual slot number increments by <em>at least</em> one every time the preferred
sequencer succesfully submits a blob. The sequencer may increment the virtual
slot by more than one.</p>
</li>
<li>
<p>The virtual slot number is never greater than the current (real) slot
number</p>
</li>
<li>
<p>Transactions may only access information about the DA layer that was known at
the time of their <em>virtual</em> slot's creation. Otherwise, users could write
transactions whose outcome couldn't be predicted, making it impossible to give
out soft confirmations. - For example, a user could say
<code>if current_block_hash % 2 == 1 { do_something() }</code>, which has a different
outcome depending on exactly which block it gets included in. Since the rollup
sequencer is not the L1 block proposer, he doesn't know what block the
transaction will get included in! By limiting transactions to accessing
historical information, we avoid this issue.</p>
</li>
</ul>
<p>What all of this means in practice is that...</p>
<ul>
<li>The visible state never changes unless either the preferred sequencer submits
a bundle, or a timeout occurs (i.e. the virtual slot lags too far). This
ensures that the preferred sequencer always knows the exact state that he's
building on top of.</li>
<li>An honest sequencer wants to keep the virtual slot number as close to the real
slot number as possible. This way, he has more buffer to absorb downtime
without the state changing. This reduces the risk of soft-confirmations being
invalidated.</li>
<li>Honest sequencers can always give accurate soft confirmations, unless the DA
layer experiences a liveness failure lasting more than <code>K</code> slots.</li>
<li>Transactions can access information about the underlying blockchain with the
best latency that doesn't invalidate soft confirmations.</li>
</ul>
<h3 id="handling-preferred-sequencer-failure"><a class="header" href="#handling-preferred-sequencer-failure">Handling Preferred Sequencer Failure</a></h3>
<p>With the current design, the Sovereign SDK supports soft confirmations while
providing a reasonably powerful forced transaction mechanism. We also provide
some limited protection from a malicious sequencer. If the sequencer is
malicious, he can - at worst - delay transaction processing by some constant
number of blocks. He can't prevent forced transactions from being processed, and
he can't selectively delay transactions.</p>
<p>We also provide some limited protection if the preferred sequencer commits a
slashable offense. In this case, the rollup enters "recovery mode", where it
reverts to standard "based" sequencing (where all sequencer are equal). In this
mode, it advances the virtual slot number two-at-a-time until the rollup is
caught up, at which point the rollup behaves as if there had never been a
preferred sequencer.</p>
<p>In the future, we may also add slashing if the preferred sequencer gives
"soft-confirmations" which turn out to be invalid, but this requires some
additional design work.</p>
<h2 id="step-4-execution"><a class="header" href="#step-4-execution">Step 4: Execution</a></h2>
<p>Once a transaction is sequenced, the rollup needs to process it.</p>
<p>At a high level, a Sovereign SDK transaction goes through the following
sequence:</p>
<ol>
<li>
<p>(Stateless) Deserialization: Decoding the bytes of the transaction into
meaningful components (signature, ChainID, etc)</p>
</li>
<li>
<p>(Stateful) Pre-validation: Checking that the address which is claiming to
have authorized the transaction exists and retrieving its preferences for
authorization. For example, if the address is a multisig, fetch the set of
public keys and the minimum number of signatures.</p>
</li>
<li>
<p>(Stateless) Authentication: Checking that the transaction is authorized. For
example, checking that the signatures are valid.</p>
</li>
<li>
<p>(Stateful) Authorization: Matching the results of the authentication and
pre-validation steps to decide whether to execute. This step also reserves
the funds to pay for gas used during transaction execution. --- State changes
up to this point are irreversable. State changes beyond this point are either
committed or reverted together</p>
</li>
<li>
<p>(Stateful) Pre-dispatch hook: This hook allows <em>all</em> modules to inspect the
transaction (and their own state) and do initialization before the
transaction is executed. For example, a wallet module might use this hook to
check the user's balance and store it for later retrieval. This hook may
abort the transaction and revert any state changes by returning an <code>Error</code>.</p>
</li>
<li>
<p>(Stateful) Execution: The transaction is dispatched to a <em>single</em> target
module for execution. That module may invoke other modules if necessary
during execution. If this call returns an error, all state changes from step
5 onward are reverted.</p>
</li>
<li>
<p>(Stateful) Post-dispatch hook: This hook allows <em>all</em> modules to inspect
their state and revert the transaction if necessary. If this call returns an
error, all state changes from step 5 onward are reverted.</p>
</li>
<li>
<p>(Stateful) Post-execution: After transaction execution, any unused gas is
refunded to the payer</p>
</li>
</ol>
<p>As described in the "Sequencing" documentation, sequencers are slashed if any of
the two stateless steps fail. If either of the stateful steps prior to execution
fail, the sequencer is penalized - but just enough to cover the cost of the work
that has been done. If the transaction fails during execution, the costs are
paid by the user (or whichever entity is sponsoring the gas cost of the
transaction.)</p>
<p>For more details on execution, see [TODO]</p>
<h2 id="step-5-proving"><a class="header" href="#step-5-proving">Step 5: Proving</a></h2>
<p>Once a transaction is executed, all of the rollup <em>full nodes</em> know the result
instantly. Light clients, on the other hand need proof. In this section, we'll
describe the different kinds of proof that the Sovereign SDK offers.</p>
<h3 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero-Knowledge Proofs</a></h3>
<p>The most powerful configuration for a rollup is zero-knowledge mode. In this
mode, light clients can trustlessly sync the chain with near-zero overhead and
only minutes of lag behind the chain tip. This enables fast and trustless
bridging between rollups, and between the rollup and the execution environment
of its DA layer (if applicable).</p>
<p>In the Sovereign SDK, proving is asynchronous (meaning that we post raw
<em>transactions</em> on the DA layer - so that full nodes can compute the rollup state
even before a proof is generated). This means that light clients have a view of
the state that lags a little bit behind full nodes.</p>
<h4 id="proof-statements"><a class="header" href="#proof-statements">Proof Statements</a></h4>
<p>All zero-knowledge proofs have the form, "I know of an input such that...". In
our case, the full statement is:</p>
<blockquote>
<p>I know of a DA layer block with hash X (where X is a public input to the
proof) and a rollup state root Y (where Y is another public input) such that
the rollup transitions to state Z (another public input) when you apply its
transaction processing rules.</p>
</blockquote>
<p>To check this proof, a client of the rollup needs to check that the input block
hash X corresponds to the next DA layer block, and that the input state root Y
corresponds to the current rollup state. If so, the client can advance its view
of the state from Y to Z.</p>
<p>This works great for a single block. But if a client needs to validate the
entire history of the rollup, checking proofs of each block would get expensive.
To alleviate this problem, we use recursive proofs to compress multiple block
proofs into one. (A nice property of zero-knowledge proofs is that the work to
verify a proof is roughly constant - so checking this recursive "aggregate"
proof is no more expensive than checking the proof of a single block.)</p>
<p>Each <code>AggregateProof</code> is a statement of the form:</p>
<blockquote>
<p>I know of a (previous) valid <code>AggregateProof</code> starting from <code>A</code> (the genesis
block hash, a public input) with state root <code>B</code> (the rollup's genesis state, a
public input) and ending at block hash <code>C</code> with state root <code>D</code>. And, I know of
a sequence of valid proofs such that...</p>
<ul>
<li>For each proof, the block header has the property that <code>header.prev_hash</code> is
the hash of the previous header</li>
<li>For each proof, the input state root is the output root of the previous
root.</li>
<li>The block header from the first proof has <code>prev_hash == C</code></li>
<li>The first proof has has input state root <code>D</code></li>
<li>The final proof in the chain has block hash <code>A</code> and output root <code>B</code> (where
<code>A</code> and <code>B</code> are public inputs)</li>
</ul>
</blockquote>
<h4 id="incentives"><a class="header" href="#incentives">Incentives</a></h4>
<p>Generating zero-knowledge proofs is expensive. So, if we want proofs to be
generated, we need to incentivize proof creation in protocol, preferrably using
the gas fees that users are already paying.</p>
<p>In a standard blockchain, the goal of transaction fees markets is to maximize
consumer surplus. They achieve this by allocating a scarce resource (blockspace)
to the people who value it most. Analysis shows that EIP-1559 is extremely good
at solving this optimization problem in the setting where supply is fixed and
demand varies rapidly. EIP-1559 adjusts the price of blockspace to the exact
price level at which demand matches supply.</p>
<p>In zk-rollups, we have a slightly different setup. Our supply of blockspace is
not constant. Instead, it's possible to invest more money in proving hardware in
order to increase the rollup's throughput. However, bringing more prover
capacity online takes time. Deals have to be negotiated, hardware provisioned,
etc. So, in the short term, we model prover capacity as being fixed - and we use
EIP-1559 to adjust demand to fit that target.</p>
<p>In the long run, we want to adjust the gas limit to reflect the actual capacity
of available provers. To facilitate this, we track the rollup's gas usage and
proving throughput (measured in gas per second) over time. If rollup blocks are
full and provers are able to keep up, we gradually increase the gas limit until
blocks are no longer full or provers start to fall behind.</p>
<p>This still leaves one problem... how do we incentivize provers to bring more
hardware online? After all, adding more hardware increases the gas limit, which
increases the supply of blockspace. This causes congestion (and fees) to fall,
increasing consumer surplus. But provers don't get paid in consumer surplus,
they get paid in fees. So, adding more hardware hurts <em>provers</em> in two ways. It
increases their costs, and it reduces the average fee level. This means that
provers are incentivized to provide as little capacity as possible.</p>
<p>The way we handle this problem is by introducing competition. In Sovereign, we
only reward the <em>first</em> prover to publish a valid proof of a block. Since
proving is almost perfectly parallel, and provers are racing to prove the block
first, a prover which adds slightly more capacity than its rivals experiences a
disproportionate increase in rewards. This should encourage provers to bring as
much capacity as possible.</p>
<p>Since we want to reward provers with funds on the rollup, we need consensus.
(Otherwise, it would be trivial to cause a chain split by creating a fork which
sent some rewards to a different prover.) So, we require provers to post their
proofs on chain. The first prover to post a valid proof of a particular block
gets rewarded with the majority of the <code>base_fee</code>s collected from that block.
This is a deviation from EIP-1559, where all base fees are burned. Intuitively,
our construction is still safe because provers "burn" money in electricity and
hardware costs in order to create proofs. However, we also burn a small
proportion of base fees as insurance in case proving costs ever fall to
negligble levels.</p>
<p>Once a prover has posted his proof on the DA layer, two things happen. First,
full nodes read the proof and, if it's valid reward the prover. If it's invalid,
the prover has his deposit slashed. (Just like a misbehaving sequencer. Also
like sequencers, data posted by un-bonded entities is ignored.) Second, light
clients of the rollup download and verify the proof, learning the state of the
rollup. As an implementation detail, we require proofs which get posted on chain
to be domain separated, so that light clients can download just the proofs from
a rollup without also needing to fetch all of the transaction data.</p>
<h4 id="summary-the-proving-workflow"><a class="header" href="#summary-the-proving-workflow">Summary: The proving workflow</a></h4>
<p>So, putting this all together, the proving workflow looks like this:</p>
<ol>
<li>
<p>A DA layer block is produced at height <code>N</code>. This block contains some rollup
transactions.</p>
</li>
<li>
<p>Full nodes immediately process the transactions and compute a new state.</p>
</li>
<li>
<p>Provers begin generating a proof of block <code>N</code>.</p>
</li>
<li>
<p>(About 15 minutes later) a prover creates a valid proof of block <code>N</code>. In the
meantime, DA layer blocks <code>N+1</code> through <code>N+X</code> have been produced.</p>
<p>a. At this point, full nodes are aware of rollup state <code>N+X</code>, while light
clients are still unaware of <code>N</code></p>
</li>
<li>
<p>The prover creates a new <code>AggregateProof</code>, which...</p>
<p>a. Proves the validity of the proof of block <code>N</code></p>
<p>b. Proves the validity of the previous <code>AggregateProof</code> (which covered the
rollup's history from genesis to block <code>N-1</code>)</p>
<p>c. Optionally proves the validity of proofs of blocks <code>N+1</code>, <code>N+2</code>, ...,
<code>N+X</code>, if such proofs are available. (Note that the <code>AggregateProof</code> must
cover a contiguous range of blocks starting from genesis, but it may cover
any number of blocks subject to that constraint.) For concreteness, suppose
that in this case the prover includes blocks <code>N+1</code> through <code>N+5</code>.</p>
</li>
<li>
<p>The prover posts the new <code>AggregateProof</code> onto the DA layer at some height -
call it <code>N+30</code>. At this point, full nodes are aware of state <code>N+30</code> (which
includes a reward for the prover), and light clients are aware of state
<code>N+5</code>. At some point in the future, a proof of <code>N+30</code> will be generated, at
which point light clients will become aware of the prover's reward.</p>
</li>
</ol>
<h3 id="optimistic-proofs"><a class="header" href="#optimistic-proofs">Optimistic Proofs</a></h3>
<p>For some rollups, generating a full zero-knowledge proof is too expensive. For
these applications, the Sovereign SDK offers Optimistic Mode, which allows
developers to trade some light-client latency for lower costs. With a zk-rollup,
light clients have a view of the state which lags behind by about 15 minutes
(the time it takes to generate a) zero- knowledge proof. However, at the end of
those 15 minutes, light clients know the state with cryptographic certainty.</p>
<p>In an optimistic rollup, light clients have a different experience. They get
some indication of the new rollup state very quickly (usually in the very next
block), but they need to wait much longer (usually about a day) to be sure that
their new view is correct. And, even in this case, clients only have
"cryptoeconomic" certainty about the new state.</p>
<h4 id="proving-setup"><a class="header" href="#proving-setup">Proving Setup</a></h4>
<p>In an optimistic rollup, the "proofs" checked by light clients are not (usually)
proofs at all. Instead, they are simple attestations. Attesters stake tokens on
claims like "the state of the rollup at height <code>N</code> is <code>X</code>", and anyone who
successfully challenges a claim gets to keep half of the staked tokens. (The
other half are burned to prevent an attester from lying about the state and then
challenging himself from another account and keeping his tokens). In exchange,
for their role in the process, attesters are rewarded with some portion of the
rollup's gas fees. This compensates attesters for the opportunity cost of
locking their capital.</p>
<p>This mechanism explains why light clients can know the state quickly with <em>some</em>
confidence right away, but they take time to reach full certainty. Once they've
seen an attestation to a state, clients know that either the state is correct,
or the attester is going to lose some amount of capital. As time goes by and no
one challenges the assertion, their confidence grows until it reaches (near)
certainty. (The point at which clients are certain about the outcome is usually
called the "finality period" or "finality delay".)</p>
<p>The previous generation of optimistic rollups (including Optimism and Arbitrum)
relies on running an on-chain bisection game over an execution trace to resolve
disputes about the rollup state. This requires $log_2(n)$ rounds of interaction,
where <code>n</code> is the length of the trace (i.e. a few hundred million). To handle the
possibility of congestion or censorship, rollups need to set the timeout period
of messages conservatively - which means that a dispute could take up to a week
to resolve.</p>
<p>In the Sovereign SDK, we resolve disputes by generating a zero-knowledge proof
of the outcome of the disputed block. Since this only requires one round of
interaction, we don't need the same challenge delay. However, we do need to
account for the fact that proving is a heavy process. Generating a proof might
take a few hours, and proving services might be experiencing congestion. To
minimize the risk, we plan to set the finality period conservatively at first
(about one day) and reduce it over time as we gain confidence.</p>
<p>Otherwise, the overall proving setup is quite similar to that of a zk-rollup.
Just as in zk-rollups, proofs (and attestations) are posted onto the DA layer so
that we have consensus about who to reward and who to slash. And, just like a
zk-rollup, optimistic proofs/attestations are posted into a separate "namespace"
on the DA layer (if possible) so that light clients can avoid downloading
transaction data. The only other significant distinction between optimistic and
zk rollups in Sovereign is that optimistic rollups use block-level proofs to
resolve disputes instead of generating aggregate proofs which go all the way to
genesis.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In the Sovereign SDK, we try to provide security, flexibility, and performance
<em>in that order</em>.</p>
<p>As a contributor, it's your job to maintain that hierarchy. Security must always
come first. And in blockchain, security is mostly about incentives. Especially
in blockchain, you get what you incentivize. If your rollup under-prices some
valuable resource, you'll get spam. If you under pay for some service, that
service won't be provided reliably.</p>
<p>This is why incentive management is so deeply baked into the SDK. Every step -
from sequencing to proving to execution to finality - needs to be carefully
orchestrated to keep the incentives of the participants in balance.</p>
<p>Once the setup is secure, our next priority is enabling the broadest set of use
cases. We try to provide maximum flexibility, and abstract as much functionality
as possible into reusable components. You can read more about how we achieve
flexibility at the level of Rust code in the <a href="sdk-contributors/./abstractions.html">abstractions</a>
chapter.</p>
<p>Finally, we optimize performance. This means eliminating redundant computation,
carefully managing state access patterns, and considering the strengths and
weaknesses of zero-knowledge proofs systems.</p>
<p>Happy hacking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="main-abstractions"><a class="header" href="#main-abstractions">Main Abstractions</a></h1>
<blockquote>
<p>This document provides an overview of the major abstractions offered by the SDK.</p>
<ul>
<li>Rollup Interface (STF + DA service + DA verifier)</li>
<li>sov-modules (<code>Runtime</code>, <code>Module</code>, stf-blueprint w/ account abstraction, state abstractions)</li>
<li>sov-sequencer</li>
<li>sov-db</li>
<li>Rockbound</li>
</ul>
</blockquote>
<p>One of the most important principles in the Sovereign SDK is modularity. We believe strongly in separating
rollups into their component parts and communicating through abstract interfaces. This allows us to iterate
more quickly (since components are unaware of the implementation details of other components), and it also
allows us to reuse components in contexts which are often quite different from the ones in which they were
orginally designed.</p>
<p>In this chapter, we'll give a brief overview of the core abstractions of the Sovereign SDK</p>
<h2 id="native-vs-zk-execution"><a class="header" href="#native-vs-zk-execution">Native vs. ZK Execution</a></h2>
<p>Perhaps the most fundamental abstraction in Sovereign is the separation between <code>"native"</code> code execution
(which computes a new rollup state) and zero-knowledge <em>verification</em> of that state. Native execution is
the experience you're used to. In native execution, you have full access to networking, disk, etc. In
native mode, you typically trust data that you read from your own database, but not data that comes over
the network.</p>
<p>Zero-knowledge execution looks similar. You write normal-looking Rust code to do CPU and memory
operations - but under the hood, the environment is alien. In zero-knowledge execution, disk
and network operations are impossible. Instead, all input is received from the (untrusted)
machine generating the proof via a special syscall. So if you make a call that looks like a network access,
you might not get a response from <code>google.com</code>. Instead, the prover will pick some arbitrary bytes to
give back to you. The bytes might correspond to an actual response (i.e. if the prover is honest
and made the network request for you) - but they might also be specially crafted to deceive you.
So, in zero-knowledge mode, great care must be taken to avoid relying on unverified data from the
prover.</p>
<p>In the Sovereign SDK, we try to share code between the <code>"native"</code> full node implementation and the
zero-knowledge environment to the greatest extent possible. This minimizes surface area for bugs.
However, a full node necessarily needs a lot of logic which is unnecessary (and undesirable) to
execute in zero-knowledge. In the SDK, such code is gated behind a <code>cargo</code> feature called <code>"native"</code>.
This code includes RPC implementations, as well as logic to pre-process some data into formats which
are easier for the zero-knowledge code to verify.</p>
<h2 id="the-rollup-interface"><a class="header" href="#the-rollup-interface">The Rollup Interface</a></h2>
<p>If you squint hard enough, a zk-rollup is made of three separate components. There's an underlying
blockchain ("Data Availability layer"), a set of transaction execution rules ("a State Transition Function")
and a zero-knowledge proof system (a "ZKVM" for zero-knowledge virtual machine). In the abstract, it seems
like it should be possible to take the same transaction processing logic (i.e. the EVM) and deploy it on
top of many different DA layers. Similarly, you <em>should</em> be able to take the same execution logic and compile
it down to several different proof systems - in the same way that you can take the same code an run it on
Risc0 or SP1.</p>
<p>Unfortunately, separating these components can be tricky in practice. For example, the OP Stack relies on an
Ethereum smart contract to enforce its censorship resistance guarantees - so, you can't
easily take an OP stack rollup and deploy it on a non-EVM chain.</p>
<p>In the Sovereign SDK, flexibility is a primary design goal. So we take care to codify this separation of concerns
into the framework from the very beginning. With Sovereign, it's possible to run any <code>State Transition Function</code>
alongside any <code>Da Service</code> on top of any (rust-compatible) proof system and get a functional rollup.
The <code>rollup-interface</code> crate is what makes this possible. Every other crate in the SDK depends on it,
because it defines the core abstractions that are shared between all SDK rollups.</p>
<p><img src="sdk-contributors/../assets/dependency-graph.png" alt="A digram showing how the rollup interface supports the entire Sovereign SDK" /></p>
<p>Inside of the rollup interface, the <code>native</code> vs zero-knowledge distinction appears in numerous places. For example,
the <code>DA layer</code> abstraction has two components - a <code>DaService</code>, which runs as part of <code>native</code> full node execution and
provides methods for fetching data from the underlying blockchain; and <code>DaVerifier</code>, which runs in zero-knowledge
and verifies that the data being executed matches the provided DA block header.</p>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it Works</a></h3>
<p>Essentially, the Sovereign SDK is just a generic function that does this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rollup&lt;Da: DaService, Zk: Zkvm, Stf: StateTransitionFunction&gt;(self, da: Da, zkvm: Zk, business_logic: Stf) {
	loop {
		// Run some `native` code to get the data for execution
		let (block_data, block_header) = da.get_next_block();
		let (input_state, input_state_root) = self.db.get_state();
		// Run some zero-knowledge code to execute the block
		let proof = zkvm.prove(|| {
			// Check that the inputs match the provided commitments
			if !da.verify(block_data, block_header) || !input_state.verify(input_state_root) {
				panic!()
			};
			// Make the data commitments part of the public proof
			output!(block_header.hash(), input_state_root)
			let output_state_root = business_logic.run(block_data, input_state);
			// Add the output root to the public proof
			output!(output_state_root)
		});
		// Publish the proof onto the DA layer
		da.publish(proof);
	}
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, most of the heavy lifting is done by the DA layer, the <code>Zkvm</code> and the rollup's business logic.
The full node implementation is basically just glue holding these components together.</p>
<h3 id="da"><a class="header" href="#da">DA</a></h3>
<p>As discussed above, the role of the DA layer is to order and publish data. To integrate with the Sovereign SDK,
a DA layer needs to provide implementations of two core traits: <code>DaService</code> and <code>DaVerifier</code>.</p>
<h4 id="da-service"><a class="header" href="#da-service">DA Service</a></h4>
<p>The <code>DaService</code> trait is usually just a thin wrapper around a DA layer's standard RPC client. This trait
provides standardized methods for fetching data, generating merkle proofs, and publishing data. Because
it interacts with the network, correct execution of this trait is <em>not</em> provable in zero-knowledge.</p>
<p>Instead, the work of verifying of the data provided by the <code>DaService</code> is offloaded to the <code>DaVerifier</code> trait.
Since the <code>DaService</code> runs only in <code>native</code> code, its implementation is less concerned about efficiency than
zero-knowledge code. It's also easier to patch, since updating the <code>DaService</code> does <em>not</em> require any light
clients or bridges to update.</p>
<p>The <code>DaService</code> is the only component of the SDK responsible for publishing and fetching data. The SDK's node
does not currently have a peer-to-peer network of its own. This dramatically simplifies the full node and reduces
bandwidth requirements.</p>
<h3 id="da-verifier"><a class="header" href="#da-verifier">DA Verifier</a></h3>
<p>The <code>DaVerifier</code> is the zero-knowledge-provable counterpart of the <code>DaService</code>. It is responsible for checking
that the (untrusted) private inputs to a proof match the public commitment <em>as efficiently as possible</em>. It's common
for the <code>DaVerifier</code> to offload some work to the <code>DaService</code> (i.e. as computing extra metadata) in order to reduce
the amount of computation required by the <code>DaVerifier</code>.</p>
<p>At the level of <code>Rust</code> code, we encode the relationship between the <code>DaVerifier</code> and the <code>DaService</code> using a helper
trait called <code>DaSpec</code> - which specifies the types on which both interfaces operate.</p>
<h4 id="zero-knowledge-virtual-machine-zkvm"><a class="header" href="#zero-knowledge-virtual-machine-zkvm">Zero Knowledge Virtual Machine ("<code>Zkvm</code>")</a></h4>
<p>The <code>Zkvm</code> traits make a zk-snark system (like <code>Risc0</code> or <code>Sp1</code>) compatible with the Sovereign SDK. Like the <code>DA layer</code>, we
separate <code>Zkvm</code> traits into a <code>native</code> and zk version, plus a shared helper.</p>
<p>The <code>ZkvmHost</code> trait describes how a <code>native</code> computer executes an <code>elf</code> file (generated from <code>Rust</code> code) and generates
a zero-knowledge proof. It also describes how the <code>native</code> machine passes private inputs (the "witness") into the execution.</p>
<p>The <code>ZkvmGuest</code> trait describes how a program running in zero-knowledge mode accepts inputs from the host machine.</p>
<p>Finally, the <code>Zkvm</code> trait describes how a proof generated by the host is verified. This trait is implemented by both the
<code>Host</code> and the <code>Guest</code>, which is how we represent that proofs must be verifiable <code>native</code>ly and recursively (i.e. inside
another SNARK.)</p>
<h4 id="state-transition"><a class="header" href="#state-transition">State Transition</a></h4>
<p>A <code>StateTransitionFunction</code> ("STF") is a trait which describes:</p>
<ol>
<li>
<p>How to initialize a rollup's state at genesis</p>
</li>
<li>
<p>How to apply the data from the DA layer to generate a new state</p>
</li>
</ol>
<p>In other words, the implementation of <code>StateTransitionFunction</code> is what defines the rollup's "business logic".</p>
<p>In the Sovereign SDK, we define a generic full node which can run any STF. As long as your logic implements the
interface, we should be able to run it.</p>
<p>However, implementing the business logic of a rollup is <em>extremely</em> complicated. While it's relatively easy to
roll your own implementation of the <code>Da</code> or <code>Zkvm</code> traits, building a secure STF from scratch is a massive undertaking.
It's so complex, in fact, that we assume no one will ever do it - andthe vast majority of the Sovereign SDK's code is
devoted to providing a generic implementation of an STF that developers can customize. (This STF is what we call the
Sovereign module system, or sov-modules).</p>
<p>So if no one is ever going to implement the <code>StateTransitionFunction</code> interface, why bother maintaining it at all?
One reason is for flexibility. Just because we don't expect anyone to roll their own STF doesn't mean that they won't.
But a bigger motivation is to keep concerns separate. By hiding the implementation details of the rollup behind the
STF interface, we build a firm abstraction barrier between it and the full node. This means that we're free to make
breaking changes on either side of the wall (either in the node, or in the STF) without worrying about breaking the
other component.</p>
<h2 id="sov-modules"><a class="header" href="#sov-modules">Sov Modules</a></h2>
<p>Outside of the rollup interface, the most important abstraction is <code>sov-modules</code>. <code>sov-modules</code> is a pre-built STF
with pluggable... modules. It does the heavy lifting of implementing a secure STF so that you can focus on the core
logic of your application.</p>
<h3 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h3>
<p>At the heart of any sov-modules rollup is the <code>Runtime</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An example runtime similar to the one used in our "standard" demo rollup
pub struct Runtime&lt;S: Spec, Da: DaSpec&gt; {
    /// The Bank module implements fungible tokens, which are needed to charge `gas`
    pub bank: sov_bank::Bank&lt;S&gt;,
    /// The Sequencer Registry module is where we track which addresses can send batches to the rollup
    pub sequencer_registry: sov_sequencer_registry::SequencerRegistry&lt;S, Da&gt;,
    /// The Prover Incentives module is where we reward provers who do useful work
    pub prover_incentives: sov_prover_incentives::ProverIncentives&lt;S, Da&gt;,
    /// The Accounts module implements identities on the rollup. All of the other modules rely on it
	/// to link cryptographic keys to logical accounts
    pub accounts: sov_accounts::Accounts&lt;S&gt;,
	/// The NFT module provides an implementation of a non-fungible token standard. It's totally optional.
    pub nft: sov_nft_module::NonFungibleToken&lt;S&gt;,
    #[cfg_attr(feature = "native", cli_skip)]
    /// The EVM module lets the rollup run Ethereum smart contracts. It's totally optional.
    pub evm: sov_evm::Evm&lt;S, Da&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>At the highest level, a runtime is "just" a collection of all the modules which are included in your rollup.
Its job is to take <code>Transaction</code>s and dispatch them to the appropriate module for execution.</p>
<p>Pretty much all rollups built with the <code>sov-modules</code> include the bank, the sequencer registry, and the accounts
module in their <code>Runtime</code>. They also usually include one of <code>sov_prover_incentives</code>
(if they're a zk-rollup) or <code>sov_attester_incentives</code> (if they're an Optimistic rollup).</p>
<p>You may also have noticed that the <code>Runtime</code> is generic over two types - a <code>Spec</code> and a <code>DaSpec</code>. These two types
describe the core types (addresses, hashers, cryptography) used by the rollup and the DA layer respectively.
Making your runtime generic over a Spec means that you can easily change DA layers, or swap any of the core
primitives of your rollup. For example, a rollup can trivially switch from Ed25519 to secp256k1 for its
signature scheme by changing the implementation of its <code>Spec</code> trait.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>"Modules" are the things that process transactions. For example, the <code>Bank</code> module lets users transfer tokens
to each other. And the <code>EVM</code> module implements a full Ethereum Virtual Machine that can process any valid Ethereum
transaction.</p>
<p>A <code>Module</code> is just a rust <code>struct</code> that implements two traits called <code>Module</code> and <code>ModuleInfo</code>.</p>
<h4 id="the-module-trait"><a class="header" href="#the-module-trait">The <code>Module</code> trait</a></h4>
<p>The <code>Module</code> trait is like a simplified version of the <code>StateTransitionFunction</code>. It describes how to
initialize the module at the rollup's genesis, and how the module processes <code>CallMessage</code>s received
from users (i.e. how it processes transactions)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Module {
	// -- Some associated type definitions are omitted here --
	/// Module defined argument to the call method.
    type CallMessage: Debug;

    /// Genesis is called when a rollup is deployed and can be used to set initial state values in the module.
    fn genesis(
        &amp;self,
        _config: &amp;Self::Config,
        _working_set: &amp;mut WorkingSet&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;

    /// Call allows interaction with the module and invokes state changes.
    /// It takes a module defined type and a context as parameters.
    fn call(&amp;self,
        _message: Self::CallMessage,
        _context: &amp;Context&lt;Self::Spec&gt;,
        _working_set: &amp;mut WorkingSet&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;CallResponse, ModuleError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>You'll notice that the <code>call</code> function takes three arguments: an associated <code>CallMessage</code> type, a <code>Context</code>,
and a <code>WorkingSet</code>.</p>
<ul>
<li>
<p>The <code>CallMessage</code> type is the deserialized content of the user's transaction - and the
module can pick any type to be its <code>CallMessage</code>. In most cases, modules use an <code>enum</code> with one variant
for each action a user might want to take.</p>
</li>
<li>
<p>The <code>Context</code> type is relatively straightforward. It simply contains the address of the sequencer, who published
the transaction, the identity of the transaction's signer, and the current block height.</p>
</li>
<li>
<p>The <code>WorkingSet</code> is the most interesting of the three, but it needs a little bit of explanation.
In the Sovereign SDK, the rust <code>struct</code> which implements a <code>Module</code> doesn't actually contain any state.
Rather than holding actual values, the module simply defines the <em>structure</em> of some items in state.
All of the actual state of the rollup is stored in a <code>WorkingSet</code>, which is an in-memory layer on top of
the rollup's database (in native mode) or merkle tree (in zk mode). The <code>WorkingSet</code> provides commit/revert
semantics, caching, deduplication, and automatic witness generation/checking. It also provides utilities
for charging <code>gas</code> and emitting <code>event</code>s.</p>
</li>
</ul>
<p>The <code>Accounts</code> module provides a good example of a standard <code>Module</code> trait implementation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CallMessage&lt;S: Spec&gt; {
    /// Updates a public key for the corresponding Account.
    /// The sender must be in possession of the new key.
    UpdatePublicKey(
        /// The new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::PublicKey,
        /// A valid signature from the new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::Signature,
    ),
}

impl&lt;S: Spec&gt; sov_modules_api::Module for Accounts&lt;S&gt; {
	// -- Some items ommitted here --
    fn call(
        &amp;self,
        msg: Self::CallMessage,
        context: &amp;Context&lt;S&gt;,
        working_set: &amp;mut WorkingSet&lt;S&gt;,
    ) -&gt; Result&lt;sov_modules_api::CallResponse, Error&gt; {
        match msg {
            call::CallMessage::UpdatePublicKey(new_pub_key, sig) =&gt; {
				// Find the account of the sender
				let pub_key = self.public_keys.get(context.sender(), working_set)?;
				let account = self.accounts.get(&amp;pub_key, working_set);
				// Update the public key
				self.accounts.set(&amp;new_pub_key, &amp;account, working_set);
				self.public_keys
					.set(context.sender(), &amp;new_pub_key, working_set);
				Ok(Default::default())
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="the-moduleinfo-trait"><a class="header" href="#the-moduleinfo-trait">The <code>ModuleInfo</code> trait</a></h4>
<p>The <code>ModuleInfo</code> trait describes how the module interacts with the broader module <em>system</em>. Each
module has a unique ID and stores its state under a unique <code>prefix</code> of the global key-value store
provided by <code>sov-modules</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ModuleInfo {
    /// Returns id of the module.
    fn id(&amp;self) -&gt; &amp;ModuleId;

    /// Returns the prefix where module state is stored.
    fn prefix(&amp;self) -&gt; ModulePrefix;

    /// Returns addresses of all the other modules this module is dependent on
    fn dependencies(&amp;self) -&gt; Vec&lt;&amp;ModuleId&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike the <code>Module</code> trait, its incredibly rare for developers to implement <code>ModuleInfo</code> by hand.
Instead, it's strongly recommended to derive the <code>ModuleInfo</code> using our handy macro. A typical
usage looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(ModuleInfo, Clone)]
pub struct Bank&lt;S: sov_modules_api::Spec&gt; {
    /// The id of the sov-bank module.
    #[id]
    pub(crate) id: ModuleId,

    /// The gas configuration of the sov-bank module.
    #[gas]
    pub(crate) gas: BankGasConfig&lt;S::Gas&gt;,

    /// A mapping of [`TokenId`]s to tokens in the sov-bank.
    #[state]
    pub(crate) tokens: sov_modules_api::StateMap&lt;TokenId, Token&lt;S&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This code automatically generates a unique ID for the bank module and stores it in the field
of the module called <code>id</code>. It also initializes the <code>StateMap</code> "<code>tokens</code>" so that any keys stored in the map
will be prefixed the with module's <code>prefix</code>. This prevents collisions in case a different module also
declares a <code>StateMap</code> where the keys are <code>TokenId</code>s.</p>
<h3 id="module-state"><a class="header" href="#module-state">Module State</a></h3>
<p>The Sovereign SDK provides three core abstractions for managing module state. A <code>StateMap&lt;K, V&gt;</code> maps arbitrary keys of type <code>K</code>
to arbitrary values of type <code>V</code>. A <code>StateValue&lt;V&gt;</code> stores a value of type <code>V</code>. And a <code>StateVec&lt;V&gt;</code> store an arbitrary length
vector of type <code>V</code>. All three types require their arguments to be serializable, since the values are stored in a merkle tree
under the hood.</p>
<p>All three abstractions support changing the underlying encoding scheme but default to <code>Borsh</code> if no alternative is specified. To
override the default, simply add an extra type parameter which implements the <code>StateCodec</code> trait. (i.e you might write
<code>StateValue&lt;Da::BlockHeader, BcsCodec&gt;</code> to use the <code>Bcs</code> serialization scheme for block headers, since your library
for DA layer types might only support serde-compatible serializers).</p>
<p>All state values are accessed through the <code>WorkingSet</code>. For example, you always write <code>my_state_value.get(&amp;mut working_set)</code> to
fetch a value. It's also important to remember that modifying a value that you read from state doesn't have any effect unless
you call <code>my_value.set(new, &amp;mut working_set)</code>.</p>
<h4 id="merkle-tree-layout"><a class="header" href="#merkle-tree-layout">Merkle Tree Layout</a></h4>
<p><code>sov-modules</code> currently uses a generic <a href="https://github.com/penumbra-zone/jmt">Jellyfish Merkle Tree</a> for its authenticated
key-value store. (Generic because it can be configured to use any 32-byte hash function).
In the near future, this JMT will be replaced with the
<a href="https://sovereign.mirror.xyz/jfx_cJ_15saejG9ZuQWjnGnG-NfahbazQH98i1J3NN8">Nearly Optimal Merkle Tree</a>
that is currently under development.</p>
<p>In the current implementation, the SDK implements storage by generating a unique (human-readable) key for each <code>StateValue</code>,
using the hash of that key as a path in the merkle tree. For <code>StateMap</code>s, the serialization of the key is appended to that path.
And for <code>StateVec</code>s, the index of the value is appended to the path.</p>
<p>For example, consider the following module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Suppose we're in the file my_crate/lib.rs
#[derive(ModuleInfo, Clone)]
pub struct Example&lt;S: sov_modules_api::Spec&gt; {
    #[id]
    pub(crate) id: ModuleId,
    #[state]
    pub(crate) some_value: sov_modules_api::StateValue&lt;u8&gt;,
    #[state]
    pub(crate) some_vec: sov_modules_api::StateVec&lt;u64&gt;,
    #[state]
    pub(crate) some_map: sov_modules_api::StateMap&lt;String, String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The value of <code>some_value</code> would be stored at the path <code>hash(b"my_crate/Example/some_value")</code>. The value of the key "hello"
in <code>some_map</code> would be stored at <code>hash(b"my_crate/Example/some_map/⍰hello")</code> (where <code>⍰hello</code> represents the borsh encoding
of the string "hello") etc.</p>
<p>However, this layout may change in future to provide better locality. For more details... ask Preston, I guess.</p>
<h4 id="exotic-state-variants"><a class="header" href="#exotic-state-variants">Exotic State Variants</a></h4>
<p>In addition to the standard state store, we support two other kinds of state:</p>
<p><code>KernelStateValue</code>s or (maps/vecs) act identically to regular <code>StateValues</code>, but they're stored in a separate merkle tree
which is only accessible to builtin rollup functionality. This mechanism allows the rollup to store data that is
inaccessible during transaction execution, which is necessary to enable soft-confirmations without sacrificing
censorship resistance. For more details, see the section on soft-confirmations in the
<a href="sdk-contributors/./transaction-lifecycle.html">transaction lifecycle</a> documentation. The global "state root" returned by the <code>sov-modules</code>
from the <code>StateTransitionFunction</code> implementation is the hash of the kernel state root with the regular state root.
We do our best to hide this detail from users of the SDK, though. Merkle proofs are automatically generated against the
global root, so users don't need to worry about which state trie there values are in.</p>
<p><code>AccessoryStateValue</code> or (map/vec) types are similar to <code>Kernel</code> types except that their values are not <em>readable</em> from inside
the state transition function at all. Under the hood, these value are stored in the rollup's database
<em>but not in either merkle tree</em>. This is useful for creating data that will be served via RPC but never
accessed again during execution - for example, the transaction receipts from an Ethereum block.</p>
<h3 id="the-stf-blueprint"><a class="header" href="#the-stf-blueprint">The STF Blueprint</a></h3>
<p>The last key component of a <code>sov-modules</code> rollup is the <code>stf-blueprint</code>. This "blueprint" provides a generic
implementation of a <code>StateTransitionFunction</code> in terms of a <code>Runtime</code> (described above) and a <code>Kernel</code> (which
provides security-critical functionality like censorship resistance in a way that's isolated from the transaction
execution logic).</p>
<p>The STF blueprint implements the following high-level workflow:</p>
<ol>
<li>Take all of the new data <code>Blob</code>s read from the DA layer and send them to the <code>Kernel</code>.
The <code>Kernel</code> will return a list of deserialized <code>Batch</code>es of transactions as well as the current <code>gas</code> price.
(A "<code>Batch</code>" is a "<code>Blob</code>" sent by a registered sequencer that has been succesfully deserialized
into a list of <code>Transaction</code>s)</li>
</ol>
<ul>
<li>Note that the list of <code>Batch</code>es returned by the <code>Kernel</code> does <em>not</em> necessarily correspond
exactly to the incoming <code>Blob</code>s. The <code>Kernel</code> might decide to ignore some Blobs, or to store some in its
internal state for "deferred" execution. It might also add some <code>Batch</code>es saved from a previous slot.</li>
</ul>
<ol start="2">
<li>
<p>Run the <code>begin_slot</code> hook, allowing modules to execute any initialization logic</p>
</li>
<li>
<p>For each batch initialize the sequencer reward to zero and run the <code>begin_batch</code> hook.
Apply the transactions, rewarding or penalizing the sequencer as appropriate. Finally, run
the <code>end_batch</code> hook</p>
</li>
<li>
<p>Run the <code>end_slot</code> hook to allow modules to execute any final logic.</p>
</li>
<li>
<p>Compute the state change set and state root based on the transactions that were executed.</p>
</li>
<li>
<p>Execute the <code>finalize</code> hook, which allows modules to compute any summary information from the change set
and make it available via RPC.</p>
</li>
</ol>
<p>For more details on the process of applying individual transactions, see the <a href="sdk-contributors/./transaction-lifecycle.html">transaction lifecycle</a>
document.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-specification"><a class="header" href="#gas-specification">Gas Specification</a></h1>
<p>This document contains a detailed specification of the way gas is handled within
Sovereign's SDK. We use <code>&lt;., .&gt;</code> to denote the scalar product of two
multidimensional quantities.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Gas is an ubiquitous concept in the blockchain space. It is a measure of the
computational effort required to perform an operation as part of a transaction
execution context. This is used to prevent the network from getting spammed by
regulating the use of computational resources by each participant in the
network.</p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High level overview</a></h2>
<p>We have drawn a lot of inspiration from the
<a href="https://ethereum.org/en/developers/docs/gas/">Ethereum gas model</a> in our gas
mechanism design. Given that Ethereum's gas is well understood and widely used
in the crypto industry, we believe that this will help users onboard more easily
while providing strong security guarantees out-of-the box. We have deliberately
chosen to tweak some concepts that were ill-suited to the rollups built using
Sovereing's SDK. In particular, sorted decreasing order of importance:</p>
<ul>
<li>We are using multidimensional gas units and prices.</li>
<li>We are using a dynamic gas target. Otherwise, the rollups built with
Sovereign's SDK follow the <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>
specification by default.</li>
<li>Rollup transactions specify a <code>max_fee</code>, <code>max_priority_fee_bips</code>, and
<em>optional gas limit</em> <code>gas_limit</code>. The semantics of these quantities roughtly
match their definition in the
<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559 specification</a>.</li>
<li>Transaction rewards are decomposed into <code>base_fee</code> and <code>priority_fee</code>. The
<code>base_fee</code> <em>is only partially burnt by default</em>, the remaining amount is used
<em>to reward provers/attesters</em>. The <code>priority_fee</code> is used to reward the <em>block
sequencers</em>.</li>
<li>We are charging gas for every storage access within the module system by
default.</li>
<li>Customers of the SDK will have access to wrappers that allow to charge gas for
hash computation and signature checks.</li>
</ul>
<h2 id="a-design-for-multidimensional-gas"><a class="header" href="#a-design-for-multidimensional-gas">A design for multidimensional gas</a></h2>
<p>Sovereign SDK's rollups use multidimensional gas units and prices. For example,
this allows developers to take into account the differences between native and
zero-knowledge computational costs for the same operation. Indeed:</p>
<ul>
<li>Hashing is orders of magnitude more expensive when performed inside a
zero-knowledge circuit. The cost of proving the correct computation of two
different Hash may also vary much more than the cost of computing the hash
itself (<code>Poseidon</code> or <code>MiMc</code> vs <code>Sha2</code>).</li>
<li>Accessing a storage cell for the first time is much more expensive in <code>zk</code>
mode than in <code>native</code> mode. But <em>hot</em> storage accesses are practically free in
zero-knowledge.</li>
</ul>
<p><strong>The number and meaning of each dimension is is still not finalized</strong>. The most
recent designs account for 4 dimensions that represent fundamental metrics of
the rollup <em>which are assumed to vary slowly</em> (on a weekly/monthly scale):</p>
<ul>
<li>Native computation costs.</li>
<li>Zk computation costs.</li>
<li>Storage size (which should be a function of the depth of the Jellyfish Merkle
tree or NOMT)</li>
<li>DA bandwidth - this dimension should track the <strong>long-term DA layer
bandwidth</strong> and should not be strongly affected by local congestion spikes.</li>
</ul>
<p>We have chosen to follow the
<a href="https://ethresear.ch/t/multidimensional-eip-1559/11651">multi-dimensional EIP-1559</a>
design for the gas pricing adjustment formulas. In essence:</p>
<ul>
<li>We are performing the gas price updates for each dimension separately. In
other words, each dimension follows a separate uni-dimensional EIP-1559 gas
price adjustment formula.</li>
<li>The gas price adjustment formula uses a <code>gas_target</code> reference, which is a
uni-dimensional gas unit that is compared to the gas consumed <code>gas_used</code>. The
<code>gas_price</code> is then adjusted to regulate the gas throughtput to get as close
as possible to the <code>gas_target</code>. We have the following invariant:
<code>0 &lt;= gas_used_slot &lt;= 2 * gas_target</code>.</li>
<li><em>Contrarily to Ethereum</em>, we are planning to design a dynamic <code>gas_target</code>.
The value of the <code>gas_target</code> will vary slowly to follow the evolution of the
rollup metrics we have described above. That way, Sovereign rollups can
account for major technological improvements in computation (such as zk-proof
generation throughtput), or storage cost.</li>
<li>Every transaction has to specify a unidimensional <code>max_fee</code> which is the
maximum amount of <em>gas tokens</em> that can be used to execute a given
transaction. Similarly, users have to specify a <code>max_priority_fee_per_gas</code>
expressed in basis points which can be used to reward the transaction
sequencer.</li>
<li>The final sequencer reward is:
<code>seq_reward = min(max_fee - &lt;base_fee, gas_price&gt;, max_priority_fee_per_gas * &lt;base_fee, gas_price&gt;)</code>.</li>
<li>Users can provide an optional <code>gas_limit</code> field which is a maximum amount of
gas to be used for the transaction. This quantity is converted to a
uni-dimensional <code>remaining_funds</code> quantity by taking the scalar product with
the current <code>gas_price</code>.</li>
<li>If users provide the <code>gas_limit</code>, the rollup checks that
<code>&lt;gas_limit, current_gas_price&gt; &lt;= max_fee</code> (ie, the scalar product with the
current <code>gas_price</code>). If the check fails, the associated transaction is not
executed and the rollup raises a
<code>ReserveGasErrorReason::CurrentGasPriceTooHigh</code> error.</li>
</ul>
<h2 id="charging-gas-for-state-accesses"><a class="header" href="#charging-gas-for-state-accesses">Charging gas for state accesses.</a></h2>
<p>State accessors such as the <code>WorkingSet</code> or the <code>PreExecWorkingSet</code> charge some
gas whenever state is modified. If these accessors run out of gas, they return a
<code>StateAccessorError</code> and the execution gets reverted (or the sequencer is
penalized). Some state accessors - like <code>StateCheckpoint</code>, the <code>TxScratchpad</code> or
the <code>ApiStateAccessor</code> - don't charge for gas for state accesses. In that case,
the access methods return a <code>Result&lt;T, Infallible&gt;</code> type which can be unwrapped
safely using <code>unwrap_infallible</code>.</p>
<p>For now, we are enforcing simple cached access patterns - we are refunding some
gas if the value that is accessed/modified is <em>hot</em> (ie has been already
accessed and is cached).</p>
<h2 id="gas-rewards"><a class="header" href="#gas-rewards">Gas rewards.</a></h2>
<p>The gas consumed during transaction execution is used to reward both
provers/attesters and block sequencers. The <code>base_fee</code>, ie the total amount of
gas consumed by the transaction execution is partially burnt (the amount to burn
is specified by the <code>PERCENT_BASE_FEE_TO_BURN</code> constant), and the remaining
portion is locked in a reward pool to be redeemed by provers/attesters. The
<code>priority_fee</code> is also partially burnt and used to reward block sequencers.</p>
<h2 id="additional-data-structures-that-can-be-used-to-charge-gas"><a class="header" href="#additional-data-structures-that-can-be-used-to-charge-gas">Additional data structures that can be used to charge gas.</a></h2>
<p>We have a couple of additional data structures that can be used to charge gas.
These are:</p>
<ul>
<li><code>MeteredHasher</code>: a wrapper structure that can be used to charge gas for hash
computation.</li>
<li><code>MeteredSignature</code>: a wrapper structure that can be used to charge gas for
signature checks.</li>
<li><code>MeteredBorshDeserialize</code>: a supertrait that can be used to charge gas for
structures implementing <code>BorshDeserialize</code>.</li>
</ul>
<h2 id="structure-of-the-implementation"><a class="header" href="#structure-of-the-implementation">Structure of the implementation</a></h2>
<p>The core of the gas implementation is located within the <code>sov-modules-api</code> crate
in the following modules/files:</p>
<ul>
<li><code>module-system/sov-modules-api/src/common/gas.rs</code>: contains the implementation
of the <code>Gas</code> and <code>GasMeter</code> traits. These are the core interfaces that are
consumed by the API. The <code>Gas</code> trait defines the way users can interact with
multidimensional gas units. The <code>GasMeter</code> is the interface implemented by
every data structure that contains or consumes gas (such as the <code>WorkingSet</code>
which contains a <code>TxGasMeter</code>, or the <code>PreExecWorkingSet</code> that may contain a
<code>SequencerStakeMeter</code>).</li>
<li><code>module-system/sov-modules-api/src/common/hash.rs</code>: contains the
implementation of the <code>MeteredHasher</code> which is a wrapper structure that can be
used to charge gas for hash computation.</li>
<li><code>module-system/sov-modules-api/src/transaction.rs</code>: contains the
representation of the transaction type that is used within the SDK. These
structures contain the <code>max_fee</code>, <code>max_priority_fee_bips</code> and <code>gas_limit</code>
fields that represent the maximum amount of gas tokens to use for the
transaction, the maximum priority fee to pay the sequencer (in basis points),
and an optionnal multidimensional gas limit (ie the maximum amount of gas to
be consumed for this transaction).</li>
</ul>
<p>Outside of the <code>sov-modules-api</code>, within the module system:</p>
<ul>
<li><code>module-system/module-implementations/sov-chain-state/src/gas.rs</code>:
<code>compute_base_fee_per_gas</code> contains the implementation of the gas price update
which follows our modified version of the <code>EIP-1559</code>. The gas price is updated
within the <code>ChainState</code>'s module lifecycle hooks
(<code>ChainState::begin_slot_hook</code> updates the gas price,
<code>ChainState::end_slot_hook</code> updates the gas consumed by the transaction).</li>
<li><code>module-system/module-implementations/sov-sequencer-registry/src/capabilities.rs</code>:
contains the implementationn of the <code>SequencerStakeMeter</code> which is the data
structure used to meter the sequencer stake before the transaction's execution
starts.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
