<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sovereign SDK Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="/assets/sovereign-dark-highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="1-intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="2-running-starter.html"><strong aria-hidden="true">2.</strong> Running the Starter Rollup</a></li><li class="chapter-item expanded "><a href="3-quickstart.html"><strong aria-hidden="true">3.</strong> Quickstart: Your First Module</a></li><li class="chapter-item expanded "><a href="4-0-build-for-production-intro.html"><strong aria-hidden="true">4.</strong> Building for Production</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="4-1-anatomy-of-a-module.html"><strong aria-hidden="true">4.1.</strong> Anatomy of a Module</a></li><li class="chapter-item expanded "><a href="4-2-testing-your-module.html"><strong aria-hidden="true">4.2.</strong> Testing Your Module</a></li><li class="chapter-item expanded "><a href="4-3-wallets-and-accounts.html"><strong aria-hidden="true">4.3.</strong> Wallets and Accounts</a></li><li class="chapter-item expanded "><a href="4-4-advanced-topics.html"><strong aria-hidden="true">4.4.</strong> Advanced Topics</a></li><li class="chapter-item expanded "><a href="4-5-performance.html"><strong aria-hidden="true">4.5.</strong> Performance</a></li><li class="chapter-item expanded "><a href="4-6-prebuilt-modules.html"><strong aria-hidden="true">4.6.</strong> Prebuilt Modules</a></li></ol></li><li class="chapter-item expanded "><a href="5-additional-capabilities.html"><strong aria-hidden="true">5.</strong> Additional Capabilities</a></li><li class="chapter-item expanded "><a href="6-0-intro.html"><strong aria-hidden="true">6.</strong> Instrumenting Your Rollup</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="6-1-metrics.html"><strong aria-hidden="true">6.1.</strong> Metrics</a></li><li class="chapter-item expanded "><a href="6-2-logging.html"><strong aria-hidden="true">6.2.</strong> Logging</a></li></ol></li><li class="chapter-item expanded "><a href="7-0-intro.html"><strong aria-hidden="true">7.</strong> SDK Contributors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="7-1-transaction-lifecycle.html"><strong aria-hidden="true">7.1.</strong> Transaction Lifecyle</a></li><li class="chapter-item expanded "><a href="7-2-abstractions.html"><strong aria-hidden="true">7.2.</strong> Main Abstractions</a></li><li class="chapter-item expanded "><a href="7-3-forced-sequencer-registration.html"><strong aria-hidden="true">7.3.</strong> Forced Sequencer Registration</a></li><li class="chapter-item expanded "><a href="7-4-gas.html"><strong aria-hidden="true">7.4.</strong> Gas</a></li></ol></li><li class="chapter-item expanded "><a href="8-0-complying-with-revenue-share.html"><strong aria-hidden="true">8.</strong> Complying with Revenue Share</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="sovereign-dark">Sovereign Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sovereign SDK Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to the Sovereign SDK Book!</p>
<p>With P99 of transaction executions under 10 milliseconds, the Sovereign SDK is fast enough to bring complex financial systems, like Central-Limit Orderbooks (CLOBs), fully on-chain.</p>
<p>The Sovereign SDK provides much more flexibility and performance than traditional blockchain frameworks. In this guide, you'll learn to take full advantage of the SDK's unique features and bring your app from idea to production.</p>
<p>Let's get started!</p>
<img src="./assets/sov-sdk-low-res.jpeg" style="border-radius: 10px">
<h2 id="why-build-a-dedicated-rollup-for-your-application"><a class="header" href="#why-build-a-dedicated-rollup-for-your-application">Why Build a Dedicated Rollup For Your Application?</a></h2>
<p>For almost a decade, developers have been forced to build applications on shared, general-purpose blockchains. This model forces apps with vastly different needs to compete for the same limited blockspace. Building your application as a dedicated rollup gives you three strategic advantages:</p>
<ol>
<li><strong>Dedicated Throughput:</strong> Your users will never have to compete with a viral NFT drop. A rollup gives your application its own dedicated lane, ensuring a consistently fast and affordable user experience.</li>
<li><strong>Capturing More Value:</strong> On shared blockchains, user fees primarily benefit the chain operators (i.e. L1 validators or general-purpose L2 sequencers). With a rollup, your application and its users can capture the vast majority of that value, creating a sustainable economic engine for your project.</li>
<li><strong>Full Control &amp; Flexibility:</strong> Go beyond the limitations of a shared virtual machine. A rollup gives you full control over the execution environment, allowing you to define your own rules for how transactions are processed. <strong>With a rollup, you're in the driver's seat.</strong></li>
</ol>
<h2 id="why-choose-the-sovereign-sdk"><a class="header" href="#why-choose-the-sovereign-sdk">Why Choose the Sovereign SDK?</a></h2>
<p>The Sovereign SDK is designed around four key goals to provide an unmatched developer and user experience:</p>
<ul>
<li><strong>Total Customization:</strong> While rollups promise flexibility, existing frameworks are overly restrictive. With its modular Rust runtime,Sovereign SDK empowers you to customize as much or as little as neeeded. Easily add custom fee logic, integrate tailored authenticators, prioritize specific transaction types, or even swap out the authenticated state store. All without wrestling with legacy code.</li>
<li><strong>Best-in-Class Performance:</strong> With P99 &lt; 10 ms for transaction execution and throughput exceeding 4,500 TPS, the Sovereign SDK is orders of magnitude faster than competing frameworks like Orbit, the OP Stack, or the Cosmos SDK.</li>
<li><strong>Developer-Friendly Experience:</strong> Write your logic in standard Rust, run <code>cargo build</code>, and get a complete full-node implementation with REST &amp; WebSocket APIs, an indexer, auto-generated OpenAPI specs, and a sequencer  with automatic failover out of the box. No deep blockchain expertise required.</li>
<li><strong>Future-Proof Architecture:</strong> Never get locked into yesterday's tech stack. With the Sovereign SDK, you can switch data availability layers or zkVMs with just a few lines of code, ensuring your project remains agile for years to come.</li>
</ul>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How It Works</a></h2>
<p>As a developer, you write your rollup's business logic in Rust, and the SDK handles the complexity of creating a complete, production-ready node implementation.</p>
<p>The magic happens in two stages: <strong>real-time execution</strong> and <strong>on-chain settlement</strong>.</p>
<ol>
<li>
<p><strong>Real-Time Execution (Soft Confirmations):</strong> Users send transactions to a <strong>sequencer</strong>. The sequencer executes these transactions instantly (typically in under 2-5ms) and returns a "soft confirmation" back to the user. This provides a real-time user experience that feels like a traditional web application.</p>
</li>
<li>
<p><strong>On-Chain Settlement &amp; Verification:</strong> Periodically, the sequencer batches thousands of these transactions and posts them to an underlying <strong>Data Availability (DA) layer</strong> like Celestia. From this point, the rest of the network—the full nodes—can read the ordered data and execute the transactions to independently verify the new state of the rollup.</p>
</li>
</ol>
<p>Finally, specialized actors called <strong>provers</strong> (in zk-rollup mode) or <strong>attesters</strong> (in optimistic-rollup mode) generate cryptographic proofs  or attestations that the state was computed correctly. These are posted back to the DA layer, allowing light clients and bridges to securely verify the rollup's state without having to re-execute every transaction.</p>
<p>This two-stage process gives you the best of both worlds: the instant, centralized execution needed for high-performance applications, combined with the censorship-resistance and trust-minimized verification of a traditional blockchain.</p>
<h2 id="ready-to-build"><a class="header" href="#ready-to-build">Ready to Build?</a></h2>
<p>In the next section we'll get you up and running with your first Sovereign SDK rollup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="running-the-starter-rollup"><a class="header" href="#running-the-starter-rollup">Running the Starter Rollup</a></h1>
<p>This chapter is about one thing: <strong>getting to run your first rollup.</strong> We'll do this by cloning a pre-built starter rollup and running it on your local machine. We'll save the fun part—writing your own code—for the next chapter.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before you begin, ensure you have the following installed on your system:</p>
<ul>
<li><strong>Rust</strong>: Version 1.88 or later. We recommend installing it via <a href="https://rustup.rs/">rustup</a>. The starter repository uses a <code>rust-toolchain.toml</code> file to automatically select the correct toolchain version.</li>
<li><strong>Node.js and npm</strong>: Version 20.0 or later. We'll use this for the Typescript client in a later chapter. <a href="https://nodejs.org/en/download">Install here.</a></li>
<li><strong>Git</strong>: For cloning the starter repository.</li>
</ul>
<h2 id="running-the-rollup"><a class="header" href="#running-the-rollup">Running the Rollup</a></h2>
<p>With the prerequisites installed, running the rollup takes just two commands.</p>
<ol>
<li>
<p><strong>Clone the starter repository:</strong></p>
<pre><code class="language-bash">git clone https://github.com/Sovereign-Labs/rollup-starter.git
cd rollup-starter
</code></pre>
</li>
<li>
<p><strong>Build and run the node:</strong></p>
<pre><code class="language-bash">cargo run 
</code></pre>
<p>You should see a stream of log messages, indicating that the rollup node is running and producing new blocks. Keep this terminal window open.</p>
<blockquote>
<p><strong>Note:</strong> The first build can take several minutes as Cargo downloads and compiles all the dependencies. Subsequent builds will be much faster.</p>
</blockquote>
</li>
</ol>
<h2 id="verifying-the-node-is-running"><a class="header" href="#verifying-the-node-is-running">Verifying the Node is Running</a></h2>
<p>Open a new terminal window. We can verify that the node is running and all its core components have loaded by querying its list of <strong>modules</strong>.</p>
<p>Modules are the individual building blocks of a Sovereign SDK rollup, each handling a specific feature like token management (<code>bank</code>) or the sequencer registry. Let's query the <code>/modules</code> endpoint to see which ones are active in the starter rollup:</p>
<pre><code class="language-bash">curl 'http://127.0.0.1:12346/modules'
</code></pre>
<p>If everything is working, you should see a JSON response listing the default modules included in the starter rollup, like <code>bank</code>, <code>accounts</code>, and <code>sequencer_registry</code>.</p>
<pre><code class="language-json">{
  "data": {
    "modules": [
      "bank",
      "sequencer_registry",
      "accounts",
      "value_setter"
      // ... and others
    ]
  },
  "meta": {}
}
</code></pre>
<h2 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h2>
<p>Now that you've successfully run the starter rollup, let's get you building your own.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quickstart-your-first-module"><a class="header" href="#quickstart-your-first-module">Quickstart: Your First Module</a></h1>
<p>In this section, you’ll write and deploy your own business logic as a rollup.</p>
<p>We'll start with a very basic <a href="https://github.com/Sovereign-Labs/rollup-starter/tree/main/examples/value-setter"><code>ValueSetter</code></a> module that's already included in the <code>rollup-starter</code>.</p>
<p>The <code>ValueSetter</code> module currently stores a single number that any user can update. We want to ensure that only one user (the admin) has permission to update this number.</p>
<p>This requires four changes:</p>
<ol>
<li><strong>Add an</strong> <code>admin</code> <strong>field</strong> to the module's state to store the admin address.</li>
<li><strong>Create a configuration struct</strong> so that we can set the admin address when the rollup launches.</li>
<li><strong>Initialize</strong> the <code>admin</code>from the configuration struct in the <code>genesis</code> method, which sets up the module's initial state.</li>
<li><strong>Add a check</strong> in the <code>call</code> method to verify that the transaction sender is the admin.</li>
</ol>
<p>Let's get started.</p>
<h2 id="step-1-understand-the-starting-point"><a class="header" href="#step-1-understand-the-starting-point">Step 1: Understand the Starting Point</a></h2>
<p>First, navigate to the <code>value-setter</code> module in the starter repository and open the <code>src/lib.rs</code> file.</p>
<pre><code class="language-bash"># From the sov-rollup-starter root
cd examples/value-setter/
</code></pre>
<p>The code in this file defines the module's structure and a <code>call</code> method that lets anyone set the value.</p>
<p>Here’s the simplified <code>lib.rs</code> that we'll start with:</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs

#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct ValueSetter&lt;S: Spec&gt; {
    #[id]
    pub id: ModuleId,

    /// Holds the value
    #[state]
    pub value: StateValue&lt;u32&gt;,
}

#[derive(Clone, Debug, PartialEq, Eq, JsonSchema, UniversalWallet)]
#[serialize(Borsh, Serde)]
#[serde(rename_all = "snake_case")]
pub enum CallMessage {
    SetValue(u32),
}

impl&lt;S: Spec&gt; Module for ValueSetter&lt;S&gt; {
    type Spec = S;
    type Config = (); // No configuration yet!
    type CallMessage = CallMessage;
    type Event = ();

    // The `call` method handles incoming transactions.
    // Notice it doesn't check *who* is calling.
    fn call(&amp;mut self, msg: Self::CallMessage, _context: &amp;Context&lt;S&gt;, state: &amp;mut impl TxState&lt;S&gt;) -&gt; Result&lt;()&gt; {
        match msg {
            CallMessage::SetValue(new_value) =&gt; {

                self.value.set(&amp;new_value, state)?;

                Ok(())
            }
        }
    }
}</code></pre>
<h2 id="step-2-implement-the-admin-logic"><a class="header" href="#step-2-implement-the-admin-logic">Step 2: Implement the Admin Logic</a></h2>
<p>Now, let's secure our module. We'll perform the four edits we outlined earlier.</p>
<h3 id="a-add-the-admin-state-variable"><a class="header" href="#a-add-the-admin-state-variable">a) Add the <code>admin</code> State Variable</a></h3>
<p>First, we need a place to store the admin's address. We'll add a new <code>admin</code> field to the <code>ValueSetter</code> struct and mark it with the <code>#[state]</code> attribute.</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs

#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct ValueSetter&lt;S: Spec&gt; {
    // ... existing code ...

    /// The new state value to hold the address of the admin.
    #[state]
    pub admin: StateValue&lt;S::Address&gt;,
}</code></pre>
<h3 id="b-define-a-configuration-struct"><a class="header" href="#b-define-a-configuration-struct">b) Define a Configuration Struct</a></h3>
<p>Next, we need a way to tell the module who the admin is when the rollup first starts. We do this by defining a <code>Config</code> struct. The SDK will automatically load data from a <code>genesis.json</code> file into this struct.</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs

// Add the module's configuration, read from genesis.json
#[derive(Clone, Debug, PartialEq, Eq)]
#[serialize(Serde)]
#[serde(rename_all = "snake_case")]
pub struct ValueSetterConfig&lt;S: Spec&gt; {
    pub admin: S::Address,
}</code></pre>
<h3 id="c-initialize-the-admin-at-genesis"><a class="header" href="#c-initialize-the-admin-at-genesis">c) Initialize the Admin at Genesis</a></h3>
<p>With our <code>Config</code> struct defined, we can now implement the <code>genesis</code> method. This function is called once when the rollup is launched. It takes the <code>config</code> as an argument and uses it to set the initial state.</p>
<p>We also need to tell the <code>Module</code> implementation to use our new <code>ValueSetterConfig</code>.</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs

// ... existing code ...

impl&lt;S: Spec&gt; Module for ValueSetter&lt;S&gt; {
    type Spec = S;
    type Config = ValueSetterConfig&lt;S&gt;; // Use the new config struct
    type CallMessage = CallMessage;
    type Event = ();

    // `genesis` initializes the module's state. Here, we set the admin address.
    fn genesis(&amp;mut self, _header: &amp;&lt;S::Da as sov_modules_api::DaSpec&gt;::BlockHeader, config: &amp;Self::Config, state: &amp;mut impl GenesisState&lt;S&gt;) -&gt; Result&lt;()&gt; {
        self.admin.set(&amp;config.admin, state)?;
        Ok(())
    }

    fn call(&amp;mut self, msg: Self::CallMessage, context: &amp;Context&lt;S&gt;, state: &amp;mut impl TxState&lt;S&gt;) -&gt; Result&lt;()&gt; {
// ... existing code ...</code></pre>
<h3 id="d-add-the-admin-check-in-call"><a class="header" href="#d-add-the-admin-check-in-call">d) Add the Admin Check in <code>call</code></a></h3>
<p>The final piece. We'll modify the <code>call</code> method to read the <code>admin</code> address from state and compare it to the transaction sender. If they don't match, the transaction fails.</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs
// ... existing code ...

    fn call(&amp;mut self, msg: Self::CallMessage, context: &amp;Context&lt;S&gt;, state: &amp;mut impl TxState&lt;S&gt;) -&gt; Result&lt;()&gt; {
        match msg {
            CallMessage::SetValue(new_value) =&gt; {
                // Read the admin's address from state.
                let admin = self.admin.get_or_err(state)??;

                // Ensure the sender is the admin.
                anyhow::ensure!(admin == *context.sender(), "Only the admin can set the value.");

                // If the check passes, update the state.
                self.value.set(&amp;new_value, state)?;
                Ok(())
            }
        }
    }
}</code></pre>
<h2 id="step-3-configure-the-genesis-state"><a class="header" href="#step-3-configure-the-genesis-state">Step 3: Configure the Genesis State</a></h2>
<p>Our <code>genesis</code> method reads the admin's address from a configuration file. We need to provide that value in <code>configs/mock_da/genesis.json</code>.</p>
<p>The SDK automatically deserializes this JSON into our <code>ValueSetterConfig</code> struct (since we plugged in said struct as the <code>Config</code> associated type of our module) when the rollup starts.</p>
<pre><code class="language-json">// In sov-rollup-starter/configs/mock_da/genesis.json
{
  // ... other module configs
  "value_setter": {
    "admin": "0x9b08ce57a93751aE790698A2C9ebc76A78F23E25"
  }
}
</code></pre>
<p>Previously, the <code>value_setter</code> field was <code>null</code>. Now, we've given it the data our module needs to initialize the admin address.</p>
<h2 id="how-is-the-module-integrated"><a class="header" href="#how-is-the-module-integrated">How is the Module Integrated?</a></h2>
<p>You might be wondering how the rollup knows about the <code>value-setter</code> module in the first place. In the <code>sov-rollup-starter</code>, we've already "wired it up" for you to keep this quickstart focused on module logic.</p>
<p>For your own future modules, the process involves:</p>
<ol>
<li>Adding the module crate to the workspace in the root <code>Cargo.toml</code>.</li>
<li>Adding it as a dependency to the core logic in <code>crates/stf/Cargo.toml</code>.</li>
<li>Adding the module as a field on the <code>Runtime</code> struct in <code>crates/stf/src/runtime.rs</code>.</li>
</ol>
<p>You can remove <code>value-setter</code> from these files to see what it's like to build and integrate a module from scratch.</p>
<h2 id="step-4-build-run-and-interact"><a class="header" href="#step-4-build-run-and-interact">Step 4: Build, Run, and Interact!</a></h2>
<p>Now let's see your logic in action.</p>
<ol>
<li>
<p><strong>Build and Run the Rollup:</strong> From the root directory, start the rollup.</p>
<pre><code class="language-bash">cargo run
</code></pre>
</li>
<li>
<p><strong>Query the Initial State:</strong> In another terminal, use <code>curl</code> to check the initial value. It should be <code>null</code> because our <code>genesis</code> method only sets the <code>admin</code>, not the <code>value</code>.</p>
<pre><code class="language-bash">curl http://127.0.0.1:12346/modules/value-setter/state/value
# Expected output: {"value":null}
</code></pre>
</li>
<li>
<p><strong>Submit a Transaction:</strong> Now, let's change the value. We'll edit the example js script in starter to call our module.</p>
<ul>
<li>Open the <code>examples/starter-js/src/index.ts</code> file.</li>
<li>The <code>signer</code> in this script corresponds to the <code>admin</code> address we set in <code>genesis.json</code>.</li>
<li>Find the <code>callMessage</code> variable and replace it with a call to your <code>value_setter</code> module.</li>
</ul>
<pre><code class="language-ts">// In sov-rollup-starter/examples/starter-js/src/index.ts

// Replace the existing call message with this one:
const callMessage: RuntimeCall = {
    value_setter: {   // The module's name in the Runtime struct
        set_value: 99,  // The CallMessage variant (in snake_case) and its new value
    },
};
</code></pre>
<ul>
<li>Install js dependencies, and run the script to send the transaction:</li>
</ul>
<pre><code class="language-bash"># From the sov-rollup-starter/examples/starter-js directory
npm install
npm run start
</code></pre>
</li>
<li>
<p><strong>Verify the Change:</strong> Now for the "Aha!" moment. Query the state again:</p>
<pre><code class="language-bash">curl http://127.0.0.1:12346/modules/value-setter/state/value
# Expected output: {"value":99}
</code></pre>
</li>
</ol>
<p><strong>Congratulations!</strong> You have successfully written and interacted with your own custom logic on a Sovereign SDK rollup!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="building-for-production"><a class="header" href="#building-for-production">Building for Production</a></h1>
<p>In the quickstart, you built a simple but functional module. Now we'll walk you
through the structure of a module in much more detail, taking the <code>ValueSetter</code>
as our example. In this section, we'll explain how to take better advantage of
many SDK features:</p>
<ol>
<li><strong>Events:</strong> The primary mechanism for communicating with off-chain systems.</li>
<li><strong>Testing:</strong> Using the SDK's powerful testing framework to ensure
correctness.</li>
<li><strong>Wallets and Accounts:</strong> A closer look at how users can interact with your
applications.</li>
<li><strong>Advanced Features:</strong> Exploring powerful tools like hooks, custom APIs, and
configurable delays.</li>
<li><strong>Performance Optimizations:</strong> How to ensure your module is efficient and
scalable.</li>
<li><strong>Prebuilt Modules:</strong> How to leverage the ecosystem of existing modules to
accelerate your development.</li>
</ol>
<p>Let's begin.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="anatomy-of-a-module"><a class="header" href="#anatomy-of-a-module">Anatomy of a Module</a></h1>
<p>As we begin our journey into building a production-ready rollup, the first step is to understand the two most important architectural concepts in the Sovereign SDK: the <strong>Runtime</strong> and its <strong>Modules</strong>.</p>
<h2 id="runtime-vs-modules"><a class="header" href="#runtime-vs-modules">Runtime vs. Modules</a></h2>
<p>The <strong>runtime</strong> is the orchestrator of your rollup. It receives transactions, deserializes them, and routes them to the appropriate modules for execution. Think of it as the central nervous system that connects all your application logic. The <a href="https://github.com/Sovereign-Labs/rollup-starter/blob/main/crates/stf/stf-declaration/src/lib.rs#L51"><code>Runtime</code></a> struct you define in your rollup code specifies which modules are included.</p>
<p><strong>Modules</strong> contain the actual business-logic. Each module manages its own state and defines the specific actions (called "call messages") that users can perform. Modules are usually small and self-contained, but they can contain dependencies on other modules when it
makes sense to.</p>
<p>Now that we understand this high-level structure, let's dissect the <code>ValueSetter</code> module you built and enhance it with production-grade features.</p>
<h2 id="dissecting-the-valuesetter-module"><a class="header" href="#dissecting-the-valuesetter-module">Dissecting the <code>ValueSetter</code> Module</a></h2>
<h4 id="the-module-struct-state-and-dependencies"><a class="header" href="#the-module-struct-state-and-dependencies">The Module Struct: State and Dependencies</a></h4>
<p>First, let's look at the <code>ValueSetter</code> struct, which defined its state variables and its dependencies on other modules.</p>
<pre><code class="language-rust">#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct ValueSetter&lt;S: Spec&gt; {
    #[id]
    pub id: ModuleId,

    #[state]
    pub value: StateValue&lt;u32&gt;,

    #[state]
    pub admin: StateValue&lt;S::Address&gt;,
}</code></pre>
<p>This struct is defined by several key attributes and the <code>Spec</code> generic:</p>
<ul>
<li><code>#[derive(ModuleInfo)]</code>: This derive macro is mandatory. It performs essential setup, like laying out your state values in the database.</li>
<li><code>#[id]</code>: Every module must have exactly one field with this attribute. The SDK uses it to store the module's unique, auto-generated identifier.</li>
<li><code>#[state]</code>: This attribute marks a field as a state variable that will be stored in the database. More on <a href="4-1-anatomy-of-a-module.html#state-management-in-depth">state management</a> later.</li>
<li><strong>The</strong> <code>Spec</code> <strong>Generic</strong>: All modules are generic over a <code>Spec</code>. This provides core types like <code>S::Address</code> and makes your module portable across things like DA layers, zkVMs, and address formats.</li>
<li><code>#[module]</code>: While not used in this example, this attribute declares a dependency on another module. For example, if our <code>ValueSetter</code> needed to charge a fee, we could add <code>#[module] pub bank: sov_bank::Bank&lt;S&gt;</code>, allowing us to call methods like <code>self.bank.transfer(...)</code> from our own logic.</li>
</ul>
<h4 id="the-modulerestapi-trait"><a class="header" href="#the-modulerestapi-trait">The <code>ModuleRestApi</code> Trait</a></h4>
<p>Deriving the <code>ModuleRestApi</code> trait is optional but highly recommended. It automatically generates RESTful API endpoints for the <code>#[state]</code> items in your module. Each item's endpoint will have the name <code>{hostname}/modules/{module-name}/{field-name}/</code>, with all items automatically converted to <code>kebab-casing</code>. For example, for the <code>value</code> field in our <code>ValueSetter</code> module, the SDK generates an endpoint at the path <code>/modules/value-setter/value</code>.</p>
<p>Note that <code>ModuleRestApi</code> can't always generate endpoints for you. If it can't figure out how to generate an endpoint for a particular state value, it will simply skip it by default. If you want to override this behavior and throw a compiler error if endpoint generation fails, you can add the <code>#[rest_api(include)]</code> attribute.</p>
<h3 id="state-management-in-depth"><a class="header" href="#state-management-in-depth">State Management In-Depth</a></h3>
<p>The SDK provides several "state" types for different use cases. All three types of state can be added to your module struct using the <code>#[state]</code> attribute.</p>
<ul>
<li><code>StateValue&lt;T&gt;</code>: Stores a single item of type <code>T</code>. We used this for the <code>value</code> and <code>admin</code> variables in our example.</li>
<li><code>StateMap&lt;K, V&gt;</code>: Stores a key-value mapping. This is ideal for balances or other user-specific data.</li>
<li><code>StateVec&lt;T&gt;</code>: Stores an ordered list of items, accessible by index.</li>
</ul>
<p>The generic types can be any (deterministically) serializable Rust data structure.</p>
<p><strong>Accessory State</strong>: For each state type, there is a corresponding <code>AccessoryState*</code> variant (e.g., <code>AccessoryStateMap</code>). Accessory state is special: it can be read via the API, but it is <strong>write-only</strong> during transaction execution. This makes it a simple and cheap storage to use for data that doesn't affect onchain logic, like purchase histories for an off-chain frontend.</p>
<h3 id="the-module-trait"><a class="header" href="#the-module-trait">The <code>Module</code> Trait</a></h3>
<p>The <code>Module</code> trait is where your business logic lives. Let's review the pieces you implemented for <code>ValueSetter</code> in the quickstart.</p>
<ul>
<li>
<p><strong><code>type Config</code> and <code>fn genesis()</code></strong>: You created a <code>ValueSetterConfig</code> and used it in the <code>genesis</code> method to initialize the <code>admin</code> state. This is a standard pattern: <code>Config</code> defines the initial data, read from <code>genesis.json</code>, and <code>genesis()</code> applies it to the module's state when the rollup is first deployed.</p>
</li>
<li>
<p><strong><code>type CallMessage</code> and <code>fn call()</code></strong>: You defined a <code>CallMessage</code> enum for the public <code>SetValue</code> action. This enum is the public API of your module, representing the actions a user can take. The <code>call()</code> method is the entry point for these actions. The runtime passes in the <code>CallMessage</code> and a <code>Context</code> containing metadata like the sender's address, which you used for the admin check.</p>
</li>
<li>
<p><strong>Error Handling</strong>: In your <code>call</code> method, you used <code>anyhow::ensure!</code> to handle a <strong>user error</strong> (an invalid sender). When a <code>call</code> method returns an <code>Err</code>, the SDK guarantees that all state changes are automatically reverted, ensuring atomicity. This <code>Result</code>-based approach is for predictable user errors, while unrecoverable system bugs should cause a <code>panic!</code>. A more detailed guide is available in the <a href="./4-4-advanced-topics.html"><code>Advanced Topics</code></a> section.</p>
</li>
</ul>
<blockquote>
<p><strong>A Quick Tip on Parametrizing Your Types Over S</strong></p>
<p>If you parameterize your <code>CallMessage</code> or <code>Event</code> over <code>S</code> (for example, to include an address of type <code>S::Address</code>), you must add the <code>#[schemars(bound = "S: Spec", rename = "MyEnum")]</code> attribute on top your enum definition. This is a necessary hint for <code>schemars</code>, a library that generates a JSON schema for your module's API. It ensures that your generic types can be correctly represented for external tools.</p>
</blockquote>
<blockquote>
<p><strong>Quick Tip: Handling <code>Vector</code> and <code>String</code> in CallMessage</strong></p>
<p>Use the fixed‑size wrappers <code>SafeVector</code> and <code>SafeString</code> for any fields that are deserialized directly into a <code>CallMessage</code>; they limit payload size and prevent DoS attacks. After deserialization, feel free to convert them to regular <code>Vector</code> and <code>String</code> values and use them as usual.</p>
</blockquote>
<h2 id="adding-events"><a class="header" href="#adding-events">Adding Events</a></h2>
<p>Your <code>ValueSetter</code> module works, but it's a "black box." Off-chain applications have no way of knowing when the value changes without constantly polling the API. To solve this, we introduce <strong>Events</strong>.</p>
<p>Events are the primary mechanism for streaming on-chain data to off-chain systems like indexers and front-ends in real-time. Let's add one to our module.</p>
<p>First, define an <code>Event</code> enum.</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs

#[derive(Clone, Debug, PartialEq, Eq, JsonSchema)]
#[serialize(Borsh, Serde)]
#[serde(rename_all = "snake_case")]
pub enum Event {
    ValueUpdated(u32),
}</code></pre>
<p>Next, update your <code>Module</code> implementation to use this new <code>Event</code> type and emit it from the <code>call</code> method.</p>
<pre><code class="language-rust">// In examples/value-setter/src/lib.rs

impl&lt;S: Spec&gt; Module for ValueSetter&lt;S&gt; {
    type Spec = S;
    type Config = ValueSetterConfig&lt;S&gt;;
    type CallMessage = CallMessage;
    type Event = Event; // Change this from ()

    // The `genesis` method is unchanged.
    fn genesis(&amp;mut self, _header: &amp;&lt;S::Da as sov_modules_api::DaSpec&gt;::BlockHeader, config: &amp;Self::Config, state: &amp;mut impl GenesisState&lt;S&gt;) -&gt; Result&lt;()&gt; {
        // ...
    }

    fn call(&amp;mut self, msg: Self::CallMessage, context: &amp;Context&lt;S&gt;, state: &amp;mut impl TxState&lt;S&gt;) -&gt; Result&lt;()&gt; {
        match msg {
            CallMessage::SetValue(new_value) =&gt; {
                let admin = self.admin.get(state)??;
                anyhow::ensure!(admin == *context.sender(), "Only the admin can set the value.");

                self.value.set(&amp;new_value, state)?;

                // NEW: Emit an event to record this change.
                self.emit_event(state, Event::ValueUpdated(new_value));

                Ok(())
            }
        }
    }
}</code></pre>
<p>Now, whenever the admin successfully calls <code>set_value</code>, the module will emit a <code>ValueUpdated</code> event.</p>
<p>A key guarantee of the Sovereign SDK is that event emission is <strong>atomic</strong> with transaction execution—if a transaction reverts, so do its events. This ensures any off-chain system remains consistent with the on-chain state.</p>
<p>To make it simple to build scalable and faul-tolertant off-chain data pipelines, the sequencer provides a websocket endpoint that streams sequentially numbered transactions along with their corresponding events. If a client disconnects, it can reliably resume the stream from the last transaction it processed.</p>
<h2 id="next-step-ensuring-correctness"><a class="header" href="#next-step-ensuring-correctness">Next Step: Ensuring Correctness</a></h2>
<p>You now have a strong conceptual understanding of how a Sovereign SDK module is structured.</p>
<p>In the next chapter, <strong>"Testing Your Module,"</strong> we'll show you how to test your modules.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="testing-your-module"><a class="header" href="#testing-your-module">Testing Your Module</a></h1>
<p>In this section, we'll walk you through writing tests for the <code>ValueSetter</code> module you've been working on. The Sovereign SDK provides a powerful testing framework in the <a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/sov-test-utils"><code>sov-test-utils</code></a> crate that allows you to test your module's logic in an isolated environment, without needing to run a full rollup.</p>
<h2 id="step-1-setting-up-the-test-environment"><a class="header" href="#step-1-setting-up-the-test-environment">Step 1: Setting Up the Test Environment</a></h2>
<p>All module tests follow a similar pattern. First, we need to create a temporary, isolated runtime that includes our module. Then, for each test, we'll define the initial ("genesis") state and use a <code>TestRunner</code> to execute transactions and make assertions.</p>
<p>Let's build a <code>setup</code> helper function to handle this boilerplate.</p>
<h3 id="a-create-a-test-runtime"><a class="header" href="#a-create-a-test-runtime">a) Create a Test Runtime</a></h3>
<p>The first thing we need is a runtime to test against. The <code>generate_optimistic_runtime!</code> macro creates a temporary runtime that includes your <code>ValueSetter</code> module alongside the core modules (like the <a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-bank"><code>Bank</code></a>) needed for a functioning rollup.</p>
<pre><code class="language-rust">// Typically in tests/test_value_setter.rs
use sov_modules_api::Spec;
use sov_test_utils::{generate_optimistic_runtime, TestSpec};
use value_setter::{ValueSetter, ValueSetterConfig};

type S = TestSpec;

// This macro creates a temporary runtime for testing.
generate_optimistic_runtime!(
    TestRuntime &lt;=
    value_setter: ValueSetter&lt;S&gt;
);</code></pre>
<h3 id="b-create-a-setup-helper"><a class="header" href="#b-create-a-setup-helper">b) Create a <code>setup</code> Helper</a></h3>
<p>To avoid repeating code in every test, we'll create a <code>setup</code> function. This function will be responsible for creating test users, configuring the initial state of the rollup (the genesis state), and initializing the <code>TestRunner</code> that we'll use to drive the tests.</p>
<pre><code class="language-rust">use sov_test_utils::runtime::genesis::optimistic::HighLevelOptimisticGenesisConfig;
use sov_test_utils::runtime::TestRunner;
use sov_test_utils::TestUser;

// A helper struct to hold our test users, for convenience.
pub struct TestData&lt;S: Spec&gt; {
    pub admin: TestUser&lt;S&gt;,
    pub regular_user: TestUser&lt;S&gt;,
}

pub fn setup() -&gt; (TestData&lt;S&gt;, TestRunner&lt;TestRuntime&lt;S&gt;, S&gt;) {
    // Create two users, the first of which will be our admin.
    // (The `HighLevelOptimisticGenesisConfig` builder is a convenient way
    // to set up the initial state for core modules.)
    let genesis_config = HighLevelOptimisticGenesisConfig::generate()
        .add_accounts_with_default_balance(2);
    
    let mut users = genesis_config.additional_accounts().to_vec();
    let regular_user = users.pop().unwrap();
    let admin = users.pop().unwrap();

    let test_data = TestData {
        admin: admin.clone(),
        regular_user,
    };

    // Configure the genesis state for our ValueSetter module.
    let value_setter_config = ValueSetterConfig {
        admin: admin.address(),
    };

    // Build the final genesis config by combining
    // the core config with our module's specific config.
    let genesis = GenesisConfig::from_minimal_config(
        genesis_config.into(),
        value_setter_config,
    );
    
    // Initialize the TestRunner with the genesis state.
    // The runner gives us a simple way to execute transactions and query state.
    let runner = TestRunner::new_with_genesis(
        genesis.into_genesis_params(),
        TestRuntime::default(),
    );
    
    (test_data, runner)
}</code></pre>
<p>This <code>setup</code> function now gives us a freshly initialized test environment for every test case, with our <code>admin</code> and a <code>regular_user</code> ready to go.</p>
<h2 id="step-2-writing-a-happy-path-test"><a class="header" href="#step-2-writing-a-happy-path-test">Step 2: Writing a "Happy Path" Test</a></h2>
<p>Now, let's write our first test to ensure the admin can successfully set the value. We use a <code>TransactionTestCase</code> to bundle the transaction input with a set of assertions to run after execution.</p>
<pre><code class="language-rust">use sov_test_utils::{AsUser, TransactionTestCase};
use value_setter::{CallMessage, Event};

#[test]
fn test_admin_can_set_value() {
    // 1. Setup
    let (test_data, mut runner) = setup();
    let admin = &amp;test_data.admin;

    let new_value = 42;

    // 2. Execute the transaction
    runner.execute_transaction(TransactionTestCase {
        // The transaction input, created by the admin user.
        input: admin.create_plain_message::&lt;TestRuntime&lt;S&gt;, ValueSetter&lt;S&gt;&gt;(
            CallMessage::SetValue(new_value),
        ),
        // The assertions to run after execution.
        assert: Box::new(move |result, state| {
            // 3. Assert the outcome
            assert!(result.tx_receipt.is_successful());

            // Assert that the correct event was emitted.
            assert_eq!(result.events.len(), 1);
            let event = &amp;result.events[0];
            // Note: The event enum name (`TestRuntimeEvent`) is auto-generated by our `generate_optimistic_runtime!` macro.
            assert_eq!(
                event,
                &amp;TestRuntimeEvent::ValueSetter(Event::ValueUpdated(new_value))
            );

            // Assert that the state was updated correctly by querying the module.
            let value_setter = ValueSetter::&lt;S&gt;::default();
            let current_value = value_setter.value.get(state).unwrap();
            assert_eq!(current_value, Some(new_value));
        }),
    });
}</code></pre>
<h2 id="step-3-testing-a-failure-case"><a class="header" href="#step-3-testing-a-failure-case">Step 3: Testing a Failure Case</a></h2>
<p>It's equally important to test that our module fails when it should. Let's add a test to ensure a regular user <em>cannot</em> set the value.</p>
<pre><code class="language-rust">#[test]
fn test_regular_user_cannot_set_value() {
    // 1. Setup
    let (test_data, mut runner) = setup();
    let regular_user = &amp;test_data.regular_user;

    // 2. Execute the transaction from the non-admin user
    runner.execute_transaction(TransactionTestCase {
        // This time we're sending the transaction from the regular_user
        input: regular_user.create_plain_message::&lt;TestRuntime&lt;S&gt;, ValueSetter&lt;S&gt;&gt;(
            CallMessage::SetValue(99),
        ),
        assert: Box::new(move |result, state| {
            // 3. Assert that the transaction was reverted
            assert!(result.tx_receipt.is_reverted());
            
            // Optional: Check for the specific error message
            if let sov_modules_api::TxEffect::Reverted(err) = result.tx_receipt {
                assert!(err.reason.to_string().contains("Only the admin can set the value."));
            }

            // Assert that the state was NOT changed.
            let value_setter = ValueSetter::&lt;S&gt;::default();
            let current_value = value_setter.value.get(state).unwrap();
            assert_eq!(current_value, None); // It should remain un-set.
        }),
    });
}</code></pre>
<h2 id="step-4-running-your-tests"><a class="header" href="#step-4-running-your-tests">Step 4: Running Your Tests</a></h2>
<p>Execute your tests from your module's root directory using the standard Cargo command:</p>
<pre><code class="language-bash">cargo test
</code></pre>
<h2 id="additional-testing-capabilities"><a class="header" href="#additional-testing-capabilities">Additional Testing Capabilities</a></h2>
<p>The <a href="https://github.com/Sovereign-Labs/sovereign-sdk/blob/nightly/crates/module-system/sov-test-utils/src/runtime/mod.rs#L265"><code>TestRunner</code></a> provides methods for more advanced scenarios, all documented in the <a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/sov-test-utils"><code>sov-test-utils</code> crate</a>. Key capabilities include:</p>
<ul>
<li><strong>Batch Execution:</strong> Execute and assert on a sequence of transactions with <code>runner.execute_batch(...)</code>.</li>
<li><strong>Time Advancement:</strong> Test time-sensitive logic (like in <a href="./4-4-advanced-topics.html#hooks-responding-to-on-chain-events"><code>Hooks</code></a>) by advancing the slot count with <code>runner.advance_slots(...)</code>.</li>
<li><strong>Historical Queries:</strong> Query state at a specific block height with <code>runner.query_state_at_height(...)</code>.</li>
<li><strong>API Testing:</strong> Run an integrated REST API server for off-chain testing with <code>runner.query_api_response(...)</code>.</li>
</ul>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>With a thoroughly tested module, you can be confident that your on-chain logic is correct. The next step is to understand how users will interact with it from the outside world.</p>
<p>In the next chapter, <strong>"Wallets and Accounts,"</strong> we'll take a closer look at how users create accounts, sign transactions, and submit them to your rollup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="wallets-and-accounts"><a class="header" href="#wallets-and-accounts">Wallets and Accounts</a></h1>
<p>This section covers how accounts are created, which wallets are supported, and how transactions are signed in the Sovereign SDK. In the quickstart, you already submitted a transaction using an example js script; now, we'll explore the concepts behind that interaction.</p>
<p>The core design principle is <strong>Ethereum wallet compatibility</strong>. Sovereign SDK rollups use standard Ethereum addresses and signatures (Secp256k1), and provide compatibility with many popular wallets. However, there are some important nuances to understand.</p>
<h2 id="the-sovereign-sdk-transaction-type"><a class="header" href="#the-sovereign-sdk-transaction-type">The Sovereign SDK Transaction Type</a></h2>
<p>A critical distinction to grasp is that while addresses and signatures are Ethereum-compatible, the <strong>transaction format itself is unique to your rollup</strong>. A Sovereign SDK rollup does not natively accept standard Ethereum transactions.</p>
<p>Instead, your rollup's <code>Runtime</code> defines a custom <code>RuntimeCall</code> enum in Rust, which represents all possible actions a user can take. When a user sends a transaction, they are sending a signed message that contains this <code>RuntimeCall</code>. Remember the <code>call</code> object you created in the quickstart?</p>
<pre><code class="language-ts">// From the quickstart's examples/starter-js/src/index.ts
const call = {
    value_setter: {
        set_value: 99,
    },
};
</code></pre>
<p>This JavaScript object is a direct representation of a <code>RuntimeCall</code> variant. The Sovereign <code>web3.js</code> library takes this object, serializes it into a compact binary format, and then uses a signer to sign the hash of that data.</p>
<h2 id="signing-transactions-today-the-web3js-sdk--privy"><a class="header" href="#signing-transactions-today-the-web3js-sdk--privy">Signing Transactions Today: The <code>web3.js</code> SDK &amp; Privy</a></h2>
<p>The primary way for users and developers to sign and submit these custom transactions today is through the Sovereign <code>web3.js</code> client library. This library provides two main signer implementations:</p>
<p><strong>1.</strong> <code>Secp256k1Signer</code> <strong>(For Developers)</strong></p>
<p>This is a straightforward signer for programmatic use where you have direct access to a raw private key. It's perfect for scripting, backend services, or testing. The script you used in the quickstart uses this signer behind the scenes, with the private key pre-configured to match the <code>admin</code> address from your <code>genesis.json</code>.</p>
<pre><code class="language-ts">import { Secp256k1Signer } from "@sovereign-labs/signers";

// Initialize with a raw private key
const privKey = "0d87c12ea7c12024b3f70a26d735874608f17c8bce2b48e6fe87389310191264";
const signer = new Secp256k1Signer(privKey);

// Use the signer to send a transaction
await rollup.call(callMessage, { signer });
</code></pre>
<p><strong>2.</strong> <code>PrivySigner</code> <strong>(For User-Facing Applications)</strong></p>
<p>For most applications, asking users for a private key is not feasible or secure. This is where <strong>Privy</strong> comes in. <a href="https://www.privy.io/">Privy</a> is a powerful wallet-as-a-service provider that allows users to create a non-custodial wallet using familiar Web2 logins like email or social accounts. They can also connect their existing wallets (like MetaMask or Phantom).</p>
<p>The <code>sov-rollup-starter</code> repository includes a <a href="https://github.com/Sovereign-Labs/rollup-starter/tree/main/examples/privy">full example of integrating the <code>PrivySigner</code></a>, making it the most realistic and user-friendly way to onboard users to your rollup today. It handles all the complexity of wallet creation and signing, allowing users to interact with your application seamlessly.</p>
<h2 id="the-future-supporting-all-ethereum-wallets-by-leveraging-eip-712"><a class="header" href="#the-future-supporting-all-ethereum-wallets-by-leveraging-eip-712">The Future: Supporting All Ethereum Wallets by Leveraging EIP-712</a></h2>
<p>While Privy provides an excellent experience, it is crucial to meet users where they're at and enable support for all existing Ethereum wallets (including hardware wallets). This will be enabled by implementing a new <strong>EIP-712 Authenticator</strong> for the Sovereign SDK runtime (which we hope to complete by August 24, 2025).</p>
<p><strong>EIP-712</strong> is an Ethereum standard for signing typed, structured data. Instead of asking the user to sign a cryptic hash, EIP-712 allows wallets to display the transaction data in a human-readable, key-value format. This dramatically improves security and user experience, as users can see exactly what they are approving.</p>
<p>For example, a signature request using EIP-712 would look like this in MetaMask:</p>
<p><img src="/assets/message-signing.png" alt="A message signing request from Hyperliquid" /></p>
<p>This upcoming feature, inspired by the pioneering work of Hyperliquid, will allow developers to support all Ethereum wallets.</p>
<h2 id="next-steps-advanced-features"><a class="header" href="#next-steps-advanced-features">Next Steps: Advanced Features</a></h2>
<p>You now have a complete picture of how to build a module and enable users to interact with it.</p>
<p>In the next chapter, <strong>"Advanced Topics,"</strong> you'll learn about hooks, custom APIs, and other powerful features that will allow you to build complex onchain applications.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="advanced-topics"><a class="header" href="#advanced-topics">Advanced Topics</a></h1>
<p>This section covers advanced module development features that go beyond basic functionality.</p>
<p>Need to run logic on every block? Want to build custom APIs or integrate with off-chain services? Need configurable delays to reduce MEV for your application? You'll find the answers here.</p>
<p>Each of these features is optional, designed to be adopted as your application's needs evolve.</p>
<h2 id="hooks-responding-to-on-chain-events"><a class="header" href="#hooks-responding-to-on-chain-events">Hooks: Responding to On-Chain Events</a></h2>
<p>While the <code>call</code> method allows your module to react to direct user transactions, sometimes
you need your module to execute logic in response to broader onchain events. This is where <code>Hooks</code> come in.
They allow your module to "hook into" the lifecycle of a block or transaction, enabling
powerful automation.</p>
<h3 id="blockhooks-running-logic-at-block-boundaries"><a class="header" href="#blockhooks-running-logic-at-block-boundaries"><code>BlockHooks</code>: Running Logic at Block Boundaries</a></h3>
<p><code>BlockHooks</code> are triggered at the beginning and end of every block. They are ideal for logic that
needs to run periodically, independent of any specific transaction. For example, you could use
a <code>BlockHook</code> to:</p>
<ul>
<li>Distribute rewards once per block.</li>
<li>Update funding rate looking at the number of open positions at the end of every N blocks.</li>
</ul>
<p><strong>A word of caution</strong>: BlockHook computation is not paid for by any single user, so it's a "public good" of your rollup.
Be mindful of performance here; heavy computation in a BlockHook can make your rollup vulnerable to Denial-of-Service (DoS) attacks.</p>
<h3 id="txhooks-monitoring-all-transactions"><a class="header" href="#txhooks-monitoring-all-transactions">TxHooks: Monitoring All Transactions</a></h3>
<p>TxHooks run before and after every single transaction processed by the rollup. This makes them perfect for:</p>
<ul>
<li><strong>Global Invariant Checks</strong>: Ensuring a global property (like total supply of a token) is never violated by any module.</li>
<li><strong>Monitoring and Reactions</strong>: Allowing a compliance module to monitor all transfers and flag suspicious activity.</li>
</ul>
<p>Unlike <code>BlockHooks</code>, the gas for <code>TxHooks</code> is paid by the user who submitted the transaction.</p>
<h3 id="finalizehook-simple-off-chain-indexing"><a class="header" href="#finalizehook-simple-off-chain-indexing"><code>FinalizeHook</code>: Simple Off-Chain Indexing</a></h3>
<p>The <code>FinalizeHook</code> runs at the very end of a block's execution and can only write to <code>AccessoryState</code>. This makes it
cheap to run and very simple for storing data that are only meant to be read by off-chain APIs, not used by on-chain logic.
<strong>Note:</strong> FinalizeHook with AccessoryState works for basic indexing, but for a scalable, long‑term solution we recommend
the transactions WebSocket endpoint, which emits events and lets you subscribe from any transaction number. Stream those
events into a horizontally scalable store such as Postgres or a platform like Kafka Streams.</p>
<h3 id="implementing-hooks"><a class="header" href="#implementing-hooks">Implementing Hooks</a></h3>
<p>To use a hook, you simply import the corresponding trait from <code>sov_modules_api</code> and implement it for your module. The SDK automatically detects this implementation and will call the appropriate methods at the correct time during block processing.</p>
<p><strong>Example: Implementing</strong> <code>BlockHooks</code></p>
<p>To run logic at the beginning of each block, import the <code>BlockHooks</code> trait and implement it for your module:</p>
<pre><code class="language-rust">use sov_modules_api::{BlockHooks, Spec, StateCheckpoint};
// ... other imports

impl&lt;S: Spec&gt; BlockHooks for MyModule&lt;S&gt; {
    type Spec = S;

    // This method will be called at the beginning of every block.
    fn begin_rollup_block_hook(
        &amp;mut self,
        _pre_state_user_root: &amp;&lt;S::Storage as Storage&gt;::Root,
        _state: &amp;mut StateCheckpoint&lt;S&gt;,
    ) {
        // Your custom logic here...
    }
}</code></pre>
<p><strong>Note:</strong> Since the <code>FinalizeHook</code> only runs <em>natively</em>, it should be implemented under the <a href="4-4-advanced-topics.html#the-native-feature-flag"><code>native</code></a> flag. More on that later.</p>
<h2 id="error-handling-user-errors-vs-system-bugs"><a class="header" href="#error-handling-user-errors-vs-system-bugs">Error Handling: User Errors vs. System Bugs</a></h2>
<p>In a blockchain context, handling failure correctly is critical. Your module must clearly distinguish between two types of failures: expected <strong>user errors</strong> (which should gracefully revert a transaction) and unexpected <strong>system bugs</strong> (which may require halting the chain to prevent state corruption). The Sovereign SDK provides a clear pattern for this distinction.</p>
<h3 id="1-user-errors-returning-anyhowresult"><a class="header" href="#1-user-errors-returning-anyhowresult">1. User Errors: Returning <code>anyhow::Result</code></a></h3>
<p>For all expected, business-logic-level failures, your <code>call</code> method should return an <code>Err</code> containing an <code>anyhow::Error</code>. These are the errors you anticipate, such as a user attempting to transfer more tokens than they own, calling a method without the proper permissions, or providing invalid parameters.</p>
<p>When you return an <code>Err</code>, the SDK automatically reverts all state changes from the transaction. The goal is to safely reject the invalid transaction while providing a clear error message to the user and developer.</p>
<p>The <code>anyhow</code> crate provides several convenient macros for this. While you can always construct an error with <code>anyhow::anyhow!()</code>, the <code>bail!</code> and <code>ensure!</code> macros are generally preferred for their conciseness.</p>
<ul>
<li><code>bail!(message)</code>: Immediately returns an <code>Err</code>. It's a direct shortcut for <code>return Err(anyhow::anyhow!(message))</code>.</li>
<li><code>ensure!(condition, message)</code>: Checks a condition. If it's false, it returns an <code>Err</code> with the given message. This is perfect for validating inputs and permissions at the start of a function.</li>
</ul>
<p>Here’s how they look in practice, using the <code>Bank</code> module as an example:</p>
<pre><code class="language-rust">// From the Bank module's `create_token` method
fn create_token(
    // ...
) -&gt; Result&lt;TokenId&gt; {
    // Using `ensure!` to validate an input parameter.
    anyhow::ensure!(
        token_decimals &lt;= MAX_DECIMALS,
        "Too many decimal places."
    );

    // Using `bail!` to return an error after a more complex check.
    if initial_balance &gt; supply_cap {
        bail!(
            "Initial balance {} is greater than the supply cap {}",
            initial_balance,
            supply_cap
        );
    }
    // ...
    Ok(token_id)
}</code></pre>
<p><strong>Note:</strong> Because transaction reverts are a normal part of operation, they should be logged at a <code>debug</code> level if necessary, not as warnings or errors.</p>
<h3 id="2-system-bugs-panic"><a class="header" href="#2-system-bugs-panic">2. System Bugs: <code>panic!</code></a></h3>
<p>A <code>panic!</code> is an emergency stop. It should only be used for critical, unrecoverable bugs where a core assumption or invariant of your system has been violated.</p>
<ul>
<li><strong>When:</strong> An impossible state is reached (e.g., total supply becomes negative).</li>
<li><strong>What it does:</strong> Shuts down the rollup node to prevent state corruption.</li>
<li><strong>Goal:</strong> Alert the node operator to a critical software bug that needs immediate attention.</li>
</ul>
<p>Use <code>panic!</code> as your last line of defense. It signals that your module's integrity is compromised and continuing execution would be dangerous.</p>
<h2 id="node-side-logic-with-native-features"><a class="header" href="#node-side-logic-with-native-features">Node-Side Logic with Native Features</a></h2>
<p>A crucial architectural concept in the Sovereign SDK is the distinction between logic that is part of the verifiable state transition and logic that only runs natively on the full node or sequencer. The former must be deterministic and provable in a zkVM, while the latter is used for off-chain tooling like APIs, metrics, and transaction scheduling.</p>
<h3 id="the-native-feature-flag"><a class="header" href="#the-native-feature-flag">The <code>native</code> Feature Flag</a></h3>
<p>Any code that is <strong>not</strong> part of the core state transition must be gated with <code>#[cfg(feature = "native")]</code>:</p>
<pre><code class="language-rust">#[cfg(feature = "native")]
impl&lt;S: Spec&gt; MyModule&lt;S&gt; {
    // This code only compiles natively, not in zkVM
    pub fn debug_state(&amp;self, state: &amp;impl StateAccessor&lt;S&gt;) {
        // ...
    }
}</code></pre>
<p>This ensures that your zk-proofs remain small and your onchain logic remains deterministic. Common use cases for native-only code include:</p>
<ul>
<li>Custom REST APIs and RPC methods</li>
<li>Metrics and logging integration</li>
<li>Debugging tools</li>
<li>Integrations with external services</li>
</ul>
<h3 id="adding-custom-rest-apis"><a class="header" href="#adding-custom-rest-apis">Adding Custom REST APIs</a></h3>
<p>You can easily add custom APIs to your module by implementing the <code>HasCustomRestApi</code> trait. This trait has two methods - one which actually implements the routes, and an optional one which provides an <code>OpenApi</code> spec. You can see a good example in the <code>Bank</code> module:</p>
<pre><code class="language-rust">#![cfg(feature = "native")]
impl&lt;S: Spec&gt; HasCustomRestApi for Bank&lt;S&gt; {
    type Spec = S;

    fn custom_rest_api(&amp;self, state: ApiState&lt;S&gt;) -&gt; axum::Router&lt;()&gt; {
        axum::Router::new()
            .route(
                "/tokens/:tokenId/total-supply",
                get(Self::route_total_supply),
            )
            .with_state(state.with(self.clone()))
    }

    fn custom_openapi_spec(&amp;self) -&gt; Option&lt;OpenApi&gt; {
        let mut open_api: OpenApi =
            serde_yaml::from_str(include_str!("../openapi-v3.yaml")).expect("Invalid OpenAPI spec");
        for path_item in open_api.paths.paths.values_mut() {
            path_item.extensions = None;
        }
        Some(open_api)
    }
}

async fn route_balance(
    state: ApiState&lt;S, Self&gt;,
    mut accessor: ApiStateAccessor&lt;S&gt;,
    Path((token_id, user_address)): Path&lt;(TokenId, S::Address)&gt;,
) -&gt; ApiResult&lt;Coins&gt; {
    let amount = state
        .get_balance_of(&amp;user_address, token_id, &amp;mut accessor)
        .unwrap_infallible() // State access can't fail because no one has to pay for gas.
        .ok_or_else(|| errors::not_found_404("Balance", user_address))?;

    Ok(Coins { amount, token_id }.into())
}</code></pre>
<p>REST API methods get access to an <code>ApiStateAccessor</code>. This accessor provides a read-only view of the latest committed state. While it allows you to call state mutation methods (e.g., <code>set</code>, <code>delete</code>), these changes are temporary and are discarded at the end of the request. This design allows you to reuse view-logic from your module without the risk of accidentally modifying persistent state.</p>
<p>If you implement a custom REST API, your new routes will be automatically nested under your module's router. So, in the following example, the <code>tokens/:tokenId/total-supply</code> function can be found at <code>/modules/bank/tokens/:tokenId/total-supply</code>. Similarly, your OpenApi spec will get combined with the auto-generated one automatically.</p>
<p>Note that for for custom REST APIs, you'll need to manually write an <code>OpenApi</code> specification if you want client support.</p>
<h3 id="adding-legacy-rpc-support"><a class="header" href="#adding-legacy-rpc-support">Adding Legacy RPC Support</a></h3>
<p>In addition to custom RESTful APIs, the Sovereign SDK lets you create JSON-RPC methods. This is useful to provide API compatibility with existing chains like Ethereum and Solana, but we recommend using REST APIs whenever compatibility isn't a concern.</p>
<p>To implement RPC methods, simply annotate an <code>impl</code> block on your module with the <code>#[rpc_gen(client, server)]</code> macro, and then write methods which accept an <code>ApiStateAcessor</code> as their final argument and return an <code>RpcResult</code>. You can see some examples in the <a href="https://github.com/Sovereign-Labs/sovereign-sdk/blob/nightly/crates/module-system/module-implementations/sov-evm/src/rpc/mod.rs#L187"><code>Evm</code> module</a>.</p>
<pre><code class="language-rust">#![cfg(feature = "native")]
#[rpc_gen(client, server)]
impl&lt;S: Spec&gt; Evm&lt;S&gt; {
    /// Handler for `net_version`
    #[rpc_method(name = "eth_getStorageAt")]
    pub fn get_storage_at(
        &amp;self,
        address: Address,
        index: U256,
        state: &amp;mut ApiStateAccessor&lt;S&gt;,
    ) -&gt; RpcResult&lt;U256&gt; {
        let storage_slot = self
            .account_storage
            .get(&amp;(&amp;address, &amp;index), state)
            .unwrap_infallible()
            .unwrap_or_default();
        Ok(storage_slot)
    }
}</code></pre>
<h3 id="transaction-scheduling-for-mev-mitigation"><a class="header" href="#transaction-scheduling-for-mev-mitigation">Transaction Scheduling for MEV Mitigation</a></h3>
<p>For latency-sensitive financial applications, managing transaction order and mitigating Maximum Extractable Value (MEV) is critical. The Sovereign SDK provides a powerful, sequencer-level tool to combat toxic orderflow by allowing developers to introduce fine-grained processing delays for specific transaction types.</p>
<p>This is a powerful technique for applications like on-chain Central Limit Orderbooks (CLOBs). By introducing a small, artificial delay on aggressive "take" orders, a rollup can implicitly prioritize "cancel" orders. This gives market makers a crucial window to pull stale quotes before they can be exploited by low-latency arbitrageurs, leading to fairer and more liquid markets.</p>
<p>This functionality is implemented via the <code>get_transaction_delay_ms</code> method on your <code>Runtime</code> struct. Because this is a sequencer-level scheduling feature and not part of the core state transition logic, it must be gated behind the <code>native</code> feature flag.</p>
<p>The method receives a decoded <code>CallMessage</code> and returns the number of milliseconds the sequencer should wait before processing it. A return value of <code>0</code> means the transaction should be processed immediately.</p>
<h4 id="example-prioritizing-cancels-in-a-clob"><a class="header" href="#example-prioritizing-cancels-in-a-clob">Example: Prioritizing Cancels in a CLOB</a></h4>
<pre><code class="language-rust">// In your-rollup/stf/src/runtime.rs

// In the `impl&lt;S&gt; sov_modules_stf_blueprint::Runtime&lt;S&gt; for Runtime&lt;S&gt;` block:

#[cfg(feature = "native")]
fn get_transaction_delay_ms(&amp;self, call: &amp;Self::Decodable) -&gt; u64 {
    // `Self::Decodable` is the auto-generated `RuntimeCall` enum for your runtime.
    // It has one variant for each module in your `Runtime` struct.
    match call {
        // Introduce a small 50ms delay on all "take" orders to give
        // market makers time to cancel stale orders.
        // (Here, `Clob` is the variant corresponding to the `clob` field in your `Runtime` struct,
        // and `PlaceTakeOrder` is the variant of the `clob` module's `CallMessage` enum.)
        Self::Decodable::Clob(clob::CallMessage::PlaceTakeOrder { .. }) =&gt; 50,

        // All other CLOB operations, like placing or cancelling "make" orders,
        // are processed immediately with zero delay.
        Self::Decodable::Clob(..) =&gt; 0,
        
        // All other transactions in other modules are also processed immediately.
        _ =&gt; 0,
    }
}</code></pre>
<p>This feature gives you precise control over your sequencer's processing queue, enabling sophisticated MEV mitigation strategies without altering your onchain business logic.</p>
<h2 id="mastering-your-module"><a class="header" href="#mastering-your-module">Mastering Your Module</a></h2>
<p>With a solid grasp of module implementation, it's time to focus on performance. The next chapter, <strong>"Understanding Performance,"</strong> dives into the key considerations for building a fast and efficient rollup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-performance"><a class="header" href="#understanding-performance">Understanding Performance</a></h1>
<p>The performance of your modules directly impacts your rollup's throughput, latency, and user transaction costs. While the SDK handles many optimizations automatically, your design choices—especially regarding state accesses and cryptography—are the biggest levers you have.</p>
<h2 id="state-access-the-golden-rule-is-to-minimize-distinct-accesses"><a class="header" href="#state-access-the-golden-rule-is-to-minimize-distinct-accesses">State Access: The Golden Rule is to Minimize Distinct Accesses</a></h2>
<p><strong>The Problem: Every State Access Has a High Fixed Cost</strong></p>
<p>The vast majority of the cost of executing a transaction comes from state accesses. Each time you call <code>.get()</code> or <code>.set()</code> on a <em>distinct</em> state item for the first time in a block (a "cold" access), the SDK must generate a Merkle proof for that item. This proof is required by the ZK-prover to verify that the data is part of the correct state root. Generating these proofs is expensive.</p>
<p>Accessing a value that has already been touched in the current block (a "hot" access) is much cheaper because the proof has already been generated and cached.</p>
<p><strong>The Solution: Bundle Related Data</strong></p>
<p>The most effective optimization is to group data that is frequently read or written together into a single <code>StateValue</code>.</p>
<p>Consider a user profile module. A naive implementation might look like this:</p>
<pre><code class="language-rust">// ANTI-PATTERN: Separated state items
#[state]
pub usernames: StateMap&lt;S::Address, String&gt;,
#[state]
pub bios: StateMap&lt;S::Address, String&gt;,
#[state]
pub follower_counts: StateMap&lt;S::Address, u64&gt;,</code></pre>
<p>Loading a single user's profile would require three distinct (and expensive) state accesses. A much better approach is to bundle the data:</p>
<pre><code class="language-rust">// GOOD PATTERN: Bundled state
pub struct ProfileData {
    pub username: String,
    pub bio: String,
    pub follower_count: u64,
}

#[state]
pub profiles: StateMap&lt;S::Address, ProfileData&gt;,</code></pre>
<p>Now, loading a profile requires only one state access.</p>
<p><strong>The Trade-off:</strong> This bundling increases the size of the value being read from storage, but it saves the massive fixed cost of generating a new Merkle proof for a separate state access. This trade-off is almost always worth it.</p>
<p>While precise numbers can change with SDK updates, the cost of reading even a few hundred extra bytes is negligible compared to the cost of a distinct "cold" state access. Therefore, the guiding principle is: if data items have a reasonable probability of being used together, you should bundle them. If two items are <strong>always</strong> accessed together, they should <strong>always</strong> be in the same state item, regardless of size.</p>
<h2 id="cryptography-use-zk-optimized-implementations"><a class="header" href="#cryptography-use-zk-optimized-implementations">Cryptography: Use ZK-Optimized Implementations</a></h2>
<p><strong>The Problem: General-Purpose Crypto is Slow to Prove</strong></p>
<p>The other common source of performance issues is heavy-duty cryptography. Many standard Rust crypto libraries are not optimized for ZK environments and can be extremely slow to prove, creating a bottleneck that limits your rollup's throughput.</p>
<p><strong>The Solution Hierarchy:</strong></p>
<ol>
<li><strong>Preferred:</strong> Use the implementations provided by the <code>Spec::CryptoSpec</code> associated type. These are guaranteed to be selected for their ZK-friendly performance.</li>
<li><strong>If you must use an external library:</strong> Be aware of the potential for a severe performance penalty during proof generation.</li>
<li><strong>For advanced, specialized needs:</strong> Consider using a library tailored to a specific ZKVM (like <code>SP1</code> or <code>Risc0</code>). This will give you better performance but will tie your module to that specific proving system.</li>
</ol>
<h2 id="next-up-prebuilt-modules"><a class="header" href="#next-up-prebuilt-modules">Next up: Prebuilt Modules</a></h2>
<p>Building custom modules is powerful, but you don't always have to start from scratch. The next chapter introduces the SDK's <strong>"Prebuilt Modules,"</strong> which provide ready-to-use solutions for common tasks like token management and bridging.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prebuilt-modules"><a class="header" href="#prebuilt-modules">Prebuilt Modules</a></h1>
<p>The SDK provides a large suite of prebuilt, well-maintained modules that handle common blockchain primitives. Leveraging these modules allows you to focus on your application's unique logic instead of reinventing the wheel.</p>
<p>This page serves as a reference guide to the standard modules included with the SDK.</p>
<div class="table-wrapper"><table><thead><tr><th>Module</th><th>Crate Link</th><th>Description</th></tr></thead><tbody>
<tr><td><strong>User-Facing</strong></td><td></td><td><em>Modules that directly provide user-facing application logic.</em></td></tr>
<tr><td>Bank</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-bank"><code>sov-bank</code></a></td><td>Creates and manages fungible tokens. Handles minting, transfers, and burning.</td></tr>
<tr><td>Paymaster</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-paymaster"><code>sov-paymaster</code></a></td><td>Enables gas sponsorship (meta-transactions), allowing users to transact without needing to hold gas tokens.</td></tr>
<tr><td>Chain State</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-chain-state"><code>sov-chain-state</code></a></td><td>Provides on-chain access to block metadata like the current block height and hash.</td></tr>
<tr><td>EVM</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-evm"><code>sov-evm</code></a></td><td>An EVM compatibility layer that executes standard, RLP-encoded Ethereum transactions.</td></tr>
<tr><td>SVM</td><td><a href="fix-link"><code>sov-svm</code></a></td><td>A Solana VM compatibility layer that executes standard Solana transactions (maintained by the <a href="https://www.termina.technology/">Termina</a> team).</td></tr>
<tr><td><strong>Core Infrastructure</strong></td><td></td><td><em>Modules that provide fundamental, system-level capabilities.</em></td></tr>
<tr><td>Accounts</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-accounts"><code>sov-accounts</code></a></td><td>Manages user accounts, public keys, and nonces.</td></tr>
<tr><td>Uniqueness</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-uniqueness"><code>sov-uniqueness</code></a></td><td>Provides transaction deduplication logic using either nonces (Ethereum-style) or generation numbers (for low-latency applications).</td></tr>
<tr><td>Blob Storage</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-blob-storage"><code>sov-blob-storage</code></a></td><td>A deferred blob storage system that enables soft-confirmations without losing censorship resistance.</td></tr>
<tr><td><strong>Bridging</strong></td><td></td><td><em>Modules for interoperability with other blockchains.</em></td></tr>
<tr><td>Hyperlane Bridge</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/hyperlane"><code>sov-hyperlane-mailbox</code></a></td><td>An integration with the Hyperlane interoperability protocol, enabling messaging and token bridging to other blockchains (EVM, SVM, Cosmos).</td></tr>
<tr><td><strong>Rollup Economics</strong></td><td></td><td><em>Modules for managing incentives and fee distribution.</em></td></tr>
<tr><td>Sequencer Registry</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-sequencer-registry"><code>sov-sequencer-registry</code></a></td><td>Manages sequencer registration, bonding, and rewards distribution (for decentralized sequencing).</td></tr>
<tr><td>Prover Incentives</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-prover-incentives"><code>sov-prover-incentives</code></a></td><td>Manages prover registration, proof validation, and rewards distribution.</td></tr>
<tr><td>Attester Incentives</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-attester-incentives"><code>sov-attester-incentives</code></a></td><td>Manages the attestation/challenge process for optimistic rollups, including bonding and rewards.</td></tr>
<tr><td>Revenue Share</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-revenue-share"><code>sov-revenue-share</code></a></td><td>Automates on-chain fee sharing for the use of premium SDK components, such as the low-latency sequencer.</td></tr>
<tr><td><strong>Development &amp; Testing</strong></td><td></td><td><em>Helper modules for the development and testing lifecycle.</em></td></tr>
<tr><td>Value Setter</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-value-setter"><code>sov-value-setter</code></a></td><td>A minimal example module used throughout the documentation for teaching purposes.</td></tr>
<tr><td>Synthetic Load</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/sov-synthetic-load"><code>sov-synthetic-load</code></a></td><td>A utility module for generating heavy transactions to assist with performance testing and benchmarking.</td></tr>
<tr><td>Module Template</td><td><a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/module-system/module-implementations/module-template"><code>module-template</code></a></td><td>A starter template demonstrating best practices for module structure, including state, calls, and events.</td></tr>
</tbody></table>
</div>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>In the next section, <strong>"Additional Capabilities,"</strong> you'll get a high-level overview of these features and how we can help you integrate them.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="additional-capabilities"><a class="header" href="#additional-capabilities">Additional Capabilities</a></h1>
<p>The Sovereign SDK includes many advanced features beyond the core functionality covered in this documentation. The features listed in
this section are already available or very near completion, but are not yet comprehensively documented.</p>
<p><strong>To learn more about implementing these features in your rollup, just shoot us a message in our <a href="https://join.slack.com/t/sovereigndevelopers/shared_invite/zt-39aolimfp-XsFK6dL6LhOFHhtXsD_kCA">support channel</a> or fill out our <a href="https://airtable.com/app9kbNZcvqdrOidH/shrPlG9rok3sVd8Mh">partner form</a> and we'll reach out to you.</strong></p>
<h3 id="performance--reliability"><a class="header" href="#performance--reliability">Performance &amp; Reliability</a></h3>
<ul>
<li><strong>Automatic sequencer fail-over</strong> – Seamless failover across data centers ensures your soft-confirmations survive even the worst outages</li>
<li><strong>Intra-block caching</strong> – Cache state that's repeatedly accessed throughout a block, eliminating redundant instantiation per transaction and significantly boosting performance</li>
<li><strong>Dev-Ops tooling</strong> – Production-ready observability and deployment tools</li>
</ul>
<h3 id="integrations--compatibility"><a class="header" href="#integrations--compatibility">Integrations &amp; Compatibility</a></h3>
<ul>
<li><strong>Ethereum or Solana addresses and wallet support</strong> – Use any address format or wallet you prefer</li>
<li><strong>Hyperlane integration</strong> – Bridge liquidity from any EVM, SVM, or Cosmos SDK chain</li>
<li><strong>Multiple zkVM integrations</strong> – Choose the ZK-prover that best suits your application's performance characteristics, with support for Risc0, SP1, and other Rust-compatible ZKVMs.</li>
</ul>
<p>We're happy to help you leverage these features to build production-ready rollups tailored to your exact requirements.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="instrumenting-your-rollup"><a class="header" href="#instrumenting-your-rollup">Instrumenting Your Rollup</a></h1>
<p>Proper instrumentation is essential for monitoring, debugging, and optimizing your rollup in production. The Sovereign SDK provides comprehensive observability tools that help you understand your rollup's behavior and performance.</p>
<h2 id="getting-started-with-observability"><a class="header" href="#getting-started-with-observability">Getting Started with Observability</a></h2>
<p>The <a href="https://github.com/Sovereign-Labs/rollup-starter">rollup starter</a> repository includes a complete observability stack that gives you instant visibility into your rollup. With a single command, you can spin up a local monitoring environment:</p>
<pre><code class="language-bash">$ make start-obs
...
Waiting for all services to become healthy...
⏳ Waiting for services... (45 seconds remaining)
✅ All observability services are healthy!
🚀 Observability stack is ready:
   - Grafana:     http://localhost:3000 (admin/admin123)
   - InfluxDB:    http://localhost:8086 (admin/admin123)
</code></pre>
<p>This command starts all necessary Docker containers and automatically provisions Grafana dashboards specifically designed for rollups. You'll immediately see key metrics like block production rate, transaction throughput, and system performance.</p>
<p>To stop the observability stack:</p>
<pre><code class="language-bash">make stop-obs
</code></pre>
<p>For production deployments and advanced configuration, check out our <a href="https://sovlabs.notion.site/Tutorial-Getting-started-with-Grafana-Cloud-17e47ef6566b80839fe5c563f5869017?pvs=74">Observability Tutorial</a>.</p>
<h2 id="adding-custom-instrumentation"><a class="header" href="#adding-custom-instrumentation">Adding Custom Instrumentation</a></h2>
<p>While the default dashboards provide excellent baseline monitoring, every rollup has unique requirements. You'll want to add custom instrumentation to track:</p>
<ul>
<li>Application-specific metrics (e.g., DEX trading volume, NFT mints)</li>
<li>Performance bottlenecks in your custom modules</li>
</ul>
<p>This section will teach you how to:</p>
<ul>
<li><strong><a href="6-1-metrics.html">Add Custom Metrics</a></strong> - Track performance indicators and business metrics using the SDK's metrics framework</li>
<li><strong><a href="6-2-logging.html">Implement Structured Logging</a></strong> - Debug and monitor your rollup's execution with contextual logs</li>
</ul>
<h2 id="important-native-only-features"><a class="header" href="#important-native-only-features">Important: Native-Only Features</a></h2>
<p>All instrumentation code must be gated with <code>#[cfg(feature = "native")]</code> to ensure it only runs on full nodes, not in the zkVM during proof generation. This critical distinction allows you to instrument generously without affecting proof generation performance or determinism.</p>
<p>Let's dive into the specifics of adding metrics and logging to your rollup.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="metrics"><a class="header" href="#metrics">Metrics</a></h1>
<p>The SDK includes a custom metrics system called <a href="https://github.com/Sovereign-Labs/sovereign-sdk/tree/nightly/crates/full-node/sov-metrics"><code>sov-metrics</code></a> designed specifically for rollup monitoring. It uses the <a href="https://docs.influxdata.com/influxdb/cloud/reference/syntax/line-protocol/">Telegraf line protocol</a> format and integrates with Telegraf through socket listeners for efficient data collection. Metrics are automatically timestamped and sent to your configured Telegraf endpoint, which typically forwards them to InfluxDB for storage and Grafana for visualization. Metrics can only be tracked in <strong>native mode</strong> (not in zkVM).</p>
<p><strong>Important</strong>: Metrics are emitted immediately when tracked and are NOT rolled back if a transaction reverts. This means failed transactions will still have their metrics recorded, which can be useful for debugging and monitoring error rates.</p>
<h2 id="basic-example"><a class="header" href="#basic-example">Basic Example</a></h2>
<pre><code class="language-rust">#[cfg(feature = "native")]
use sov_metrics::{track_metrics, start_timer, save_elapsed};

impl&lt;S: Spec&gt; MyModule&lt;S&gt; {
    fn process_batch(&amp;self, items: Vec&lt;Item&gt;) -&gt; Result&lt;()&gt; {
        // Time the operation using the provided macros
        start_timer!(batch_timer);
            
        for item in items {
            self.process_item(item)?;
        }
            
        save_elapsed!(elapsed SINCE batch_timer);

        #[cfg(feature = "native")] 
        {
            // Track batch size
            track_metrics(|tracker| {
                tracker.submit_inline(
                    "mymodule_batch_size",
                    format!("items={}", items.len()),
                );
            });
            
            // Track processing time
            track_metrics(|tracker| {
                tracker.submit_inline(
                    "mymodule_batch_processing_time",
                    format!("duration_ms={}", elapsed.as_millis()),
                );
            });
        }
        
        Ok(())
    }
}</code></pre>
<h2 id="tracking-custom-metrics"><a class="header" href="#tracking-custom-metrics">Tracking Custom Metrics</a></h2>
<p>To track custom metrics, implement the <code>Metric</code> trait:</p>
<pre><code class="language-rust">// Implement your custom metric in a file of your own choosing...
#![cfg(feature = "native")]
use sov_metrics::Metric;
use sov_metrics::{track_metrics, start_timer, save_elapsed};
use std::io::Write;

#[derive(Debug)]
struct TransferMetric {
    from: String,
    to: String,
    token_id: TokenId,
    amount: u64,
    duration_ms: u64,
}

impl Metric for TransferMetric {
    fn measurement_name(&amp;self) -&gt; &amp;'static str {
        "mymodule_transfers"
    }
    
    fn serialize_for_telegraf(&amp;self, buffer: &amp;mut Vec&lt;u8&gt;) -&gt; std::io::Result&lt;()&gt; {
        // Format: measurement_name,tag1=value1,tag2=value2 field1=value1,field2=value2
        write!(
            buffer,
            "{},from={},to={},token_id={} amount={},duration_ms={}",
            self.measurement_name(),
            self.from,
            self.to,
            self.token_id,
            self.amount,
            self.duration_ms
        )
    }
}

// In your module file...
#[cfg(feature = "native")]
use sov_metrics::{track_metrics, start_timer, save_elapsed};
#[cfg(feature = "native")]
use my_custom_metrics::TransferMetric;

// Adapted from Bank module 
impl&lt;S: Spec&gt; Bank&lt;S&gt; {
    fn transfer(&amp;self, from: &amp;S::Address, to: &amp;S::Address, token_id: &amp;TokenId, amount: u64, state: &amp;mut impl TxState&lt;S&gt;) -&gt; Result&lt;()&gt; {

        start_timer!(transfer_timer);
        
        // Perform the transfer
        self.do_transfer(from, to, token_id, amount, state)?;
        
        save_elapsed!(elapsed SINCE transfer_timer);
        
        #[cfg(feature = "native")]
        {
            // Track your custom metric
            track_metrics(|tracker| {
                tracker.submit_metric(TransferMetric {
                    from: from.to_string(),
                    to: to.to_string(),
                    token_id: token_id.clone(),
                    amount,
                    duration_ms: elapsed.as_millis() as u64,
                });
            });
        }
        
        Ok(())
    }
}</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>Note: While the SDK provides comprehensive metrics infrastructure, individual modules in the SDK don't currently use metrics directly. Most metrics are tracked at the system level (runner, sequencer, state transitions). The examples here show how you <em>could</em> add metrics to your custom modules.</p>
<ol>
<li><strong>Always gate with <code>#[cfg(feature = "native")]</code></strong> - Metrics are not available in zkVM</li>
<li><strong>Use meaningful measurement names</strong>
<ul>
<li>A lot of the packages that Sovereign SDK runs under the hood emit metrics.
To make it easy to discern that the metrics come from a Sovereign SDK component, we
follow the pattern of <code>sov_</code> in our metric names. We recommend following the
pattern <code>sov_user_module_name_metric_type</code> so that it's easy to discern user level
metric types.</li>
</ul>
</li>
<li><strong>Separate tags and fields properly</strong>:
<ul>
<li><a href="https://docs.influxdata.com/influxdb/cloud/reference/syntax/line-protocol/#elements-of-line-protocol">Telegraf line protocol discerns between Tags and Fields by separating them with a single whitespace</a>. Make sure to write your metrics accordingly.</li>
<li>Tags: Categorical values for filtering (types, status, enum variants), both their keys and values can only be strings</li>
<li>Fields: Numerical values you want to aggregate (counts, durations, amounts), their keys can be strings, and values can be one of: floats, integers, unsigned integers, strings, and booleans</li>
</ul>
</li>
<li><strong>Track business-critical metrics</strong>:
<ul>
<li>Transaction volumes and types</li>
<li>Processing times for key operations</li>
<li>Error rates and types</li>
</ul>
</li>
<li><strong>Avoid high-cardinality tags</strong> - Don't use unique identifiers like transaction hashes as tags</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="logging"><a class="header" href="#logging">Logging</a></h1>
<p>The SDK uses the <a href="https://docs.rs/tracing/latest/tracing/"><code>tracing</code></a> crate for structured logging, providing rich context and efficient filtering.</p>
<p><strong>Important</strong>: Logs are emitted immediately when generated and are NOT rolled back if a transaction reverts. This means failed transactions will still have their logs recorded, which is useful for debugging or monitoring why transactions failed.</p>
<h2 id="basic-logging-patterns"><a class="header" href="#basic-logging-patterns">Basic Logging Patterns</a></h2>
<pre><code class="language-rust">// Adapted from the `Bank` module
use tracing::trace;

impl&lt;S: Spec&gt; MyModule&lt;S&gt; {
    pub(crate) fn freeze(
        &amp;mut self,
        token_id: TokenId,
        context: &amp;Context&lt;S&gt;,
        state: &amp;mut impl TxState&lt;S&gt;,
    ) -&gt; Result&lt;()&gt; {
        // Logging at the start of operation
        trace!(freezer = %sender, "Freeze token request");

        // Redundant code elided here...

        token
            .freeze(sender)
            .with_context(|| format!("Failed to freeze token_id={}", &amp;token_id))?;

        self.tokens.set(&amp;token_id, &amp;token, state)?;

        // Logging at the end of operation
        trace!(
            freezer = %sender,
            %token_id,
            "Successfully froze tokens"
        );

        Ok(())
    }
}</code></pre>
<h2 id="using-spans-for-context"><a class="header" href="#using-spans-for-context">Using Spans for Context</a></h2>
<p>Spans are like invisible context that gets automatically attached to every log line within their scope. Instead of passing context like <code>batch_id</code> or <code>user_id</code> through every function call just so you can log it, you create a span at the top level and all logs within that span automatically include that context.</p>
<p>Think of spans as a way to say "everything that happens from here until the span ends is part of this operation." This is especially useful when debugging - you can filter logs by span fields to see everything that happened during a specific batch process or user request.</p>
<pre><code class="language-rust">use tracing::instrument;

// Example 1: Using the #[instrument] macro (easiest way)
#[instrument(skip(self, state, items))]  // skip large/non-Debug types
fn process_batch(&amp;self, batch_id: BatchId, items: Vec&lt;Item&gt;, state: &amp;mut impl TxState&lt;S&gt;) -&gt; Result&lt;()&gt; {
    // The #[instrument] macro automatically adds all function parameters (except skipped ones) to the span
    // So batch_id is automatically included in all logs within this function
    info!(item_count = items.len(), "Starting batch processing");
    
    for (idx, item) in items.iter().enumerate() {
        // This log will show: batch_id=123 item_id=456 "Processing item"
        trace!(item_index = idx, item_id = %item.id, "Processing item");
        self.process_single_item(item, state)?;
    }
    
    info!("Batch processing completed");
    Ok(())
}

// Example 2: Creating spans manually (when you need more control)
fn process_user_request(&amp;self, user_id: UserId, request: Request) -&gt; Result&lt;()&gt; {
    // Create a span with context that will be included in all logs
    let span = tracing::span!(
        tracing::Level::INFO,
        "user_request", // span name
        %user_id,
        request_type = %request.request_type()
    );
    
    // Enter the span - all logs from here will include user_id and request_type
    let _enter = span.enter();
    
    debug!("Validating request");
    self.validate_request(&amp;request)?;
    
    debug!("Processing request");
    self.process(&amp;request)?;
    
    info!("Request completed successfully");
    Ok(())
}</code></pre>
<h2 id="log-levels"><a class="header" href="#log-levels">Log Levels</a></h2>
<ul>
<li><code>error!</code> - Unrecoverable errors that affect module operation</li>
<li><code>warn!</code> - Recoverable issues or unusual conditions</li>
<li><code>info!</code> - High-level operations (tx processing, module lifecycle)</li>
<li><code>debug!</code> - Detailed operational data (state changes, intermediate values)</li>
<li><code>trace!</code> - Very detailed execution flow</li>
</ul>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<ol>
<li>
<p><strong>Structure your logs</strong>:</p>
<pre><code class="language-rust">// Good - structured, filterable
debug!(user = %address, action = "deposit", amount = %value, "Processing deposit");

// Avoid - unstructured string interpolation
debug!("Processing deposit for {} of amount {}", address, value);</code></pre>
</li>
<li>
<p><strong>Include relevant context</strong>:</p>
<ul>
<li>Transaction/operation IDs</li>
<li>User addresses (when relevant)</li>
<li>Amounts and values</li>
<li>Error details</li>
<li>State transitions</li>
</ul>
</li>
<li>
<p><strong>Don't log transaction reverts as errors or warnings</strong>:
Transaction reverts are expected behavior. Log them at <code>debug!</code> level if needed for debugging:</p>
<pre><code class="language-rust">if balance &lt; amount {
    debug!(
        user = %sender,
        requested = %amount,
        available = %balance,
        "Transfer failed due to insufficient balance"
    );
    return Err(anyhow::anyhow!("Insufficient balance"));
}</code></pre>
</li>
<li>
<p><strong>Keep frequently triggered logs at debug or trace level</strong>:
Any log that gets triggered by every call to your module should use <code>debug!</code> or <code>trace!</code> to avoid log spam:</p>
<pre><code class="language-rust">// Good - routine operations at trace level
trace!(method = "transfer", from = %sender, "Processing transfer request");

// Bad - routine operations at info level will spam logs
info!("Transfer request received");  // Don't do this for every call</code></pre>
</li>
<li>
<p><strong>Use conditional logging for expensive operations</strong>:</p>
<pre><code class="language-rust">#[cfg(feature = "native")]
fn debug_state(&amp;self, state: &amp;impl StateAccessor&lt;S&gt;) {
    if tracing::enabled!(tracing::Level::TRACE) {
        let total_accounts = self.count_accounts(state);
        let total_balance = self.calculate_total_balance(state);
        trace!(
            %total_accounts,
            %total_balance,
            "Module state snapshot"
        );
    }
}</code></pre>
</li>
</ol>
<p>Set log levels via environment variables:</p>
<pre><code class="language-bash">RUST_LOG=info,my_module=debug cargo run
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-contributors"><a class="header" href="#sdk-contributors">SDK Contributors</a></h1>
<p>This section provides an overview of the Sovereign SDK aimed at core
contributors to the framework. It describes the primary components of the SDK at
the level of Rust crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-lifecyle-overview"><a class="header" href="#transaction-lifecyle-overview">Transaction Lifecyle Overview</a></h1>
<p>The transaction lifecycle begins with a <em>user</em>. First, the user opens a frontend
and gets some information about the current state of the blockchain. Then, they
open their wallet and sign a message indicating what action they want to take.</p>
<p>Once a message is signed, it needs to be ordered before full nodes can execute
it, so the user's next step is to contact a <em>sequencer</em> to post the transaction
onto the DA layer.</p>
<p>The sequencer accepts a number of transactions and bundles them into a single
<em><code>Blob</code></em>, which he sends to the DA layer for inclusion. This <code>Blob</code> is
ultimately sent to a <code>Proposer</code> on the DA layer, who includes it in his block
and gets it approved by the DA layer's validator set. Once consensus is reached
on the DA layer block containing the sequencer's <code>Blob</code>, the full nodes of the
rollup parse its contents and execute the transactions, computing a new rollup
state.</p>
<p>Next, specialized actors ("provers" or "attesters") generate a proof of the new
rollup state and post it onto the <code>DA layer</code>. Finally, light clients of the
rollup (end-users and/or bridges on other blockchains) verify the proof and see
the results of the transaction.</p>
<p><img src="../assets/tx-lifecycle.png" alt="Diagram of the Transaction Lifecycle" /></p>
<h1 id="sdk-design-philosophy"><a class="header" href="#sdk-design-philosophy">SDK Design Philosophy</a></h1>
<p>Now that we've established the basic transaction lifecycle, we have the
background we need to really dig into the design of the Sovereign SDK.</p>
<p>At a high level, the design process for the SDK was essentially just tracing the
transaction lifecycle diagram and asking two questions at each step:</p>
<ul>
<li>"How do we implement this step so that we really 'inherit the security of the
L1'?"</li>
<li>"Within those constraints, how do we build the SDK to accommodate the broadest
range of use cases?"</li>
</ul>
<h2 id="step-1-retrieving-information"><a class="header" href="#step-1-retrieving-information">Step 1: Retrieving Information</a></h2>
<p>Before doing anything, users need to find out about the current state of the
rollup. How can we enable that?</p>
<p>At this step, we have several conflicting goals and constraints:</p>
<ul>
<li>We want the user's view of the rollup to be as up-to-date as possible</li>
<li>We want to provide the strongest possible guarantees that the user's view of
state is correct</li>
<li>We want to minimize costs for the rollup</li>
<li>Users may not be willing/able to download more than a few hundred kilobytes of
data or do any significant computation</li>
</ul>
<p>Obviously, it's not possible to optimize all of these constraints
simultaneously. So, in the Sovereign SDK, we allow developers some flexibility
to pick the appropriate tradeoffs for their rollups - and we give end-users
additional flexibility to choose the setup that works best for them.</p>
<p>In practice, that means that...</p>
<ul>
<li>Developers can choose between Optimistic and ZK rollups, trading transaction
cost for time-to-finality.</li>
<li>Users can choose between running a full node (instant state access, but
expensive), running a light client (slower state access, but much cheaper and
trustless) and trusting a full node (instant state access)</li>
</ul>
<h2 id="step-2-signing-transactions"><a class="header" href="#step-2-signing-transactions">Step 2: Signing Transactions</a></h2>
<p>The SDK supports several signing/verification modes. The standard choice for
interacting with Sovereign SDK chains is our custom <code>UniversalWallet</code>, which is
available as a Metamask snap and a Ledger app. The <code>UniversalWallet</code> integrates
tightly with the Sovereign SDK to render transactions in human-readable format.
However, many chains need compatibility with legacy formats like Ethereum RLP
transactions or Solana instructions</p>
<p>We've made the pragmatic choice to be as compatible as possible with existing
crypto wallets using our <code>RuntimeAuthenticator</code> abstraction. By implementing the
<code>RuntimeAuthenticator</code>trait, developers cab bring their own transaction
deserialization and authorization logic. Even better, we allow rollups to
support several different <code>Authenticator</code> implementations simultaneously. This
allows developers to retain backward compatibility with legacy transaction
formats, without compromising on support for their native functionality.</p>
<h2 id="step-3-sequencing"><a class="header" href="#step-3-sequencing">Step 3: Sequencing</a></h2>
<p>Once a user has signed a transaction, we need to broadcast it to all full nodes
of the rollup.</p>
<p>Since a primary design goal is to inherit the security of the underlying
blockchain, we want to ensure that users are always able to fall back on the
censorship resistance of the L1 if necessary. At the same time, we don't expect
users to interact directly with the underlying blockchain in the normal case.
The underlying blockchain will charge fees in its own token, and we don't need
or want users of the rollup to be thinking about exchange rates and L1 gas
limits.</p>
<p>We also need to protect the rollup from spam. In a standard blockchain, spam is
handled by ensuring that everyone pays for the computation that the network does
on their behalf. Transactions with invalid signatures are filtered out at the
peer-to-peer layer and never get included in blocks. This means that an attacker
wanting to spam the rollup has no asymmetric advantage. He can send invalid
transactions to the few nodes he happens to be directly connected to, but they
will just disconnect. The only way to get the <em>entire blockchain network</em> to
process a transaction is to provide a valid signature and pay enough gas fees to
cover the cost of execution.</p>
<p>In a rollup, things are different. Rollups <em>inherit</em> the consensus of an
underlying blockchain <em>which doesn't know about the transaction validity rules
of the rollup</em>. Since the underlying chain doesn't know the rules, it can't
enforce them. So, we need to be prepared to deal with the fact that the rollup's
ledger is <em>dirty</em>. This is bad news, because checking transaction signatures is
expensive - especially in zero-knowledge. If we aren't careful, an attacker
could flood the rollup's ledger with malformed transactions and force the entire
network to pay to check thousands of invalid signatures.</p>
<p>This is where the sequencer comes in. Sequencers accept transactions from users
and bundle them into <code>Blob</code>s, which get posted onto the L1. At the rollup level,
we force all sequencers to register by locking up some tokens - and we ignore
any transactions which aren't posted by a registered sequencer. If a sequencer's
bundle includes any transactions which have invalid signatures, we slash his
deposit and remove him from the registry. This solves two problems at once.
<em>Users</em> don't need to worry about obtaining tokens to pay for inclusion on the
DA layer, and <em>the rollup</em> gets builtin spam protection.</p>
<p>Unfortunately, this setup also gives sequencers a lot of power. Since the
sequencer handles transactions before they've gone through the DA layer's
consensus mechanism, he can re-order transactions - and potentially even halt
the rollup by refusing to publish new transactions.</p>
<p>To mitigate this power, we need to put a couple of safeguards in the protocol.</p>
<p>First, we allow anyone to register as a sequencer depositing tokens into the
sequencer registry. This is a significant departure from most existing rollups,
which rely on a single trusted sequencer.</p>
<p>Second, we allow sequencers to register <em>without sending a transaction through
an existing sequencer</em>. Specifically, we add a rule that the rollup will
consider up to <code>K</code> extra blobs from unregisterd sequencers in each rollup block.
If any of the first <code>K</code> "unregistered" blobs conform to a special format, then
the rollup will interpret them as requests to register a new sequencer. By
capping the number of unregistered blobs that we look at, we limit the
usefulness of unregistered blobs as a DOS vector while still ensuring that
honest sequencers can register relatively quickly in case of censorship.</p>
<p>Finally, we try to make sequencing competitive by distributing some of the fees
from each transaction to the sequencer who included it. This incentivizes new
sequencers to register if the quality of service is low.</p>
<hr />
<p>Ok, that was a lot of information. Let's recap.</p>
<p>In the Sovereign SDK, sequencers are middlemen who post transactions onto the DA
layer, but it's the DA layer which ultimately decides on the ordering of
transactions. Anyone can register as a sequencer, but sequencers expose
themselves to slashing if they include transactions with invalid signatures (or
certain other kinds of obvious spam).</p>
<p>That covers a huge chunk of sequencing. But there are still two topics we
haven't touched on: stateful validation, and soft confirmations.</p>
<h3 id="stateful-validation"><a class="header" href="#stateful-validation">Stateful Validation</a></h3>
<p>Up to this point, we've been talking about transactions as if they're always
either valid or invalid for all time, regardless of what's happening on the
rollup. But in the real world (especially when there are many sequencers),
that's not the case. To give just one example, it's entirely possible for an
account to burn through all of its funds with a single transaction, leaving
nothing to pay gas with the next time around. So, if two sequencers publish
blobs at about the same time, it's very possible that the first blob will cause
some tranasactions in the second one to become invalid.</p>
<p>This complicates our analysis. Previously, we assumed that a sequencer was
malicious if he caused any invalid transactions to be processed. That meant that
we could safely slash his deposit and move on whenever we encountered a
validation error. But now, we can't make that assumption. Otherwise, sequencers
would have to be extremely conservative about which transactions they included -
since a malicious (or confused) user could potentially cause a sequencer to get
slashed by sending conflicting transactions to two different sequencers at the
same time.</p>
<p>On the other hand, we don't want to let sequencers get away with including
transactions that they <em>know</em> are invalid. Otherwise, a malicious sequencer
could include invalid transactions "for free", causing the rollup to do a bunch
of wasted computation.</p>
<p>We address these issues by splitting transasction validation into two
categories. Stateless validation (i.e. signature checks) happens first, and
transactions which fail stateless validation are invalid <em>forever</em>. If a
sequencer includes a transaction which is statelessly invalid, then we know he's
malicious. After a transaction has passed stateless validation, we proceed to
make some stateful checks (i.e. checking that the transaction isn't a duplicate,
and that the account has enough funds to pay for gas). If these checks fail, we
charge the sequencer a small fee - just enough to cover the cost of the
validatoin.</p>
<p>This ensures that sequencers are incentivized to do their best to filter out
invalid transactions, and that the rollup never does any computation without
getting paid for it, without being unfairly punitive to sequencers.</p>
<h3 id="soft-confirmations"><a class="header" href="#soft-confirmations">Soft Confirmations</a></h3>
<p>Now that we've talked about the minimum requirements for sequencer, we move on
to soft-confirmations.</p>
<p>One of the biggest selling points of rollups today is the ability to tell users
the outcome of the tranaction instantly. Under the hood, this experience is
enabled by giving a single trusted sequencer a "lock" on the rollup state.
Because he holds the lock, the sequencer can run a local simulation to determine
the exact effect of a transaction <em>before</em> he posts it on the DA layer.</p>
<p>Unfortunately, this introduces a load bearing point of centralization. If the
centralized sequencer becomes unavailable (or is malicious), the rollup halts
and users have little recourse.</p>
<p>On existing rollups, this issue is somewhat mitigated by providing an "inbox" on
the DA layer where users can send special "forced withdrawal" transactions.
However, in most existing rollups these "forced" transactions are significantly
less powerful than ordinary ones. (Users are often limited to only withdrawing
funds) and the delay period before they are processed is long.</p>
<p>In the Sovereign SDK, we try to do better. Unfortunately, there's no way to
enable soft confirmations without giving some entity a lock on (some subset of)
the rollup state. So, this is exactly what we do. We allow rollup deployers to
specify some special "preferred sequencer", which has a partial lock on the
rollup state.</p>
<p>In order to protect users in case of a malicious sequencer, though, we make a
few additional changes to the rollup.</p>
<p>First, we separate the rollup state into two subsets, "user" space and "kernel"
space. The kernel state of the rollup is maintained programatically, and it
depends directly on the headers of the latest DA layer blocks. Inside of the
protected kernel state, the rollup maintains a list of all the blobs that have
appeared on the DA layer, and the block number in which they appeared.</p>
<p>Second, we prevent access to the kernel state of the rollup during transaction
execution. This prevents users from creating transactions that could
accidentally invalidate soft-confirmations given by the sequencer, as well as
preventing the sequencer from deleting forced transactions before they can be
processsed.</p>
<p>Finally, we add two new invariants:</p>
<ol>
<li>
<p>Every blob which appears on the (canonical) DA chain will be processed within
some fixed number of blocks</p>
</li>
<li>
<p>All "forced" (non-preferred) transactions will be processed in the order they
appeared on the DA layer</p>
</li>
</ol>
<p>To help enforce these invariants, we add a concept of a "visible" slot number.
The visible slot number is a nondecreasing integer which represents block number
that the preferred sequencer observed when he started building his current
bundle. Any "forced" blobs which appear on the DA layer are processed when the
visible slot number advances beyond the number of the <em>real</em> slot in which they
appeared.</p>
<p>Inside the rollup, we enforce that...</p>
<ul>
<li>
<p>The visible slot number never lags behind the real slot number by more than
some constant <code>K</code> slots</p>
<ul>
<li>This ensures that "forced" transactions are always processed in a reasonable
time frame</li>
</ul>
</li>
<li>
<p>The visible slot number increments by <em>at least</em> one every time the preferred
sequencer succesfully submits a blob. The sequencer may increment the virtual
slot by more than one, but the maximum increment is bounded by a small
constant (say, 10).</p>
</li>
<li>
<p>The visible slot number is never greater than the current (real) slot number</p>
</li>
<li>
<p>Transactions may only access information about the DA layer that was known at
the time of their <em>virtual</em> slot's creation. Otherwise, users could write
transactions whose outcome couldn't be predicted, making it impossible to give
out soft confirmations. - For example, a user could say
<code>if current_block_hash % 2 == 1 { do_something() }</code>, which has a different
outcome depending on exactly which block it gets included in. Since the rollup
sequencer is not the L1 block proposer, he doesn't know what block the
transaction will get included in! By limiting transactions to accessing
historical information, we avoid this issue.</p>
</li>
</ul>
<p>What all of this means in practice is that...</p>
<ul>
<li>The visible state never changes unless either the preferred sequencer submits
a batch, or a timeout occurs (i.e. the visible slot lags too far). This
ensures that the preferred sequencer always knows the exact state that he's
building on top of.</li>
<li>An honest sequencer wants to keep the virtual slot number as close to the real
slot number as possible. This way, he has more buffer to absorb downtime
without the state changing. This reduces the risk of soft-confirmations being
invalidated.</li>
<li>Honest sequencers can always give accurate soft confirmations, unless the DA
layer experiences a liveness failure lasting more than <code>K</code> slots.</li>
<li>Transactions can access information about the underlying blockchain with the
best latency that doesn't invalidate soft confirmations.</li>
</ul>
<h3 id="handling-preferred-sequencer-failure"><a class="header" href="#handling-preferred-sequencer-failure">Handling Preferred Sequencer Failure</a></h3>
<p>With the current design, the Sovereign SDK supports soft confirmations while
providing a reasonably powerful forced transaction mechanism. We also provide
some limited protection from a malicious sequencer. If the sequencer is
malicious, he can - at worst - delay transaction processing by some constant
number of blocks. He can't prevent forced transactions from being processed, and
he can't selectively delay transactions.</p>
<p>We also provide some limited protection if the preferred sequencer commits a
slashable offense. In this case, the rollup enters "recovery mode", where it
reverts to standard "based" sequencing (where all sequencer are equal). In this
mode, it advances the virtual slot number two-at-a-time until the rollup is
caught up, at which point the rollup behaves as if there had never been a
preferred sequencer.</p>
<p>In the future, we may also add slashing if the preferred sequencer gives
"soft-confirmations" which turn out to be invalid, but this requires some
additional design work.</p>
<h2 id="step-4-execution"><a class="header" href="#step-4-execution">Step 4: Execution</a></h2>
<p>Once a transaction is sequenced, the rollup needs to process it.</p>
<p>At a high level, a Sovereign SDK transaction goes through the following
sequence:</p>
<ol>
<li>
<p>(Stateless) Deserialization: Decoding the bytes of the transaction into
meaningful components (signature, ChainID, etc)</p>
</li>
<li>
<p>(Stateful) Pre-validation: Checking that the address which is claiming to
have authorized the transaction exists and retrieving its preferences for
authorization. For example, if the address is a multisig, fetch the set of
public keys and the minimum number of signatures.</p>
</li>
<li>
<p>(Usually Stateless) Authentication: Checking that the transaction is
authorized. For example, checking that the signatures are valid.</p>
</li>
<li>
<p>(Stateful) Authorization: Matching the results of the authentication and
pre-validation steps to decide whether to execute. This step also reserves
the funds to pay for gas used during transaction execution. --- State changes
up to this point are irreversable. State changes beyond this point are either
committed or reverted together</p>
</li>
<li>
<p>(Stateful) Pre-dispatch hook: This hook allows <em>all</em> modules to inspect the
transaction (and their own state) and do initialization before the
transaction is executed. For example, a wallet module might use this hook to
check the user's balance and store it for later retrieval. This hook may
abort the transaction and revert any state changes by returning an <code>Error</code>.</p>
</li>
<li>
<p>(Stateful) Execution: The transaction is dispatched to a <em>single</em> target
module for execution. That module may invoke other modules if necessary
during execution. If this call returns an error, all state changes from step
5 onward are reverted.</p>
</li>
<li>
<p>(Stateful) Post-dispatch hook: This hook allows <em>all</em> modules to inspect
their state and revert the transaction if necessary. If this call returns an
error, all state changes from step 5 onward are reverted.</p>
</li>
<li>
<p>(Stateful) Post-execution: After transaction execution, any unused gas is
refunded to the payer</p>
</li>
</ol>
<p>As described in the "Sequencing" documentation, sequencers are slashed if any of
the two stateless steps fail. If either of the stateful steps prior to execution
fail, the sequencer is penalized - but just enough to cover the cost of the work
that has been done. If the transaction fails during execution, the costs are
paid by the user (or whichever entity is sponsoring the gas cost of the
transaction.)</p>
<p>For more details on execution, see [TODO]</p>
<h2 id="step-5-proving"><a class="header" href="#step-5-proving">Step 5: Proving</a></h2>
<p>Once a transaction is executed, all of the rollup <em>full nodes</em> know the result
instantly. Light clients, on the other hand need proof. In this section, we'll
describe the different kinds of proof that the Sovereign SDK offers.</p>
<h3 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero-Knowledge Proofs</a></h3>
<p>The most powerful configuration for a rollup is zero-knowledge mode. In this
mode, light clients can trustlessly sync the chain with near-zero overhead and
only minutes of lag behind the chain tip. This enables fast and trustless
bridging between rollups, and between the rollup and the execution environment
of its DA layer (if applicable).</p>
<p>In the Sovereign SDK, proving is asynchronous (meaning that we post raw
<em>transactions</em> on the DA layer - so that full nodes can compute the rollup state
even before a proof is generated). This means that light clients have a view of
the state that lags a little bit behind full nodes.</p>
<h4 id="proof-statements"><a class="header" href="#proof-statements">Proof Statements</a></h4>
<p>All zero-knowledge proofs have the form, "I know of an input such that...". In
our case, the full statement is:</p>
<blockquote>
<p>I know of a DA layer block with hash X (where X is a public input to the
proof) and a rollup state root Y (where Y is another public input) such that
the rollup transitions to state Z (another public input) when you apply its
transaction processing rules.</p>
</blockquote>
<p>To check this proof, a client of the rollup needs to check that the input block
hash X corresponds to the next DA layer block, and that the input state root Y
corresponds to the current rollup state. If so, the client can advance its view
of the state from Y to Z.</p>
<p>This works great for a single block. But if a client needs to validate the
entire history of the rollup, checking proofs of each block would get expensive.
To alleviate this problem, we use recursive proofs to compress multiple block
proofs into one. (A nice property of zero-knowledge proofs is that the work to
verify a proof is roughly constant - so checking this recursive "aggregate"
proof is no more expensive than checking the proof of a single block.)</p>
<p>Each <code>AggregateProof</code> is a statement of the form:</p>
<blockquote>
<p>I know of a (previous) valid <code>AggregateProof</code> starting from <code>A</code> (the genesis
block hash, a public input) with state root <code>B</code> (the rollup's genesis state, a
public input) and ending at block hash <code>C</code> with state root <code>D</code>. And, I know of
a sequence of valid proofs such that...</p>
<ul>
<li>For each proof, the block header has the property that <code>header.prev_hash</code> is
the hash of the previous header</li>
<li>For each proof, the input state root is the output root of the previous
root.</li>
<li>The block header from the first proof has <code>prev_hash == C</code></li>
<li>The first proof has has input state root <code>D</code></li>
<li>The final proof in the chain has block hash <code>A</code> and output root <code>B</code> (where
<code>A</code> and <code>B</code> are public inputs)</li>
</ul>
</blockquote>
<h4 id="incentives"><a class="header" href="#incentives">Incentives</a></h4>
<p>Generating zero-knowledge proofs is expensive. So, if we want proofs to be
generated, we need to incentivize proof creation in protocol, preferrably using
the gas fees that users are already paying.</p>
<p>In a standard blockchain, the goal of transaction fees markets is to maximize
consumer surplus. They achieve this by allocating a scarce resource (blockspace)
to the people who value it most. Analysis shows that EIP-1559 is extremely good
at solving this optimization problem in the setting where supply is fixed and
demand varies rapidly. EIP-1559 adjusts the price of blockspace to the exact
price level at which demand matches supply.</p>
<p>In zk-rollups, we have a slightly different setup. Our supply of blockspace is
not constant. Instead, it's possible to invest more money in proving hardware in
order to increase the rollup's throughput. However, bringing more prover
capacity online takes time. Deals have to be negotiated, hardware provisioned,
etc. So, in the short term, we model prover capacity as being fixed - and we use
EIP-1559 to adjust demand to fit that target.</p>
<p>In the long run, we want to adjust the gas limit to reflect the actual capacity
of available provers. (Note that this is not yet fully implemented). To
facilitate this, we will track the rollup's gas usage and proving throughput
(measured in gas per second) over time. If rollup blocks are full and provers
are able to keep up, we will gradually increase the gas limit until blocks are
no longer full or provers start to fall behind.</p>
<p>This still leaves one problem... how do we incentivize provers to bring more
hardware online? After all, adding more hardware increases the gas limit, which
increases the supply of blockspace. This causes congestion (and fees) to fall,
increasing consumer surplus. But provers don't get paid in consumer surplus,
they get paid in fees. So, adding more hardware hurts <em>provers</em> in two ways. It
increases their costs, and it reduces the average fee level. This means that
provers are incentivized to provide as little capacity as possible.</p>
<p>The way we handle this problem is by introducing competition. In Sovereign, we
only reward the <em>first</em> prover to publish a valid proof of a block. Since
proving is almost perfectly parallel, and provers are racing to prove the block
first, a prover which adds slightly more capacity than its rivals experiences a
disproportionate increase in rewards. This should encourage provers to bring as
much capacity as possible.</p>
<p>Since we want to reward provers with funds on the rollup, we need consensus.
(Otherwise, it would be trivial to cause a chain split by creating a fork which
sent some rewards to a different prover.) So, we require provers to post their
proofs on chain. The first prover to post a valid proof of a particular block
gets rewarded with the majority of the <code>base_fee</code>s collected from that block.
This is a deviation from EIP-1559, where all base fees are burned. Intuitively,
our construction is still safe because provers "burn" money in electricity and
hardware costs in order to create proofs. However, we also burn a small
proportion of base fees as insurance in case proving costs ever fall to
negligble levels.</p>
<p>Once a prover has posted his proof on the DA layer, two things happen. First,
full nodes read the proof and, if it's valid reward the prover. If it's invalid,
the prover has his deposit slashed. (Just like a misbehaving sequencer. Also
like sequencers, data posted by un-bonded entities is ignored.) Second, light
clients of the rollup download and verify the proof, learning the state of the
rollup. As an implementation detail, we require proofs which get posted on chain
to be domain separated, so that light clients can download just the proofs from
a rollup without also needing to fetch all of the transaction data.</p>
<h4 id="summary-the-proving-workflow"><a class="header" href="#summary-the-proving-workflow">Summary: The proving workflow</a></h4>
<p>So, putting this all together, the proving workflow looks like this:</p>
<ol>
<li>
<p>A DA layer block is produced at height <code>N</code>. This block contains some rollup
transactions.</p>
</li>
<li>
<p>Full nodes immediately process the transactions and compute a new state.</p>
</li>
<li>
<p>Provers begin generating a proof of block <code>N</code>.</p>
</li>
<li>
<p>(About 15 minutes later) a prover creates a valid proof of block <code>N</code>. In the
meantime, DA layer blocks <code>N+1</code> through <code>N+X</code> have been produced.</p>
<p>a. At this point, full nodes are aware of rollup state <code>N+X</code>, while light
clients are still unaware of <code>N</code></p>
</li>
<li>
<p>The prover creates a new <code>AggregateProof</code>, which...</p>
<p>a. Proves the validity of the proof of block <code>N</code></p>
<p>b. Proves the validity of the previous <code>AggregateProof</code> (which covered the
rollup's history from genesis to block <code>N-1</code>)</p>
<p>c. Optionally proves the validity of proofs of blocks <code>N+1</code>, <code>N+2</code>, ...,
<code>N+X</code>, if such proofs are available. (Note that the <code>AggregateProof</code> must
cover a contiguous range of blocks starting from genesis, but it may cover
any number of blocks subject to that constraint.) For concreteness, suppose
that in this case the prover includes blocks <code>N+1</code> through <code>N+5</code>.</p>
</li>
<li>
<p>The prover posts the new <code>AggregateProof</code> onto the DA layer at some height -
call it <code>N+30</code>. At this point, full nodes are aware of state <code>N+30</code> (which
includes a reward for the prover), and light clients are aware of state
<code>N+5</code>. At some point in the future, a proof of <code>N+30</code> will be generated, at
which point light clients will become aware of the prover's reward.</p>
</li>
</ol>
<h3 id="optimistic-proofs"><a class="header" href="#optimistic-proofs">Optimistic Proofs</a></h3>
<p>For some rollups, generating a full zero-knowledge proof is too expensive. For
these applications, the Sovereign SDK offers Optimistic Mode, which allows
developers to trade some light-client latency for lower costs. With a zk-rollup,
light clients have a view of the state which lags behind by about 15 minutes
(the time it takes to generate a) zero- knowledge proof. However, at the end of
those 15 minutes, light clients know the state with cryptographic certainty.</p>
<p>In an optimistic rollup, light clients have a different experience. They get
some indication of the new rollup state very quickly (usually in the very next
block), but they need to wait much longer (usually about a day) to be sure that
their new view is correct. And, even in this case, clients only have
"cryptoeconomic" certainty about the new state.</p>
<h4 id="proving-setup"><a class="header" href="#proving-setup">Proving Setup</a></h4>
<p>In an optimistic rollup, the "proofs" checked by light clients are not (usually)
proofs at all. Instead, they are simple attestations. Attesters stake tokens on
claims like "the state of the rollup at height <code>N</code> is <code>X</code>", and anyone who
successfully challenges a claim gets to keep half of the staked tokens. (The
other half are burned to prevent an attester from lying about the state and then
challenging himself from another account and keeping his tokens). In exchange,
for their role in the process, attesters are rewarded with some portion of the
rollup's gas fees. This compensates attesters for the opportunity cost of
locking their capital.</p>
<p>This mechanism explains why light clients can know the state quickly with <em>some</em>
confidence right away, but they take time to reach full certainty. Once they've
seen an attestation to a state, clients know that either the state is correct,
or the attester is going to lose some amount of capital. As time goes by and no
one challenges the assertion, their confidence grows until it reaches (near)
certainty. (The point at which clients are certain about the outcome is usually
called the "finality period" or "finality delay".)</p>
<p>The previous generation of optimistic rollups (including Optimism and Arbitrum)
relies on running an on-chain bisection game over an execution trace to resolve
disputes about the rollup state. This requires $log_2(n)$ rounds of interaction,
where <code>n</code> is the length of the trace (i.e. a few hundred million). To handle the
possibility of congestion or censorship, rollups need to set the timeout period
of messages conservatively - which means that a dispute could take up to a week
to resolve.</p>
<p>In the Sovereign SDK, we resolve disputes by generating a zero-knowledge proof
of the outcome of the disputed block. Since this only requires one round of
interaction, we don't need the same challenge delay. However, we do need to
account for the fact that proving is a heavy process. Generating a proof might
take a few hours, and proving services might be experiencing congestion. To
minimize the risk, we plan to set the finality period conservatively at first
(about one day) and reduce it over time as we gain confidence.</p>
<p>Otherwise, the overall proving setup is quite similar to that of a zk-rollup.
Just as in zk-rollups, proofs (and attestations) are posted onto the DA layer so
that we have consensus about who to reward and who to slash. And, just like a
zk-rollup, optimistic proofs/attestations are posted into a separate "namespace"
on the DA layer (if possible) so that light clients can avoid downloading
transaction data. The only other significant distinction between optimistic and
zk rollups in Sovereign is that optimistic rollups use block-level proofs to
resolve disputes instead of generating aggregate proofs which go all the way to
genesis.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In the Sovereign SDK, we try to provide security, flexibility, and performance
<em>in that order</em>.</p>
<p>As a contributor, it's your job to maintain that hierarchy. Security must always
come first. And in blockchain, security is mostly about incentives. Especially
in blockchain, you get what you incentivize. If your rollup under-prices some
valuable resource, you'll get spam. If you under pay for some service, that
service won't be provided reliably.</p>
<p>This is why incentive management is so deeply baked into the SDK. Every step -
from sequencing to proving to execution to finality - needs to be carefully
orchestrated to keep the incentives of the participants in balance.</p>
<p>Once the setup is secure, our next priority is enabling the broadest set of use
cases. We try to provide maximum flexibility, and abstract as much functionality
as possible into reusable components. You can read more about how we achieve
flexibility at the level of Rust code in the <a href="./abstractions.html">abstractions</a>
chapter.</p>
<p>Finally, we optimize performance. This means eliminating redundant computation,
carefully managing state access patterns, and considering the strengths and
weaknesses of zero-knowledge proofs systems.</p>
<p>Happy hacking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="main-abstractions"><a class="header" href="#main-abstractions">Main Abstractions</a></h1>
<blockquote>
<p>This document provides an overview of the major abstractions offered by the
SDK.</p>
<ul>
<li>Rollup Interface (STF + DA service + DA verifier)</li>
<li>sov-modules (<code>Runtime</code>, <code>Module</code>, stf-blueprint w/ account abstraction,
state abstractions)</li>
<li>sov-sequencer</li>
<li>sov-db</li>
<li>Rockbound</li>
</ul>
</blockquote>
<p>One of the most important principles in the Sovereign SDK is modularity. We
believe strongly in separating rollups into their component parts and
communicating through abstract interfaces. This allows us to iterate more
quickly (since components are unaware of the implementation details of other
components), and it also allows us to reuse components in contexts which are
often quite different from the ones in which they were orginally designed.</p>
<p>In this chapter, we'll give a brief overview of the core abstractions of the
Sovereign SDK</p>
<h2 id="native-vs-zk-execution"><a class="header" href="#native-vs-zk-execution">Native vs. ZK Execution</a></h2>
<p>Perhaps the most fundamental abstraction in Sovereign is the separation between
<code>"native"</code> code execution (which computes a new rollup state) and zero-knowledge
<em>verification</em> of that state. Native execution is the experience you're used to.
In native execution, you have full access to networking, disk, etc. In native
mode, you typically trust data that you read from your own database, but not
data that comes over the network.</p>
<p>Zero-knowledge execution looks similar. You write normal-looking Rust code to do
CPU and memory operations - but under the hood, the environment is alien. In
zero-knowledge execution, disk and network operations are impossible. Instead,
all input is received from the (untrusted) machine generating the proof via a
special syscall. So if you make a call that looks like a network access, you
might not get a response from <code>google.com</code>. Instead, the prover will pick some
arbitrary bytes to give back to you. The bytes might correspond to an actual
response (i.e. if the prover is honest and made the network request for you) -
but they might also be specially crafted to deceive you. So, in zero-knowledge
mode, great care must be taken to avoid relying on unverified data from the
prover.</p>
<p>In the Sovereign SDK, we try to share code between the <code>"native"</code> full node
implementation and the zero-knowledge environment to the greatest extent
possible. This minimizes surface area for bugs. However, a full node necessarily
needs a lot of logic which is unnecessary (and undesirable) to execute in
zero-knowledge. In the SDK, such code is gated behind a <code>cargo</code> feature called
<code>"native"</code>. This code includes RPC implementations, as well as logic to
pre-process some data into formats which are easier for the zero-knowledge code
to verify.</p>
<h2 id="the-rollup-interface"><a class="header" href="#the-rollup-interface">The Rollup Interface</a></h2>
<p>If you squint hard enough, a zk-rollup is made of three separate components.
There's an underlying blockchain ("Data Availability layer"), a set of
transaction execution rules ("a State Transition Function") and a zero-knowledge
proof system (a "ZKVM" for zero-knowledge virtual machine). In the abstract, it
seems like it should be possible to take the same transaction processing logic
(i.e. the EVM) and deploy it on top of many different DA layers. Similarly, you
<em>should</em> be able to take the same execution logic and compile it down to several
different proof systems - in the same way that you can take the same code an run
it on Risc0 or SP1.</p>
<p>Unfortunately, separating these components can be tricky in practice. For
example, the OP Stack relies on an Ethereum smart contract to enforce its
censorship resistance guarantees - so, you can't easily take an OP stack rollup
and deploy it on a non-EVM chain.</p>
<p>In the Sovereign SDK, flexibility is a primary design goal. So we take care to
codify this separation of concerns into the framework from the very beginning.
With Sovereign, it's possible to run any <code>State Transition Function</code> alongside
any <code>Da Service</code> on top of any (rust-compatible) proof system and get a
functional rollup. The <code>rollup-interface</code> crate is what makes this possible.
Every other crate in the SDK depends on it, because it defines the core
abstractions that are shared between all SDK rollups.</p>
<p><img src="../assets/dependency-graph.png" alt="A digram showing how the rollup interface supports the entire Sovereign SDK" /></p>
<p>Inside of the rollup interface, the <code>native</code> vs zero-knowledge distinction
appears in numerous places. For example, the <code>DA layer</code> abstraction has two
components - a <code>DaService</code>, which runs as part of <code>native</code> full node execution
and provides methods for fetching data from the underlying blockchain; and
<code>DaVerifier</code>, which runs in zero-knowledge and verifies that the data being
executed matches the provided DA block header.</p>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it Works</a></h3>
<p>Essentially, the Sovereign SDK is just a generic function that does this:</p>
<pre><code class="language-rust">fn run_rollup&lt;Da: DaService, Zk: Zkvm, Stf: StateTransitionFunction&gt;(self, da: Da, zkvm: Zk, business_logic: Stf) {
	loop {
		// Run some `native` code to get the data for execution
		let (block_data, block_header) = da.get_next_block();
		let (input_state, input_state_root) = self.db.get_state();
		// Run some zero-knowledge code to execute the block
		let proof = zkvm.prove(|| {
			// Check that the inputs match the provided commitments
			if !da.verify(block_data, block_header) || !input_state.verify(input_state_root) {
				panic!()
			};
			// Make the data commitments part of the public proof
			output!(block_header.hash(), input_state_root)
			let output_state_root = business_logic.run(block_data, input_state);
			// Add the output root to the public proof
			output!(output_state_root)
		});
		// Publish the proof onto the DA layer
		da.publish(proof);
	}
}</code></pre>
<p>As you can see, most of the heavy lifting is done by the DA layer, the <code>Zkvm</code>
and the rollup's business logic. The full node implementation is basically just
glue holding these components together.</p>
<h3 id="da"><a class="header" href="#da">DA</a></h3>
<p>As discussed above, the role of the DA layer is to order and publish data. To
integrate with the Sovereign SDK, a DA layer needs to provide implementations of
two core traits: <code>DaService</code> and <code>DaVerifier</code>.</p>
<h4 id="da-service"><a class="header" href="#da-service">DA Service</a></h4>
<p>The <code>DaService</code> trait is usually just a thin wrapper around a DA layer's
standard RPC client. This trait provides standardized methods for fetching data,
generating merkle proofs, and publishing data. Because it interacts with the
network, correct execution of this trait is <em>not</em> provable in zero-knowledge.</p>
<p>Instead, the work of verifying of the data provided by the <code>DaService</code> is
offloaded to the <code>DaVerifier</code> trait. Since the <code>DaService</code> runs only in <code>native</code>
code, its implementation is less concerned about efficiency than zero-knowledge
code. It's also easier to patch, since updating the <code>DaService</code> does <em>not</em>
require any light clients or bridges to update.</p>
<p>The <code>DaService</code> is the only component of the SDK responsible for publishing and
fetching data. The SDK's node does not currently have a peer-to-peer network of
its own. This dramatically simplifies the full node and reduces bandwidth
requirements.</p>
<h3 id="da-verifier"><a class="header" href="#da-verifier">DA Verifier</a></h3>
<p>The <code>DaVerifier</code> is the zero-knowledge-provable counterpart of the <code>DaService</code>.
It is responsible for checking that the (untrusted) private inputs to a proof
match the public commitment <em>as efficiently as possible</em>. It's common for the
<code>DaVerifier</code> to offload some work to the <code>DaService</code> (i.e. as computing extra
metadata) in order to reduce the amount of computation required by the
<code>DaVerifier</code>.</p>
<p>At the level of <code>Rust</code> code, we encode the relationship between the <code>DaVerifier</code>
and the <code>DaService</code> using a helper trait called <code>DaSpec</code> - which specifies the
types on which both interfaces operate.</p>
<h4 id="zero-knowledge-virtual-machine-zkvm"><a class="header" href="#zero-knowledge-virtual-machine-zkvm">Zero Knowledge Virtual Machine ("<code>Zkvm</code>")</a></h4>
<p>The <code>Zkvm</code> traits make a zk-snark system (like <code>Risc0</code> or <code>Sp1</code>) compatible with
the Sovereign SDK. Like the <code>DA layer</code>, we separate <code>Zkvm</code> traits into a
<code>native</code> and zk version, plus a shared helper.</p>
<p>The <code>ZkvmHost</code> trait describes how a <code>native</code> computer executes an <code>elf</code> file
(generated from <code>Rust</code> code) and generates a zero-knowledge proof. It also
describes how the <code>native</code> machine passes private inputs (the "witness") into
the execution.</p>
<p>The <code>ZkvmGuest</code> trait describes how a program running in zero-knowledge mode
accepts inputs from the host machine.</p>
<p>Finally, the <code>ZkVerifier</code> trait describes how a proof generated by the host is
verified. This trait is implemented by both the <code>Host</code> and the <code>Guest</code>, which is
how we represent that proofs must be verifiable <code>native</code>ly and recursively (i.e.
inside another SNARK.)</p>
<h4 id="state-transition"><a class="header" href="#state-transition">State Transition</a></h4>
<p>A <code>StateTransitionFunction</code> ("STF") is a trait which describes:</p>
<ol>
<li>
<p>How to initialize a rollup's state at genesis</p>
</li>
<li>
<p>How to apply the data from the DA layer to generate a new state</p>
</li>
</ol>
<p>In other words, the implementation of <code>StateTransitionFunction</code> is what defines
the rollup's "business logic".</p>
<p>In the Sovereign SDK, we define a generic full node which can run any STF. As
long as your logic implements the interface, we should be able to run it.</p>
<p>However, implementing the business logic of a rollup is <em>extremely</em> complicated.
While it's relatively easy to roll your own implementation of the <code>Da</code> or <code>Zkvm</code>
traits, building a secure STF from scratch is a massive undertaking. It's so
complex, in fact, that we assume no one will ever do it - andthe vast majority
of the Sovereign SDK's code is devoted to providing a generic implementation of
an STF that developers can customize. (This STF is what we call the Sovereign
module system, or sov-modules).</p>
<p>So if no one is ever going to implement the <code>StateTransitionFunction</code> interface,
why bother maintaining it at all? One reason is for flexibility. Just because we
don't expect anyone to roll their own STF doesn't mean that they won't. But a
bigger motivation is to keep concerns separate. By hiding the implementation
details of the rollup behind the STF interface, we build a firm abstraction
barrier between it and the full node. This means that we're free to make
breaking changes on either side of the wall (either in the node, or in the STF)
without worrying about breaking the other component.</p>
<h2 id="sov-modules"><a class="header" href="#sov-modules">Sov Modules</a></h2>
<p>Outside of the rollup interface, the most important abstraction is
<code>sov-modules</code>. <code>sov-modules</code> is a pre-built STF with pluggable... modules. It
does the heavy lifting of implementing a secure STF so that you can focus on the
core logic of your application.</p>
<h3 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h3>
<p>At the heart of any sov-modules rollup is the <code>Runtime</code>:</p>
<pre><code class="language-rust">// An example runtime similar to the one used in our "standard" demo rollup
pub struct Runtime&lt;S: Spec&gt; {
    /// The Bank module implements fungible tokens, which are needed to charge `gas`
    pub bank: sov_bank::Bank&lt;S&gt;,
    /// The Sequencer Registry module is where we track which addresses can send batches to the rollup
    pub sequencer_registry: sov_sequencer_registry::SequencerRegistry&lt;S&gt;,
    /// The Prover Incentives module is where we reward provers who do useful work
    pub prover_incentives: sov_prover_incentives::ProverIncentives&lt;S&gt;,
    /// The Accounts module implements identities on the rollup. All of the other modules rely on it
	/// to link cryptographic keys to logical accounts
    pub accounts: sov_accounts::Accounts&lt;S&gt;,
	/// The NFT module provides an implementation of a non-fungible token standard. It's totally optional.
    pub nft: sov_nft_module::NonFungibleToken&lt;S&gt;,
    #[cfg_attr(feature = "native", cli_skip)]
    /// The EVM module lets the rollup run Ethereum smart contracts. It's totally optional.
    pub evm: sov_evm::Evm&lt;S, Da&gt;,
}</code></pre>
<p>At the highest level, a runtime is "just" a collection of all the modules which
are included in your rollup. Its job is to take <code>Transaction</code>s and dispatch them
to the appropriate module for execution.</p>
<p>Pretty much all rollups built with the <code>sov-modules</code> include the bank, the
sequencer registry, and the accounts module in their <code>Runtime</code>. They also
usually include one of <code>sov_prover_incentives</code> (if they're a zk-rollup) or
<code>sov_attester_incentives</code> (if they're an Optimistic rollup).</p>
<p>You may also have noticed that the <code>Runtime</code> is generic over a <code>Spec</code>. This
<code>Spec</code> describe the core types (addresses, hashers, cryptography) used by the
rollup and the DA layer. Making your runtime generic over a Spec means that you
can easily change DA layers, or swap any of the core primitives of your rollup.
For example, a rollup can trivially switch from Ed25519 to secp256k1 for its
signature scheme by changing the implementation of its <code>Spec</code> trait.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>"Modules" are the things that process transactions. For example, the <code>Bank</code>
module lets users transfer tokens to each other. And the <code>EVM</code> module implements
a full Ethereum Virtual Machine that can process any valid Ethereum transaction.</p>
<p>A <code>Module</code> is just a rust <code>struct</code> that implements two traits called <code>Module</code>
and <code>ModuleInfo</code>.</p>
<h4 id="the-module-trait-1"><a class="header" href="#the-module-trait-1">The <code>Module</code> trait</a></h4>
<p>The <code>Module</code> trait is like a simplified version of the
<code>StateTransitionFunction</code>. It describes how to initialize the module at the
rollup's genesis, and how the module processes <code>CallMessage</code>s received from
users (i.e. how it processes transactions)</p>
<pre><code class="language-rust">pub trait Module {
	// -- Some associated type definitions are omitted here --
	/// Module defined argument to the call method.
    type CallMessage: Debug;

    /// Genesis is called when a rollup is deployed and can be used to set initial state values in the module.
    fn genesis(
        &amp;self,
        _config: &amp;Self::Config,
        _working_set: &amp;mut WorkingSet&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;

    /// Processes a transaction, updating the rollup state.
    fn call(&amp;self,
        _message: Self::CallMessage,
        _context: &amp;Context&lt;Self::Spec&gt;,
        _state: &amp;mut impl TxState&lt;S&gt;,
    ) -&gt; Result&lt;CallResponse, ModuleError&gt;;
}</code></pre>
<p>You'll notice that the <code>call</code> function takes three arguments: an associated
<code>CallMessage</code> type, a <code>Context</code>, and a <code>WorkingSet</code>.</p>
<ul>
<li>
<p>The <code>CallMessage</code> type is the deserialized content of the user's transaction -
and the module can pick any type to be its <code>CallMessage</code>. In most cases,
modules use an <code>enum</code> with one variant for each action a user might want to
take. For example, the <code>Bank::CallMessage</code> type has variants for minting,
transferring, and burning tokens.</p>
</li>
<li>
<p>The <code>Context</code> type is relatively straightforward. It simply contains the
address of the sequencer, who published the transaction, the identity of the
transaction's signer, and the current block height.</p>
</li>
<li>
<p>The <code>TxState</code> is the most interesting of the three, but it needs a little bit
of explanation. In the Sovereign SDK, the rust <code>struct</code> which implements a
<code>Module</code> doesn't actually contain any state. Rather than holding actual
values, the module simply defines the <em>structure</em> of some items in state. All
of the actual state of the rollup is stored in the <code>State</code> object, which is
in-memory layer on top of the rollup's database (in native mode) or merkle
tree (in zk mode). The <code>State</code> abstraction handles commit/revert semantics for
you, as well as taking responsibility for caching, deduplication, and
automatic witness generation/checking. It also provides utilities for charging
<code>gas</code> and emitting <code>event</code>s.</p>
</li>
</ul>
<p>The <code>Accounts</code> module provides a good example of a standard <code>Module</code> trait
implementation.</p>
<pre><code class="language-rust">pub enum CallMessage&lt;S: Spec&gt; {
    /// Updates a public key for the corresponding Account.
    /// The sender must be in possession of the new key.
    UpdatePublicKey(
        /// The new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::PublicKey,
        /// A valid signature from the new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::Signature,
    ),
}

impl&lt;S: Spec&gt; sov_modules_api::Module for Accounts&lt;S&gt; {
	// -- Some items ommitted here --
    fn call(
        &amp;self,
        msg: Self::CallMessage,
        context: &amp;Context&lt;S&gt;,
        working_set: &amp;mut WorkingSet&lt;S&gt;,
    ) -&gt; Result&lt;sov_modules_api::CallResponse, Error&gt; {
        match msg {
            call::CallMessage::UpdatePublicKey(new_pub_key, sig) =&gt; {
				// Find the account of the sender
				let pub_key = self.public_keys.get(context.sender(), working_set)?;
				let account = self.accounts.get(&amp;pub_key, working_set);
				// Update the public key
				self.accounts.set(&amp;new_pub_key, &amp;account, working_set);
				self.public_keys
					.set(context.sender(), &amp;new_pub_key, working_set);
				Ok(Default::default())
            }
        }
    }
}</code></pre>
<h4 id="the-moduleinfo-trait"><a class="header" href="#the-moduleinfo-trait">The <code>ModuleInfo</code> trait</a></h4>
<p>The <code>ModuleInfo</code> trait describes how the module interacts with the broader
module <em>system</em>. Each module has a unique ID and stores its state under a unique
<code>prefix</code> of the global key-value store provided by <code>sov-modules</code></p>
<pre><code class="language-rust">pub trait ModuleInfo {
    /// Returns id of the module.
    fn id(&amp;self) -&gt; &amp;ModuleId;

    /// Returns the prefix where module state is stored.
    fn prefix(&amp;self) -&gt; ModulePrefix;

    /// Returns addresses of all the other modules this module is dependent on
    fn dependencies(&amp;self) -&gt; Vec&lt;&amp;ModuleId&gt;;
}</code></pre>
<p>Unlike the <code>Module</code> trait, its incredibly rare for developers to implement
<code>ModuleInfo</code> by hand. Instead, it's strongly recommended to derive the
<code>ModuleInfo</code> using our handy macro. A typical usage looks like this:</p>
<pre><code class="language-rust">#[derive(ModuleInfo, Clone)]
pub struct Bank&lt;S: sov_modules_api::Spec&gt; {
    /// The id of the sov-bank module.
    #[id]
    pub(crate) id: ModuleId,

    /// The gas configuration of the sov-bank module.
    #[gas]
    pub(crate) gas: BankGasConfig&lt;S::Gas&gt;,

    /// A mapping of [`TokenId`]s to tokens in the sov-bank.
    #[state]
    pub(crate) tokens: sov_modules_api::StateMap&lt;TokenId, Token&lt;S&gt;&gt;,
}</code></pre>
<p>This code automatically generates a unique ID for the bank module and stores it
in the field of the module called <code>id</code>. It also initializes the <code>StateMap</code>
"<code>tokens</code>" so that any keys stored in the map will be prefixed the with module's
<code>prefix</code>. This prevents collisions in case a different module also declares a
<code>StateMap</code> where the keys are <code>TokenId</code>s.</p>
<h3 id="module-state"><a class="header" href="#module-state">Module State</a></h3>
<p>The Sovereign SDK provides three core abstractions for managing module state. A
<code>StateMap&lt;K, V&gt;</code> maps arbitrary keys of type <code>K</code> to arbitrary values of type
<code>V</code>. A <code>StateValue&lt;V&gt;</code> stores a value of type <code>V</code>. And a <code>StateVec&lt;V&gt;</code> store an
arbitrary length vector of type <code>V</code>. All three types require their arguments to
be serializable, since the values are stored in a merkle tree under the hood.</p>
<p>All three abstractions support changing the underlying encoding scheme but
default to <code>Borsh</code> if no alternative is specified. To override the default,
simply add an extra type parameter which implements the <code>StateCodec</code> trait. (i.e
you might write <code>StateValue&lt;Da::BlockHeader, BcsCodec&gt;</code> to use the <code>Bcs</code>
serialization scheme for block headers, since your library for DA layer types
might only support serde-compatible serializers).</p>
<p>All state values are accessed through <code>TxState</code>. For example, you always write
<code>my_state_value.get(&amp;mut state)</code> to fetch a value. It's also important to
remember that modifying a value that you read from state doesn't have any effect
unless you call <code>my_value.set(new, &amp;mut working_set)</code>.</p>
<h4 id="merkle-tree-layout"><a class="header" href="#merkle-tree-layout">Merkle Tree Layout</a></h4>
<p><code>sov-modules</code> currently uses a generic
<a href="https://github.com/penumbra-zone/jmt">Jellyfish Merkle Tree</a> for its
authenticated key-value store. (Generic because it can be configured to use any
32-byte hash function). In the near future, this JMT will be replaced with the
<a href="https://sovereign.mirror.xyz/jfx_cJ_15saejG9ZuQWjnGnG-NfahbazQH98i1J3NN8">Nearly Optimal Merkle Tree</a>
that is currently under development.</p>
<p>In the current implementation, the SDK implements storage by generating a unique
(human-readable) key for each <code>StateValue</code>, using the hash of that key as a path
in the merkle tree. For <code>StateMap</code>s, the serialization of the key is appended to
that path. And for <code>StateVec</code>s, the index of the value is appended to the path.</p>
<p>For example, consider the following module:</p>
<pre><code class="language-rust">// Suppose we're in the file my_crate/lib.rs
#[derive(ModuleInfo, Clone)]
pub struct Example&lt;S: sov_modules_api::Spec&gt; {
    #[id]
    pub(crate) id: ModuleId,
    #[state]
    pub(crate) some_value: sov_modules_api::StateValue&lt;u8&gt;,
    #[state]
    pub(crate) some_vec: sov_modules_api::StateVec&lt;u64&gt;,
    #[state]
    pub(crate) some_map: sov_modules_api::StateMap&lt;String, String&gt;,
}</code></pre>
<p>The value of <code>some_value</code> would be stored at the path
<code>hash(b"my_crate/Example/some_value")</code>. The value of the key "hello" in
<code>some_map</code> would be stored at <code>hash(b"my_crate/Example/some_map/⍰hello")</code> (where
<code>⍰hello</code> represents the borsh encoding of the string "hello") etc.</p>
<p>However, this layout may change in future to provide better locality. For more
details... ask Preston, I guess.</p>
<h4 id="exotic-state-variants"><a class="header" href="#exotic-state-variants">Exotic State Variants</a></h4>
<p>In addition to the standard state store, we support two other kinds of state:</p>
<p><code>KernelStateValue</code>s or (maps/vecs) act identically to regular <code>StateValues</code>, but
they're stored in a separate merkle tree which is more tightly access
controlled. This mechanism allows the rollup to store data that is inaccessible
during transaction execution, which is necessary to enable soft-confirmations
without sacrificing censorship resistance. For more details, see the section on
soft-confirmations in the <a href="./transaction-lifecycle.html">transaction lifecycle</a>
documentation. The global "state root" returned by the <code>sov-modules</code> from the
<code>StateTransitionFunction</code> implementation is the hash of the kernel state root
with the regular state root. We do our best to hide this detail from users of
the SDK, though. Merkle proofs are automatically generated against the global
root, so users don't need to worry about which state trie there values are in.</p>
<p><code>AccessoryStateValue</code> or (map/vec) types are similar to <code>Kernel</code> types except
that their values are not <em>readable</em> from inside the state transition function
at all. Under the hood, these value are stored in the rollup's database <em>but not
in either merkle tree</em>. This is useful for creating data that will be served via
RPC but never accessed again during execution - for example, the transaction
receipts from an Ethereum block.</p>
<h3 id="the-stf-blueprint"><a class="header" href="#the-stf-blueprint">The STF Blueprint</a></h3>
<p>The last key component of a <code>sov-modules</code> rollup is the <code>stf-blueprint</code>. This
"blueprint" provides a generic implementation of a <code>StateTransitionFunction</code> in
terms of a <code>Runtime</code> (described above) and a <code>Kernel</code> (which provides
security-critical functionality like censorship resistance in a way that's
isolated from the transaction execution logic).</p>
<p>The STF blueprint implements the following high-level workflow:</p>
<ol>
<li>Take all of the new data <code>Blob</code>s read from the DA layer and send them to the
<code>Kernel</code>. The <code>Kernel</code> will return a list of deserialized <code>Batch</code>es of
transactions as well as the current <code>gas</code> price. (A "<code>Batch</code>" is a "<code>Blob</code>"
sent by a registered sequencer that has been succesfully deserialized into a
list of <code>Transaction</code>s)</li>
</ol>
<ul>
<li>Note that the list of <code>Batch</code>es returned by the <code>Kernel</code> does <em>not</em>
necessarily correspond exactly to the incoming <code>Blob</code>s. The <code>Kernel</code> might
decide to ignore some Blobs, or to store some in its internal state for
"deferred" execution. It might also add some <code>Batch</code>es saved from a previous
slot.</li>
</ul>
<ol start="2">
<li>
<p>Run the <code>begin_slot</code> hook, allowing modules to execute any initialization
logic</p>
</li>
<li>
<p>For each batch initialize the sequencer reward to zero and run the
<code>begin_batch</code> hook. Apply the transactions, rewarding or penalizing the
sequencer as appropriate. Finally, run the <code>end_batch</code> hook</p>
</li>
<li>
<p>Run the <code>end_slot</code> hook to allow modules to execute any final logic.</p>
</li>
<li>
<p>Compute the state change set and state root based on the transactions that
were executed.</p>
</li>
<li>
<p>Execute the <code>finalize</code> hook, which allows modules to compute any summary
information from the change set and make it available via RPC.</p>
</li>
</ol>
<p>For more details on the process of applying individual transactions, see the
<a href="./transaction-lifecycle.html">transaction lifecycle</a> document.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequencer-registration-via-forced-inclusion"><a class="header" href="#sequencer-registration-via-forced-inclusion">Sequencer Registration via Forced Inclusion</a></h1>
<p>Forced inclusion is a strategic mechanism in rollups designed to circumvent
sequencers that censor user transactions. It allows users to directly submit
transaction batches to the <a href="./da-layer.html">Data Availability Layer</a> instead of
going through a sequencer.</p>
<p>The Sovereign SDK supports this feature under specific conditions and
guidelines. Crucially, only "Register Sequencer" transactions are accepted for
forced inclusion; all other types will be ignored. For more details, see the
<a href="7-3-forced-sequencer-registration.html#rules">Rules</a> section.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The Sovereign SDK limits the number of batches from unregistered sequencers
processed per rollup slot. This measure limits the use of this mechanism as a
denial-of-service (DOS) attack vector.</p>
<h3 id="process-for-forced-registration"><a class="header" href="#process-for-forced-registration">Process for Forced Registration</a></h3>
<ol>
<li>Create a batch containing a valid "Register Sequencer" transaction.</li>
<li>Submit the batch to the Data Availability layer.</li>
<li>Rollup nodes collect and execute the transaction.</li>
<li>If the transaction complies with all rules, the user is registered as a
sequencer and can submit regular transaction batches.</li>
</ol>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<p>To ensure forced inclusion requests are processed correctly, the following rules
apply:</p>
<ul>
<li><strong>Transaction Limit</strong>: Only the first transaction in each batch is taken into
account. Any additional transactions will be discarded.</li>
<li><strong>Transaction Type</strong>: The transaction must be a "Register Sequencer"
transaction.</li>
<li><strong>Transaction Construction</strong>: The transaction must be properly formatted and
comply with standard transaction rules.</li>
<li><strong>Financial Requirements</strong>: Users must have enough funds to cover:
<ul>
<li>Pre-execution checks (including signature validation, deserialization and
transaction type checks).</li>
<li>Transaction execution costs.</li>
<li>A bond required for sequencer registration.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-specification"><a class="header" href="#gas-specification">Gas Specification</a></h1>
<p>This document contains a detailed specification of the way gas is handled within
Sovereign's SDK. We use <code>&lt;., .&gt;</code> to denote the scalar product of two
multidimensional quantities.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Gas is an ubiquitous concept in the blockchain space. It is a measure of the
computational effort required to perform an operation as part of a transaction
execution context. This is used to prevent the network from getting spammed by
regulating the use of computational resources by each participant in the
network.</p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High level overview</a></h2>
<p>We have drawn a lot of inspiration from the
<a href="https://ethereum.org/en/developers/docs/gas/">Ethereum gas model</a> in our gas
mechanism design. Given that Ethereum's gas is well understood and widely used
in the crypto industry, we believe that this will help users onboard more easily
while providing strong security guarantees out-of-the box. We have deliberately
chosen to tweak some concepts that were ill-suited to the rollups built using
Sovereing's SDK. In particular, sorted decreasing order of importance:</p>
<ul>
<li>We are using multidimensional gas units and prices.</li>
<li>We plan to using a dynamic gas target. Otherwise, the rollups built with
Sovereign's SDK follow the <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>
specification by default.</li>
<li>Rollup transactions specify a <code>max_fee</code>, <code>max_priority_fee_bips</code>, and
<em>optional gas limit</em> <code>gas_limit</code>. The semantics of these quantities roughtly
match their definition in the
<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559 specification</a>.</li>
<li>Transaction rewards are decomposed into <code>base_fee</code> and <code>priority_fee</code>. The
<code>base_fee</code> <em>is only partially burnt by default</em>, the remaining amount is used
<em>to reward provers/attesters</em>. The <code>priority_fee</code> is used to reward the <em>block
sequencers</em>.</li>
<li>We are charging gas for every storage access within the module system by
default.</li>
<li>Customers of the SDK will have access to wrappers that allow to charge gas for
hash computation and signature checks.</li>
</ul>
<h2 id="a-design-for-multidimensional-gas"><a class="header" href="#a-design-for-multidimensional-gas">A design for multidimensional gas</a></h2>
<p>Sovereign SDK's rollups use multidimensional gas units and prices. For example,
this allows developers to take into account the differences between native and
zero-knowledge computational costs for the same operation. Indeed:</p>
<ul>
<li>Hashing is orders of magnitude more expensive when performed inside a
zero-knowledge circuit. The cost of proving the correct computation of two
different Hash may also vary much more than the cost of computing the hash
itself (<code>Poseidon</code> or <code>MiMc</code> vs <code>Sha2</code>).</li>
<li>Accessing a storage cell for the first time is much more expensive in <code>zk</code>
mode than in <code>native</code> mode. But <em>hot</em> storage accesses are practically free in
zero-knowledge.</li>
</ul>
<p>In the Sovereign SDK, we currently meter consumption in two dimensions - compute
and memory.</p>
<p>We have chosen to follow the
<a href="https://ethresear.ch/t/multidimensional-eip-1559/11651">multi-dimensional EIP-1559</a>
design for the gas pricing adjustment formulas. In essence:</p>
<ul>
<li>We are performing the gas price updates for each dimension separately. In
other words, each dimension follows a separate uni-dimensional EIP-1559 gas
price adjustment formula.</li>
<li>The gas price adjustment formula uses a <code>gas_target</code> reference, which is a
uni-dimensional gas unit that is compared to the gas consumed <code>gas_used</code>. The
<code>gas_price</code> is then adjusted to regulate the gas throughtput to get as close
as possible to the <code>gas_target</code>. We have the following invariant:
<code>0 &lt;= gas_used_slot &lt;= 2 * gas_target</code>.</li>
<li><em>Contrarily to Ethereum</em>, we are planning to design a dynamic <code>gas_target</code>.
The value of the <code>gas_target</code> will vary slowly to follow the evolution of the
rollup metrics we have described above. That way, Sovereign rollups can
account for major technological improvements in computation (such as zk-proof
generation throughtput), or storage cost.</li>
<li>Every transaction has to specify a scalar <code>max_fee</code> which is the maximum
amount of <em>gas tokens</em> that can be used to execute a given transaction.
Similarly, users have to specify a <code>max_priority_fee_per_gas</code> expressed in
basis points which can be used to reward the transaction sequencer.</li>
<li>The final sequencer reward is:
<code>seq_reward = min(max_fee - &lt;base_fee, gas_price&gt;, max_priority_fee_per_gas * &lt;base_fee, gas_price&gt;)</code>.</li>
<li>Users can provide an optional <code>gas_limit</code> field which is a maximum amount of
gas to be used for the transaction. This quantity is converted to a
uni-dimensional <code>remaining_funds</code> quantity by taking the scalar product with
the current <code>gas_price</code>.</li>
<li>If users provide the <code>gas_limit</code>, the rollup checks that
<code>&lt;gas_limit, current_gas_price&gt; &lt;= max_fee</code> (ie, the scalar product with the
current <code>gas_price</code>). If the check fails, the associated transaction is not
executed and the rollup raises a
<code>ReserveGasErrorReason::CurrentGasPriceTooHigh</code> error.</li>
</ul>
<h2 id="charging-gas-for-state-accesses"><a class="header" href="#charging-gas-for-state-accesses">Charging gas for state accesses.</a></h2>
<p>State accessors such as the <code>WorkingSet</code> or the <code>PreExecWorkingSet</code> charge some
gas whenever state is modified. If these accessors run out of gas, they return a
<code>StateAccessorError</code> and the execution gets reverted (or the sequencer is
penalized). Some state accessors - like <code>StateCheckpoint</code>, the <code>TxScratchpad</code> or
the <code>ApiStateAccessor</code> - don't charge for gas for state accesses. In that case,
the access methods return a <code>Result&lt;T, Infallible&gt;</code> type which can be unwrapped
safely using <code>unwrap_infallible</code>.</p>
<p>For now, we are enforcing simple cached access patterns - we are refunding some
gas if the value that is accessed/modified is <em>hot</em> (ie has been already
accessed and is cached).</p>
<h2 id="gas-rewards"><a class="header" href="#gas-rewards">Gas rewards.</a></h2>
<p>The gas consumed during transaction execution is used to reward both
provers/attesters and block sequencers. The <code>base_fee</code>, ie the total amount of
gas consumed by the transaction execution is partially burnt (the amount to burn
is specified by the <code>PERCENT_BASE_FEE_TO_BURN</code> constant), and the remaining
portion is locked in a reward pool to be redeemed by provers/attesters. The
<code>priority_fee</code> is also partially burnt and used to reward block sequencers.</p>
<h2 id="additional-data-structures-that-can-be-used-to-charge-gas"><a class="header" href="#additional-data-structures-that-can-be-used-to-charge-gas">Additional data structures that can be used to charge gas.</a></h2>
<p>We have a couple of additional data structures that can be used to charge gas.
These are:</p>
<ul>
<li><code>MeteredHasher</code>: a wrapper structure that can be used to charge gas for hash
computation.</li>
<li><code>MeteredSignature</code>: a wrapper structure that can be used to charge gas for
signature checks.</li>
<li><code>MeteredBorshDeserialize</code>: a supertrait that can be used to charge gas for
structures implementing <code>BorshDeserialize</code>.</li>
</ul>
<h2 id="structure-of-the-implementation"><a class="header" href="#structure-of-the-implementation">Structure of the implementation</a></h2>
<p>The core of the gas implementation is located within the <code>sov-modules-api</code> crate
in the following modules/files:</p>
<ul>
<li><code>module-system/sov-modules-api/src/common/gas.rs</code>: contains the implementation
of the <code>Gas</code> and <code>GasMeter</code> traits. These are the core interfaces that are
consumed by the API. The <code>Gas</code> trait defines the way users can interact with
multidimensional gas units. The <code>GasMeter</code> is the interface implemented by
every data structure that contains or consumes gas (such as the <code>WorkingSet</code>
which contains a <code>TxGasMeter</code>, or the <code>PreExecWorkingSet</code> that may contain a
<code>SequencerStakeMeter</code>).</li>
<li><code>module-system/sov-modules-api/src/common/hash.rs</code>: contains the
implementation of the <code>MeteredHasher</code> which is a wrapper structure that can be
used to charge gas for hash computation.</li>
<li><code>module-system/sov-modules-api/src/transaction.rs</code>: contains the
representation of the transaction type that is used within the SDK. These
structures contain the <code>max_fee</code>, <code>max_priority_fee_bips</code> and <code>gas_limit</code>
fields that represent the maximum amount of gas tokens to use for the
transaction, the maximum priority fee to pay the sequencer (in basis points),
and an optionnal multidimensional gas limit (ie the maximum amount of gas to
be consumed for this transaction).</li>
</ul>
<p>Outside of the <code>sov-modules-api</code>, within the module system:</p>
<ul>
<li><code>module-system/module-implementations/sov-chain-state/src/gas.rs</code>:
<code>compute_base_fee_per_gas</code> contains the implementation of the gas price update
which follows our modified version of the <code>EIP-1559</code>. The gas price is updated
within the <code>ChainState</code>'s module lifecycle hooks
(<code>ChainState::begin_slot_hook</code> updates the gas price,
<code>ChainState::end_slot_hook</code> updates the gas consumed by the transaction).</li>
<li><code>module-system/module-implementations/sov-sequencer-registry/src/capabilities.rs</code>:
contains the implementationn of the <code>SequencerStakeMeter</code> which is the data
structure used to meter the sequencer stake before the transaction's execution
starts.</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="revenue-share-for-premium-components"><a class="header" href="#revenue-share-for-premium-components">Revenue Share for Premium Components</a></h1>
<p>When using Sovereign SDK's premium components (such as the ultra-low latency soft-confirming sequencer), applications that generate revenue must comply with the Sovereign Permissionless Commercial License. This guide walks you through the implementation.
<strong>Note:</strong> Non-commercial and non-production use of the SDK is exempt from the revenue share requirements.</p>
<h2 id="license-requirements"><a class="header" href="#license-requirements">License Requirements</a></h2>
<p>The license requires two things:</p>
<ol>
<li><strong>Revenue Sharing</strong>: Share a portion of revenue from transactions processed by the preferred sequencer</li>
<li><strong>Notification</strong>: Contact Sovereign Labs before production deployment with rollup access details</li>
</ol>
<p>The <code>sov-revenue-share</code> module handles the revenue sharing automatically, ensuring compliance while you focus on building your application.</p>
<h2 id="how-revenue-sharing-works"><a class="header" href="#how-revenue-sharing-works">How Revenue Sharing Works</a></h2>
<p>The module acts as an escrow for Sovereign Labs' revenue share:</p>
<ul>
<li><strong>Default Rate</strong>: 10% (1,000 basis points) - Under the license, Sovereign Labs may modify the default rate but may not increase it above 10%</li>
<li><strong>Activation</strong>: Disabled by default; Sovereign Labs activates it when ready</li>
<li><strong>Conditional</strong>: Only applies to transactions from the preferred sequencer</li>
<li><strong>Flexible</strong>: Supports any token compatible with <code>sov-bank</code></li>
</ul>
<h2 id="implementation"><a class="header" href="#implementation">Implementation</a></h2>
<p>The revenue share module is included in the starter template. You just need to integrate it where your application generates revenue.</p>
<h3 id="step-1-add-the-module-reference"><a class="header" href="#step-1-add-the-module-reference">Step 1: Add the Module Reference</a></h3>
<p>Add the revenue share module to your application:</p>
<pre><code class="language-rust">#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct YourApp&lt;S: Spec&gt; {
    #[id]
    pub id: ModuleId,
    
    #[module]
    pub revenue_share: sov_revenue_share::RevenueShare&lt;S&gt;,
    
    // ... other modules
}</code></pre>
<h3 id="step-2-share-revenue-on-fee-collection"><a class="header" href="#step-2-share-revenue-on-fee-collection">Step 2: Share Revenue on Fee Collection</a></h3>
<p>When collecting fees, check if the transaction came from the preferred sequencer and share accordingly:</p>
<pre><code class="language-rust">pub fn charge_fee(
    &amp;mut self,
    payer: &amp;S::Address,
    total_fee: Amount,
    token_id: TokenId,
    context: &amp;Context&lt;S&gt;,
    state: &amp;mut impl TxState&lt;S&gt;,
) -&gt; anyhow::Result&lt;()&gt; {
    // Only share revenue for preferred sequencer transactions
    if self.revenue_share.is_preferred_sequencer(context, state) {
        self.revenue_share.compute_and_pay_revenue_share(
            payer, 
            token_id, 
            total_fee, 
            state
        )?;
    }
    
    // Continue with your fee logic...
    Ok(())
}</code></pre>
<p>This pattern ensures you only share revenue when required. For custom implementations, use <code>get_revenue_share_percentage_bps()</code> and <code>pay_revenue_share()</code> directly.</p>
<h2 id="production-deployment-requirements"><a class="header" href="#production-deployment-requirements">Production Deployment Requirements</a></h2>
<p><strong>Before deploying to production</strong>, you must notify Sovereign Labs at <strong>info@sovlabs.io</strong> with:</p>
<ol>
<li><strong>Documentation</strong>: Link to or copy of your rollup interaction docs</li>
<li><strong>API Endpoint</strong>: Where Sovereign can submit revenue share admin transactions
<ul>
<li>Must cover reasonable gas costs (via direct transfer, paymaster, or agreed method)</li>
</ul>
</li>
<li><strong>Schema</strong> (if not available via API): Your rollup's universal wallet schema JSON</li>
</ol>
<p>This notification ensures Sovereign Labs can manage the revenue share module as intended by the license.</p>
<h2 id="questions"><a class="header" href="#questions">Questions?</a></h2>
<ul>
<li>Technical issues: Join our <a href="https://join.slack.com/t/sovereigndevelopers/shared_invite/zt-39aolimfp-XsFK6dL6LhOFHhtXsD_kCA">Slack community</a></li>
<li>Licensing questions: Contact info@sovlabs.io</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
