<!DOCTYPE HTML>
<html lang="en" class="sovereign-dark" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Sovereign SDK Book</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="/assets/sovereign-dark-highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "sovereign-dark" : "sovereign-dark";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('sovereign-dark')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="intro.html"><strong aria-hidden="true">1.</strong> Intro</a></li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li class="chapter-item expanded "><a href="rollup-devs.html"><strong aria-hidden="true">3.</strong> Rollup Devs</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="rollup-devs/build-a-module.html"><strong aria-hidden="true">3.1.</strong> Building a Module</a></li><li class="chapter-item expanded "><a href="rollup-devs/gas.html"><strong aria-hidden="true">3.2.</strong> Gas</a></li></ol></li><li class="chapter-item expanded "><a href="sdk-contributors.html"><strong aria-hidden="true">4.</strong> SDK Contributors</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="sdk-contributors/transaction-lifecycle.html"><strong aria-hidden="true">4.1.</strong> Transaction Lifecyle</a></li><li class="chapter-item expanded "><a href="sdk-contributors/abstractions.html"><strong aria-hidden="true">4.2.</strong> Main Abstractions</a></li><li class="chapter-item expanded "><a href="forced-sequencer-registration.html"><strong aria-hidden="true">4.3.</strong> Forced Sequencer Registration</a></li><li class="chapter-item expanded "><a href="sdk-contributors/gas.html"><strong aria-hidden="true">4.4.</strong> Gas</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="sovereign-dark">Sovereign Dark</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Sovereign SDK Book</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-sovereign-sdk-book"><a class="header" href="#the-sovereign-sdk-book">The Sovereign SDK Book</a></h1>
<p>The Sovereign SDK is a batteries-included framework for building onchain
applications.</p>
<p><a href="https://discord.gg/kbykCcPrcA" ><img alt="Discord" src="https://img.shields.io/discord/1050059327626555462?label=discord"/></a></p>
<img src="https://github.com/Sovereign-Labs/sovereign-sdk/blob/nightly/assets/banner.jpg?raw=true" style="border-radius: 10px">
<h2 id="why-rollups"><a class="header" href="#why-rollups">Why Rollups?</a></h2>
<p>As a developer, building your application as a rollup has several advantages:</p>
<ol>
<li><strong>Dedicated throughput:</strong> your users won't pay more just because another app
is generating a lot of transactions.</li>
<li><strong>Scalability:</strong> Sovereign SDK nodes scale seamlessly to thousands of
transactions per second on commodity hardware, and can achieve substantially
higher throughput on optimized hardware.</li>
<li><strong>Incentive alignment:</strong> the vast majority of the rollup fees can be
distributed to users and developers of the rollup, rather than subsidizing
token holders on L1.</li>
<li><strong>MEV mitigation:</strong> since you have full control over your rollup logic, you
can design your protocol to minimize MEV and capture the portions that can't
be eliminated.</li>
<li><strong>Flexibility:</strong> rollups enable you to express whatever logic you want,
without worrying about the needs of other applications. Enable cutting edge
EIPs and account abstraction, or ditch the EVM entirely and build an
app-specific chain. <strong>With a rollup, you're in the driver's seat.</strong></li>
</ol>
<h2 id="why-sovereign"><a class="header" href="#why-sovereign">Why Sovereign?</a></h2>
<p>The Sovereign SDK is the most flexible framework for building rollups. Unlike
other rollup frameworks, the Sovereign SDK supports rollups without a settlement
layer. That means that you can deploy your rollup anywhere - including on
Bitcoin and Celestia. The SDK also provides top-tier scalability and a seamless
user experience, all without sacrificing flexibility. Teams are already using
the Sovereign SDK to build...</p>
<ul>
<li>An EVM chain on Bitcoin</li>
<li>A MoveVM chain on Celestia</li>
<li>Appchains on Solana</li>
</ul>
<p>... and much more.</p>
<h2 id="how-it-works"><a class="header" href="#how-it-works">How it Works</a></h2>
<p>As a developer, you write the business logic of your rollup in Rust and the SDK
handles all of the complexity of creating a rollup on their behalf. Under the
hood, the SDK compiles the chain's business logic to a zero-knowledge circuit,
which it uses to prove correct execution (if the rollup is running in "zk mode")
or to resolve disputes about execution (if the rollup is running in "optimistic
mode"). It also generates a complete <em>full node</em> implementation which can
reproduce the state of the blockchain and serve data to users.</p>
<p>Once the rollup is deployed, users post their <em>transactions</em> onto an underlying
blockchain called a <em>Data Availability Layer</em> ("DA Layer") for ordering. After
transactions are ordered, the <em>full nodes</em> of the rollup execute them to compute
the new rollup <em>state</em>.</p>
<p>Finally, specialized actors called "provers" or "attesters" generate a proof
that the new rollup state was computed correctly and post the proof back onto
the DA layer. This enables clients of the rollup to verify claims about the
rollup state without running a full node for themselves.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<h2 id="overview"><a class="header" href="#overview">Overview</a></h2>
<p>This guide provides a starting point for building rollups with the Sovereign SDK.</p>
<p>It includes everything you need to create a rollup with customizable modules, REST API for state queries, TypeScript SDK for submitting transactions, WebSocket endpoints to subscribe to transactions and events, built-in token management, and much more.</p>
<h2 id="prerequisites"><a class="header" href="#prerequisites">Prerequisites</a></h2>
<p>Before you begin, ensure you have the following installed:</p>
<ul>
<li><strong>Rust</strong>: 1.88.0 or later
<ul>
<li>Install via <a href="https://rustup.rs/">rustup</a>: <code>curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh</code></li>
<li>The project will automatically install the correct version via <code>rust-toolchain.toml</code></li>
</ul>
</li>
<li><strong>Node.js</strong>: 18.0 or later (for Typescript client)
<ul>
<li>Install via <a href="https://nodejs.org/en/download">official website</a></li>
</ul>
</li>
<li><strong>Git</strong>: For cloning the repository</li>
</ul>
<h2 id="running-with-mock-da"><a class="header" href="#running-with-mock-da">Running with Mock DA</a></h2>
<h3 id="1-clone-the-starter-repository-and-navigate-to-the-rollup-directory"><a class="header" href="#1-clone-the-starter-repository-and-navigate-to-the-rollup-directory">1. Clone the starter repository and navigate to the rollup directory:</a></h3>
<pre><code class="language-bash">git clone https://github.com/Sovereign-Labs/sov-rollup-starter.git
cd sov-rollup-starter/crates/rollup/
</code></pre>
<h3 id="2-optional-clean-the-database-for-a-fresh-start"><a class="header" href="#2-optional-clean-the-database-for-a-fresh-start">2. (Optional) Clean the database for a fresh start:</a></h3>
<pre><code class="language-bash">make clean-db
</code></pre>
<h3 id="3-start-the-rollup-node"><a class="header" href="#3-start-the-rollup-node">3. Start the rollup node:</a></h3>
<pre><code class="language-bash">cargo run --bin node
</code></pre>
<h3 id="explore-the-rest-api-endpoints-via-swagger-ui"><a class="header" href="#explore-the-rest-api-endpoints-via-swagger-ui">Explore the REST API endpoints via Swagger UI</a></h3>
<p>The rollup includes several built-in modules: Bank (for token management), Paymaster, Hyperlane, and more. You can query any state item in these modules:</p>
<pre><code class="language-bash">open http://localhost:12346/swagger-ui/#/ 
</code></pre>
<h3 id="example-query-the-example-modules-state-value"><a class="header" href="#example-query-the-example-modules-state-value">Example: Query the Example Module's state value:</a></h3>
<pre><code class="language-bash">curl -X 'GET' \
  'http://0.0.0.0:12346/modules/example-module/state/value' \
  -H 'accept: application/json'
</code></pre>
<p>For now, you should just see null returned for the value state item, as the item hasn't been initialized:</p>
<pre><code class="language-bash">{"data":{"value":null},"meta":{}}
</code></pre>
<h2 id="programmatic-interaction-with-typescript"><a class="header" href="#programmatic-interaction-with-typescript">Programmatic Interaction with Typescript</a></h2>
<h3 id="set-up-the-typescript-client"><a class="header" href="#set-up-the-typescript-client">Set up the Typescript client:</a></h3>
<pre><code class="language-bash">cd ../../js # Navigate back up to the right directory
npm install 
</code></pre>
<h3 id="the-typescript-script-demonstrates-the-complete-transaction-flow"><a class="header" href="#the-typescript-script-demonstrates-the-complete-transaction-flow">The Typescript script demonstrates the complete transaction flow:</a></h3>
<pre><code class="language-js">// 1. Initialize rollup client
const rollup = await createStandardRollup({ // defaults to http://localhost:12346, or pass url: "custom-endpoint"
  context: {
    defaultTxDetails: {
      max_priority_fee_bips: 0,
      max_fee: "100000000",
      gas_limit: null,
      chain_id: 4321, // Must match chain_id in constants.toml
    },
  },
});

// 2. Initialize signer
const privKey = "0d87c12ea7c12024b3f70a26d735874608f17c8bce2b48e6fe87389310191264";
let signer = new Secp256k1Signer(privKey, chainHash);

// 3. Create a transaction (call message)
let createTokenCall: RuntimeCall = {
  bank: {
    create_token: {
      admins: [],
      token_decimals: 8,
      supply_cap: 100000000000,
      token_name: "Example Token",
      initial_balance: 1000000000,
      mint_to_address: signerAddress, // derived from privKey above (can be any valid address)
    },
  },
};

// 4. Send transaction
let tx_response = await rollup.call(createTokenCall, { signer });
</code></pre>
<h3 id="run-the-script"><a class="header" href="#run-the-script">Run the script:</a></h3>
<pre><code class="language-bash">npm run start 
</code></pre>
<p>You should see a transaction soft-confirmation with events:</p>
<pre><code class="language-bash">Tx sent successfully. Response:
{
  data: {
    id: '0xbfe14371219807b236c5c719ea85be63174fe0c673e8b229e4913e6f6273a5a0',
    events: [
      {
        type: 'event',
        number: 0,
        key: 'Bank/TokenCreated',
        value: {
          token_created: {
            token_name: 'Example Token',
            coins: {
              amount: '1000000000',
              token_id: 'token_10jrdwqkd0d4zf775np8x3tx29rk7j5m0nz9wj8t7czshylwhnsyqpgqtr9'
            },
            mint_to_address: { user: '0x9b08ce57a93751ae790698a2c9ebc76a78f23e25' },
            minter: { user: '0x9b08ce57a93751ae790698a2c9ebc76a78f23e25' },
            supply_cap: '100000000000',
            admins: []
          }
        },
        module: { type: 'moduleRef', name: 'Bank' },
        tx_hash: '0xbfe14371219807b236c5c719ea85be63174fe0c673e8b229e4913e6f6273a5a0'
      }
    ],
    receipt: { result: 'successful', data: { gas_used: [ 21119, 21119 ] } },
    status: 'submitted'
  },
  meta: {}
}
</code></pre>
<h3 id="subscribe-to-events-from-the-sequencer"><a class="header" href="#subscribe-to-events-from-the-sequencer">Subscribe to events from the sequencer:</a></h3>
<p>You can also subscribe to events from the sequencer (you need to uncomment the subscription code blocks <a href="js/src/index.ts#L53">in the script</a>):</p>
<pre><code class="language-js">// Subscribe to events
async function handleNewEvent(event: any): Promise&lt;void&gt; {
  console.log(event);
}
const subscription = rollup.subscribe("events", handleNewEvent);

// Unsubscribe
subscription.unsubscribe();
</code></pre>
<h3 id="interacting-with-different-modules"><a class="header" href="#interacting-with-different-modules">Interacting with different modules</a></h3>
<p>To interact with different modules, simply change the call message. The top-level key corresponds to the <a href="/crates/stf/src/runtime.rs#L85">module's variable name in the runtime</a>, and the nested key is the <a href="fix-link">CallMessage</a> enum variant in snake_case:</p>
<pre><code class="language-js">// Example: Call the ExampleModule's SetValue method
let setValueCall: RuntimeCall = {
  example_module: {  // Must match Runtime field name of the module
    set_value: 10  
  },
};
</code></pre>
<p>This transaction would set the ExampleModule's state value to 10. Try setting the <a href="js/src/index.ts#L39">example file's call message</a> to the expression above and re-running the script. Then verify that the ExampleModule's value changed using <a href="getting-started.html#example-query-the-example-modules-state-value">the curl command</a> we showed earlier.</p>
<p>This time, the curl command should return:</p>
<pre><code class="language-bash">{"data":{"value":10},"meta":{}}
</code></pre>
<h3 id="learn-more"><a class="header" href="#learn-more">Learn more</a></h3>
<p>To learn more about building with Sovereign SDK, experiment with the <a href="/crates/example-module/src/lib.rs">ExampleModule</a>. For a deeper understanding of the abstractions, see the <a href="https://docs.sovereign.xyz/rollup-devs/build-a-module.html">Building a module</a> section of the SDK book.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rollup-devs"><a class="header" href="#rollup-devs">Rollup Devs</a></h1>
<p>The chapter will explain the key concepts needed to build your own rollup. It's
divided into 3 sections:</p>
<ul>
<li><a href="build-a-module.html">Implementing your Business logic as a <code>Module</code></a></li>
<li>Composing <code>Module</code>s to build a rollup</li>
<li>Interacting with the chain (CLI, Snap, Rest APIs, RPC, Sequencer)</li>
</ul>
<!--
TODO: cover

- The `Module, ModuleInfo, BlockHooks, FinalizeHook, TxHooks, and Genesis`
  traits, as well as `Events`, `State` storage/retrieval and `Gas`
- The `TransactionAuthenticator` API and `HasCapabilities` , as well as the
  capabilities themselves: `GasEnforcer`, `SequencerAuthorization`
  `TransactionAuthorizer`, `ProofProcessor`, and `SequencerRemuneration` -->
<div style="break-before: page; page-break-before: always;"></div><h1 id="implementing-a-module"><a class="header" href="#implementing-a-module">Implementing a Module</a></h1>
<p>A module is the basic unit of functionality in the Sovereign SDK. A module is a
collection of values stored in state, and an optional <code>call</code> function which
allows users to interact with that state onchain. Modules also provide custom
API support and built-in indexing.</p>
<p>In this section, we'll describe how to implement a module and take full
advantage of the Sovereign SDKs builtin functionality.</p>
<h2 id="the-module-struct"><a class="header" href="#the-module-struct">The Module Struct</a></h2>
<p>A typical module definition looks like this.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct Example&lt;S: Spec&gt; {
    /// The ID of the module.
    #[id]
    pub(crate) id: ModuleId,

    /// A reference to the Bank module, so that we can transfer tokens.
    #[module]
    pub(crate) bank: sov_bank::Bank&lt;S&gt;,

	/// A mapping from addresses to users
    #[state]
    pub(crate) users: StateMap&lt;S::Address, User&lt;S&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>There are a few things to notice in this snippet.</p>
<h3 id="derived-traits"><a class="header" href="#derived-traits">Derived Traits</a></h3>
<p>First, we derive the <code>ModuleInfo</code> and <code>ModuleRestApi</code> traits.</p>
<p>You should always derive <code>ModuleInfo</code> on your module, since it does important
work like laying out your state values in the database. If you forget to derive
this trait, the SDK will throw a helpful error.</p>
<p>The <code>ModuleRestApi</code> trait is optional but very useful. It tries to generate
RESTful API endpoints for all of the <code>#[state]</code> items in your module. Each
item's endpoint will have the name
<code>{hostname}/modules/{module-name}/{field-name}/</code>, with all items automatically
converted to <code>kebab-casing</code>. For example, you could query an item from the
<code>known_sequencers</code> state value shown in the snippet above at the path
<code>/modules/sequencer-registry/known-sequencers/{address}</code>.</p>
<p>Note that <code>ModuleRestApi</code> can't always generate endpoints for you. If it can't
figure out how to generate an endpoint for a particular state value, it will
simply skip it by default. (Don't worry, you can always add endpoints manually
if you need to! We'll cover this in the next section.). If you want to override
the default behavior and throw a compiler error if endpoint generation fails,
you can add the <code>#[rest_api(include)]</code> attribute on your state value like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct Example&lt;S: Spec&gt; {
    // Redundant code elided here...
	#[rest_api(include)]
    #[state]
    pub(crate) users: StateMap&lt;S::Address, User&lt;S&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>See the
<a href="https://github.com/Sovereign-Labs/sovereign-sdk-wip/blob/1210acb5f5d8ca408ebaea40db3a75e5d2521491/crates/module-system/sov-modules-api/src/reexport_macros.rs#L387">documentation</a>
on <code>ModuleRestApi</code> for more details.</p>
<h3 id="the-spec-generic"><a class="header" href="#the-spec-generic">The <code>Spec</code> Generic</a></h3>
<p>Next, notice that the module is parameterized by <code>Spec</code> type. This paramter
gives you access to a bunch of handy types and cryptographic traits that are
used on the rollup. These includes the <code>Address</code> type used on the rollup, as
well as information about the underlying DA layer, like its <code>Da::Address</code> type,
<code>BlockHeader</code> type, and more. By being generic over the <code>Spec</code>, you ensure that
you can easily change things like the <code>Address</code> format used by your module later
on.</p>
<p>See the
<a href="https://github.com/Sovereign-Labs/sovereign-sdk-wip/blob/1210acb5f5d8ca408ebaea40db3a75e5d2521491/crates/module-system/sov-modules-api/src/module/spec.rs#L28-L29"><code>Spec</code> trait docs</a>
for more details.</p>
<h3 id="state-module-and-id-fields"><a class="header" href="#state-module-and-id-fields"><code>#[state]</code>, <code>#[module]</code>, and #[id] fields</a></h3>
<p>Modules may have as many <code>#[state]</code> and <code>#[module]</code> fields as they wish, but
they must have exactly one <code>#[id]</code>. The <code>ModuleInfo</code> macro will automatically
generate a unique identifier for the module and store it in the <code>id</code> field.</p>
<p><code>#[module]</code> fields are very straightforward. Adding a dependency on another
module will allow your module to access any of it's public fields and/or public
methods. The only downside is that any users of your module will also have to
include the dependency in their rollup.</p>
<p><code>#[state]</code> fields are the most interesting. They define the layout of the state
that your module will store. There are three primary kinds of <code>#[state]</code>:
<code>StateValue</code>s which store a single item, and <code>StateMap</code>s which store a mapping
from keys to values, and <code>StateVec</code>s which store a series of elements, keyed by
index.</p>
<p>Each kind of state item accepts an optional <code>Codec</code> parameter, which determines
how the state value is encoded and decoded for storage. By default, we use
<code>Borsh</code> for everything, but the SDK also provides a <code>BcsCodec</code> which is
compatible with the widely used <code>serde</code> library. If you want to store a type
from a 3rd-party library in you module, you might need to specify the BcsCodec
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use some_third_party_crate::SomeType;
#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct MyModule&lt;S: Spec&gt; {
    // Redundant code elided here...
    #[state]
    pub(crate) my_map: StateValue&lt;SomeType, BcsCoded&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>Note that this is only necessary if the compiler warns you that the type doesn't
suppor <code>BorshSerialize</code> or <code>BorshDeserialize</code>. If the compiler is happy, you
don't need to override the default.</p>
<p>The last important thing to note about state is that for each kind of item
(<code>Value/Map/Vec</code>), we provide a corresponding <code>AccessoryState{Item}</code> type.
Accessory state looks exactly like regular state, but it's <em>write only</em> during
transaction execution. Items stored in accessory state can be queried via the
API, but they don't have to be replicated by everybody running your rollup since
transactions can't read their contents. This makes accessory state much more
efficient than normal state for indexing and other off-chain tasks.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use some_third_party_crate::SomeType;
#[derive(Clone, ModuleInfo, ModuleRestApi)]
pub struct MyModule&lt;S: Spec&gt; {
    // Redundant code elided here...
	/// Stores a record of the purchase history of users that can be queried from the API
	/// but doesn't exist on-chain. This is much cheaper than maintaining the map on chain.
    #[state]
    pub(crate) token_buyers: AccessoryStateMap&lt;S::Address, Vec&lt;Price&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<h2 id="module-trait-implementation"><a class="header" href="#module-trait-implementation">Module Trait Implementation</a></h2>
<p>Once you've defined your module's state layout, you need a way for users to
interact with it.</p>
<p>That's where the <code>Module</code> trait comes in. This trait has two important methods,
<code>genesis</code> and <code>call</code>. You can see a simplified version of the trait below:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait Module {
    /// The configuration needed to initialize the module.
    type Config;

    /// A module defined argument to the call method. This is usually an enum,
    /// with  one variant for each action a user might take.
    type CallMessage: Debug + BorshSerialize + BorshDeserialize + Clone;

    /// A module defined event resulting from a call method. Events invisible to on-chain
    /// logic, but they're very useful for indexing.
    type Event: Debug + BorshSerialize + BorshDeserialize + 'static + core::marker::Send;

    /// Genesis is called once when a rollup is deployed.
    ///
    /// You should use this function to initialize all of your module's `StateValue`s and run any other
    /// one-time setup. Since this function runs only once, it's perfectly acceptible to do expensive operations
    /// here. Note that your function should still be deterministic, however.
    fn genesis(
        &amp;self,
        genesis_block_header: &amp;&lt;&lt;Self::Spec as Spec&gt;::Da as DaSpec&gt;::BlockHeader,
        config: &amp;Self::Config,
        state: &amp;mut impl GenesisState&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;


    /// Call accepts a `CallMessage` and executes it, changing the state of the module and emitting events.
    fn  call(&amp;self,
        message: Self::CallMessage,
        context: &amp;Context&lt;Self::Spec&gt;,
        state: &amp;mut impl TxState&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="genesis"><a class="header" href="#genesis">Genesis</a></h3>
<p>As you might expect, the <code>genesis</code> function is called exactly once when the
rollup is initialized. It lets the person deploying your module set any initial
configuration and is responsible for making sure that any state values in your
module are initialized (if necessary). Since <code>genesis</code> is only called once, you
don't need to worry about efficiency. However, you do need to be careful not to
do anything non-determinstic. That means no network requests, and no use of
randomness!</p>
<p>As you can see, the <code>genesis</code> function gets passed a user-defined <code>Config</code>
value. As a module author, you can put anything you want here. Deployers of your
rollup will need to instantiate the config at genesis, and you can use it to do
initialization. If your module doesn't need configuring, you can juse use the
empty type <code>()</code>.</p>
<p><code>genesis</code> also accepts an argument which implements the <code>GenesisState</code> trait.
This argument allows you to read and write to state values in your module and
its dependencies. A typical genesis config definition and genesis function
looklike this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Adapter from the `SequencerRegistry` module
pub struct SequencerConfig&lt;S: Spec&gt; {
    /// The rollup address of the sequencer.
    pub seq_rollup_address: S::Address,
    /// The Data Availability (DA) address of the sequencer.
    pub seq_da_address: &lt;S::Da as DaSpec&gt;::Address,
    /// Initial sequencer bond
    pub seq_bond: u128,
}

pub(crate) fn genesis(
    &amp;self,
    _genesis_rollup_header: &amp;&lt;&lt;S as Spec&gt;::Da as DaSpec&gt;::BlockHeader,
    config: &amp;SequencerConfig,
    state: &amp;mut impl GenesisState&lt;S&gt;,
) -&gt; Result&lt;()&gt; {
    self.register_staker(
        &amp;config.seq_da_address,
        Amount::new(config.seq_bond),
        config.seq_rollup_address.clone(),
        state,
    )?;
}
<span class="boring">}</span></code></pre></pre>
<h3 id="call"><a class="header" href="#call">Call</a></h3>
<p>The <code>call</code> function provides the transaction processing logic for your module.
It accepts a structured input from a user and a <code>Context</code> which contains
metadata including the sender address. In response to a <code>call</code>, modules may
update their state as well as emitting <code>Events</code> - structured key-value pairs
which are returned to the user and can be queried over the REST API.</p>
<p>If your call function returns an error, all of its state changes are
automatically reverted and any events are discarded. However, any logs generated
by the transaction will still be visible to the node operator. (More on
<code>logging</code> later.)</p>
<p>You can define the <code>CallMessage</code> accepted by your module to be any type you
wish, but an enum is usually best. Be sure to implement <code>borsh</code> and <code>serde</code>
serialization for your type, as well as <code>schemars::JsonSchema</code> and
<code>sov_modules_macros::UniversalWallet</code>. This will ensure that it's maximally
portable across languages and frontends, making it easy for users to securely
generate, review, sign, and send transactions to your module.</p>
<p>The <code>Bank</code> module provides a very typical example of a <code>call</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn call(&amp;self, msg: CallMessage, context: &amp;Context&lt;Self::Spec&gt;, state: &amp;mut impl TxState&lt;S&gt;)
-&gt; Result&lt;(), Error&gt; {
    match msg {
        call::CallMessage::Transfer { to, coins } =&gt; { Ok(self.do_transfer(context.sender(), &amp;to, &amp;coins.token_id, coins.amount, state)?) }
        // Other variants omitted for brevity
    }
}

fn do_transfer(&amp;self, from: S::Address, to: S::Address, token_id: &amp;TokenId, amount: Amount, state: &amp;mut impl StateAccessor) -&gt; anyhow::Result&lt;()&gt; {
    if from == to || amount == 0{
        return Ok(());
    }
    // Use a helper to compute the new `from` balance, throwing an error on insufficient funds
    let new_from_balance = self.decrease_balance_checked(token_id, from, amount, state)?;

    // Get the current `to` balance and compute the new one
    // Note that the `get` function can return an error if the call runs out of gas
    let current_to_balance = self
        .balances
        .get(&amp;(to, token_id), state)?
        .unwrap_or(Amount::ZERO);
    let to_balance = current_to_balance.checked_add(amount).with_context(|| {
        format!(
            "Account balance overflow for {} when adding {} to current balance {}",
            to, amount, current_to_balance
        )
    })?;

    // Update both balances and emit an event, reverting on error.
    self.balances.set(&amp;(from, token_id), &amp;new_from_balance, state)?;
    self.balances.set(&amp;(to, token_id), &amp;to_balance, state)?;
    self.emit_event(
        state,
        Event::TokenTransferred {
            from: sender.as_token_holder().into(),
            to: to.into(),
            coins,
        },
    );
    Ok(())
}

<span class="boring">}</span></code></pre></pre>
<p>Just like Ethereum <code>smart contracts</code> and Solana <code>programs</code>, modules accept
inputs that are pre-validated by the chain. That means your module does <em>not</em>
need to worry about authenticating the transaction. In most cases, you also
don't need to worry about manually metering resource consumption. The SDK will
automatically charge gas for any state accesses and deduct the cost from the
sender's balance. However, if your module does any very heavy computation you
may need to meter that explicitly using the <code>Module::charge_gas</code> function.</p>
<h2 id="optional-functionality---hooks"><a class="header" href="#optional-functionality---hooks">Optional Functionality - Hooks</a></h2>
<p>In addition to <code>call</code> modules may <em>optionally</em> implement <code>Hooks</code>. Hooks run at
the begining and end of every rollup block and every transaction. <code>BlockHooks</code>
are great for taking actions that need to happen before or after any
transactions execute in a block - but be careful, no one pays for the
computation done by <code>BlockHooks</code>, so doing any heavy computation can make your
rollup vulnerable to DOS attacks.</p>
<p><code>TxHooks</code> are useful for checking, or to allow your module to monitor actions
being taken by other modules. Unlike <code>BlockHooks</code>, <code>TxHooks</code> are paid for by the
user who sent each transaction.</p>
<p>The <code>FinalizeHook</code> is great for doing indexing. It can only modify
<code>AccessoryState</code>, which makes it cheap to run but means that the results will
only be visible via the API</p>
<p>Using the hooks is somewhat unusual - most applications only need to modify
their state in response to user actions - but it's a powerful tool in some
cases. See the documentation on
<a href="https://github.com/Sovereign-Labs/sovereign-sdk-wip/blob/1210acb5f5d8ca408ebaea40db3a75e5d2521491/crates/module-system/sov-modules-api/src/hooks.rs#L76"><code>BlockHooks</code></a>
and
<a href="https://github.com/Sovereign-Labs/sovereign-sdk-wip/blob/1210acb5f5d8ca408ebaea40db3a75e5d2521491/crates/module-system/sov-modules-api/src/hooks.rs#L12"><code>TxHooks</code></a>
and
<a href="https://github.com/Sovereign-Labs/sovereign-sdk-wip/blob/1210acb5f5d8ca408ebaea40db3a75e5d2521491/crates/module-system/sov-modules-api/src/hooks.rs#L120">`FinalizeHook</a>
more details.</p>
<h2 id="advanced-functionalty---native-only-code"><a class="header" href="#advanced-functionalty---native-only-code">Advanced Functionalty - native only code</a></h2>
<p>In this section, we'll describe more advanced functionality - adding custom
APIs, supporting JSON-RPC, and instrumenting your code for debugging and
optimization.</p>
<p>Any code that you write following the guide in this section needs to be gated
behind the <code>#[cfg(feature = "native")]</code> flag, which signals to the SDK that the
code is not part of the module's state transition function and is not relevant
to any questions about the rollup's current state. This means that it will be
excluded from <code>zk-proof</code> generation (if the rollup is a <code>zk-rollup</code>) or
challenges (if the rollup is optimistic).</p>
<h3 id="adding-custom-rest-apis"><a class="header" href="#adding-custom-rest-apis">Adding Custom REST APIs</a></h3>
<p>You can easily add custom APIs to your module by implementing the
<code>HasCustomRestApi</code> trait. This trait has two methods - one which actually
implements the routes, and an optional one which provides an <code>OpenApi</code> spec. YOu
can see a good example in the <code>Bank</code> module:</p>
<pre><code>impl&lt;S: Spec&gt; HasCustomRestApi for Bank&lt;S&gt; {
    type Spec = S;

    fn custom_rest_api(&amp;self, state: ApiState&lt;S&gt;) -&gt; axum::Router&lt;()&gt; {
        axum::Router::new()
            .route(
                "/tokens/:tokenId/total-supply",
                get(Self::route_total_supply),
            )
            .with_state(state.with(self.clone()))
    }

    fn custom_openapi_spec(&amp;self) -&gt; Option&lt;OpenApi&gt; {
        let mut open_api: OpenApi =
            serde_yaml::from_str(include_str!("../openapi-v3.yaml")).expect("Invalid OpenAPI spec");
        for path_item in open_api.paths.paths.values_mut() {
            path_item.extensions = None;
        }
        Some(open_api)
    }
}

async fn route_balance(
    state: ApiState&lt;S, Self&gt;,
    mut accessor: ApiStateAccessor&lt;S&gt;,
    Path((token_id, user_address)): Path&lt;(TokenId, S::Address)&gt;,
) -&gt; ApiResult&lt;Coins&gt; {
    let amount = state
        .get_balance_of(&amp;user_address, token_id, &amp;mut accessor)
        .unwrap_infallible() // State access can't fail because no one has to pay for gas.
        .ok_or_else(|| errors::not_found_404("Balance", user_address))?;

    Ok(Coins { amount, token_id }.into())
}
</code></pre>
<p>REST API methods get access to an <code>ApiStateAccessor</code>. This special struct gives
you access to both normal and <code>Accessory</code> state values. You can freely read and
write to state during your API calls, which makes it easy to reuse code from the
rest of your module. However, it's important to remember API calls do <em>not</em>
durably mutate state. Any state changes are thrown away at the end of the
request.</p>
<p>If you implement a custom REST API, your new routes will be automatically nested
under your module's router. So, in the following example, the
<code>tokens/:tokenId/total-supply</code> function can be found at
<code>/modules/bank/tokens/:tokenId/total-supply</code>. Similarly, your OpenApi spec will
get combined with the auto-generated one automatically.</p>
<p>Note that for for custom REST APIs, you'll need to manually write an <code>OpenApi</code>
specification if you want client support.</p>
<h3 id="legacy-rpc-support"><a class="header" href="#legacy-rpc-support">Legacy RPC Support</a></h3>
<p>In addition to custom RESTful APIs, the Sovereign SDK lets you create JSON-RPC
methods. This is useful to provide API compatibility with existing chains like
Ethereum and Solana, but we recommend using REST APIs whenever compatibility
isn't a concern.</p>
<p>To implement RPC methods, simply annotate an <code>impl</code> block on your module with
the <code>#[rpc_gen(client, server)]</code> macro, and then write methods which accept an
<code>ApiStateAcessor</code> as their final argument and return an <code>RpcResult</code>. You can see
some examples in the <code>Evm</code> module.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[rpc_gen(client, server)]
impl&lt;S: Spec&gt; Evm&lt;S&gt; {
    /// Handler for `net_version`
    #[rpc_method(name = "eth_getStorageAt")]
    pub fn get_storage_at(
        &amp;self,
        address: Address,
        index: U256,
        state: &amp;mut ApiStateAccessor&lt;S&gt;,
    ) -&gt; RpcResult&lt;U256&gt; {
        let storage_slot = self
            .account_storage
            .get(&amp;(&amp;address, &amp;index), state)
            .unwrap_infallible()
            .unwrap_or_default();
        Ok(storage_slot)
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="operationalizing"><a class="header" href="#operationalizing">Operationalizing</a></h2>
<p>In this section, we'll describe how to reason about and measure your module's
performance.</p>
<h3 id="understanding-performance"><a class="header" href="#understanding-performance">Understanding Performance</a></h3>
<p><strong>State Access</strong></p>
<p>The vast majority of the cost of executing a Sovereign SDK transaction comes
from state accesses. When call <code>item.set(&amp;value)</code>, the SDK serializes your value
and stores the bytes in cache. When time you access a value using <code>item.get()</code>,
the SDK deserializes a fresch copy of your value from the bytes held in cache,
falling back to disk if necessary.</p>
<p>Each time you access a value that's not in cache, the SDK has to generate a
merkle proof of the value, which it will consume when it's time to generate a
zero-knowledge proof. Similarly, each time you write a new value, the SDK has to
generate a merkle update proof. This makes reading/writing to a <code>hot</code> value, at
least an order of magnitude cheaper than writing to a <code>cold</code> one (where <code>hot</code>
means that the value has already been accessed in the current block.) So, if you
have state items that are frequently accessed together, it's a good idea to
bundle them into a single <code>StateValue</code> or store them under the same key in a
<code>StateMap</code>.</p>
<p>As a rule of thumb, for each 10% locality, you should be willing to add an extra
200 bytes to your <code>StateValue</code>. In other words, if two values are accessed
together 30% of the time, you should put them together unless either of the
state items is bigger than 600 bytes. (Exception: If two items are always
accessed together, you should always group them together - no questions asked).</p>
<p><strong>Cryptography</strong></p>
<p>The other common source of performance woes is heavy-duty cryptography. If you
need to do any cryptographic operations, check whether the <code>Spec</code> trait provides
a method in its <code>Spec::CryptoSpec</code> that already does what you want. If it does,
use that - the SDK will ensure you get an implementation which is optimized for
the SDK's peculiar requirements. If you need access to more exotic cryptography,
you can use pretty much any existing Rust library - but be aware that the
performance penalty might be severe when it comes time to prove your module's
execution, which could limit your total throughput. If you do need advanced
cryptography, you may need to pick an implementation that's suited to a
particular <code>ZKVM</code> (like <code>SP1</code> or <code>Risc0</code>) and only use that vm with your module.</p>
<h3 id="instrumenting-your-module"><a class="header" href="#instrumenting-your-module">Instrumenting Your Module</a></h3>
<p>TODO</p>
<ul>
<li>Metrics</li>
<li>Logging/traces</li>
</ul>
<pre><code>
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h2 id="gas-overview-and-blessed-values"><a class="header" href="#gas-overview-and-blessed-values">Gas overview and blessed values</a></h2>
<p>Sovereign's SDK transactions should specify gas parameters in a similar way to
Ethereum. When submitting a transaction, you need to specify a handful of gas
parameters (that are stored in a structure called <code>TxDetails</code>) that depend on
the rollup settings but also on the type of call message to execute. We also
have to make sure that the sender holds enough gas tokens in its bank balance to
make sure that the transaction is not rejected due to insufficient funds.
Finally, sequencers need to stake enough tokens to pay for the transaction
pre-execution checks (like signature verification, deserialization, etc.).</p>
<p>This can be quite overwhelming at first glance, hence we provide here a quick
summary of the gas parameters with their respective blessed values (this should
be enough to execute most transactions that are not compute/storage intensive),</p>
<p>First, let's look at the gas parameters that are required to submit a
transaction (in the <code>TxDetails</code> structure):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use sov_modules_api::Spec;
use sov_modules_api::transaction::PriorityFeeBips;

/// Contains details related to fees and gas handling.
pub struct TxDetails&lt;S: Spec&gt; {
    /// The maximum priority fee that can be paid for this transaction expressed as a basis point percentage of the gas consumed by the transaction.
    /// Ie if the transaction has consumed `100` gas tokens, and the priority fee is set to `100_000` (10%), the
    /// gas tip will be `10` tokens.
    pub max_priority_fee_bips: PriorityFeeBips,
    /// The maximum fee that can be paid for this transaction expressed as a the gas token amount
    pub max_fee: u64,
    /// The gas limit of the transaction.
    /// This is an optional field that can be used to provide a limit of the gas usage of the transaction
    /// across the different gas dimensions. If provided, this quantity will be used along
    /// with the current gas price (`gas_limit *_scalar gas_price`) to compute the transaction fee and compare it to the `max_fee`.
    /// If the scalar product of the gas limit and the gas price is greater than the `max_fee`, the transaction will be rejected.
    /// Then up to `gas_limit *_scalar gas_price` gas tokens can be spent on gas execution in the transaction execution - if the
    /// transaction spends more than that amount, it will run out of gas and be reverted.
    pub gas_limit: Option&lt;S::Gas&gt;,
    /// The ID of the target chain.
    pub chain_id: u64,
}
<span class="boring">}</span></code></pre></pre>
<ul>
<li>The <code>max_fee</code> parameter is the maximum amount of gas expressed in gas tokens
that can be charged for the transaction execution.</li>
<li>The <code>max_priority_fee</code> parameter is the maximum percentage (expressed in basis
points) of the total gas consumed by the transaction execution that should be
paid to reward the sequencer. This parameter can have any value because there
is a safety mechanism that prevents the user from paying more than the
<code>max_fee</code> in total.</li>
<li>The <code>gas_limit</code> parameter is the maximum amount of gas (expressed in
multidimensional gas units) that can be consumed by the transaction execution.
This parameter is optional and can be left unspecified. In the future, we will
add support for automatically computing this parameter from transaction
simulation.</li>
<li>The <code>user_balance</code> parameter is the balance of the sender's account (for the
gas token) in the rollup's bank.</li>
<li>The <code>sequencer_balance</code> parameter is the balance of the sequencer's account
(for the gas token) in the rollup's bank.</li>
<li>The <code>sequencer_stake</code> parameter is the staked amount of the sequencer in the
<code>sequencer_registry</code> module.</li>
</ul>
<p><em>Blessed gas parameters:</em></p>
<div class="table-wrapper"><table><thead><tr><th>Parameter</th><th>Value</th></tr></thead><tbody>
<tr><td>max_fee</td><td>100_000_000</td></tr>
<tr><td>max_priority_fee</td><td>any (50_000 is a reasonable choice)</td></tr>
<tr><td>gas_limit</td><td>None</td></tr>
<tr><td>user_balance</td><td>1_000_000_000</td></tr>
<tr><td>sequencer_balance</td><td>1_000_000_000</td></tr>
<tr><td>sequencer_stake</td><td>100_000_000</td></tr>
</tbody></table>
</div>
<p>Note also that:</p>
<ul>
<li>The <code>base_fee_per_gas</code> parameter (whose initial value <code>INITIAL_GAS_LIMIT</code> is
set by the rollup in the <code>constants.toml</code>) roughtly corresponds to the
rollup's gas price and is an internal parameter of the rollup.</li>
<li>A batch can consume up to <code>INITIAL_GAS_LIMIT</code> gas units of gas, and the gas
target is <code>1/ELASTICITY_MULTIPLIER</code> times that value (for each dimension).</li>
<li>The <code>base_fee_per_gas</code> is dynamically adjusted based on the gas consumption of
the batch. The adjustment follows the EIP-1559 which makes it goes down if the
batch consumes more gas than the target (and respectively up if the batch
consumes less gas than the target).</li>
</ul>
<p>The <a href="rollup-devs/../sdk-contributors/gas.html">gas specification</a> provides a detailed
description of the gas mechanisms used within the SDK.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sdk-contributors"><a class="header" href="#sdk-contributors">SDK Contributors</a></h1>
<p>This section provides an overview of the Sovereign SDK aimed at core
contributors to the framework. It describes the primary components of the SDK at
the level of Rust crates.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transaction-lifecyle-overview"><a class="header" href="#transaction-lifecyle-overview">Transaction Lifecyle Overview</a></h1>
<p>The transaction lifecycle begins with a <em>user</em>. First, the user opens a frontend
and gets some information about the current state of the blockchain. Then, they
open their wallet and sign a message indicating what action they want to take.</p>
<p>Once a message is signed, it needs to be ordered before full nodes can execute
it, so the user's next step is to contact a <em>sequencer</em> to post the transaction
onto the DA layer.</p>
<p>The sequencer accepts a number of transactions and bundles them into a single
<em><code>Blob</code></em>, which he sends to the DA layer for inclusion. This <code>Blob</code> is
ultimately sent to a <code>Proposer</code> on the DA layer, who includes it in his block
and gets it approved by the DA layer's validator set. Once consensus is reached
on the DA layer block containing the sequencer's <code>Blob</code>, the full nodes of the
rollup parse its contents and execute the transactions, computing a new rollup
state.</p>
<p>Next, specialized actors ("provers" or "attesters") generate a proof of the new
rollup state and post it onto the <code>DA layer</code>. Finally, light clients of the
rollup (end-users and/or bridges on other blockchains) verify the proof and see
the results of the transaction.</p>
<p><img src="sdk-contributors/../assets/tx-lifecycle.png" alt="Diagram of the Transaction Lifecycle" /></p>
<h1 id="sdk-design-philosophy"><a class="header" href="#sdk-design-philosophy">SDK Design Philosophy</a></h1>
<p>Now that we've established the basic transaction lifecycle, we have the
background we need to really dig into the design of the Sovereign SDK.</p>
<p>At a high level, the design process for the SDK was essentially just tracing the
transaction lifecycle diagram and asking two questions at each step:</p>
<ul>
<li>"How do we implement this step so that we really 'inherit the security of the
L1'?"</li>
<li>"Within those constraints, how do we build the SDK to accommodate the broadest
range of use cases?"</li>
</ul>
<h2 id="step-1-retrieving-information"><a class="header" href="#step-1-retrieving-information">Step 1: Retrieving Information</a></h2>
<p>Before doing anything, users need to find out about the current state of the
rollup. How can we enable that?</p>
<p>At this step, we have several conflicting goals and constraints:</p>
<ul>
<li>We want the user's view of the rollup to be as up-to-date as possible</li>
<li>We want to provide the strongest possible guarantees that the user's view of
state is correct</li>
<li>We want to minimize costs for the rollup</li>
<li>Users may not be willing/able to download more than a few hundred kilobytes of
data or do any significant computation</li>
</ul>
<p>Obviously, it's not possible to optimize all of these constraints
simultaneously. So, in the Sovereign SDK, we allow developers some flexibility
to pick the appropriate tradeoffs for their rollups - and we give end-users
additional flexibility to choose the setup that works best for them.</p>
<p>In practice, that means that...</p>
<ul>
<li>Developers can choose between Optimistic and ZK rollups, trading transaction
cost for time-to-finality.</li>
<li>Users can choose between running a full node (instant state access, but
expensive), running a light client (slower state access, but much cheaper and
trustless) and trusting a full node (instant state access)</li>
</ul>
<h2 id="step-2-signing-transactions"><a class="header" href="#step-2-signing-transactions">Step 2: Signing Transactions</a></h2>
<p>The SDK supports several signing/verification modes. The standard choice for
interacting with Sovereign SDK chains is our custom <code>UniversalWallet</code>, which is
available as a Metamask snap and a Ledger app. The <code>UniversalWallet</code> integrates
tightly with the Sovereign SDK to render transactions in human-readable format.
However, many chains need compatibility with legacy formats like Ethereum RLP
transactions or Solana instructions</p>
<p>We've made the pragmatic choice to be as compatible as possible with existing
crypto wallets using our <code>RuntimeAuthenticator</code> abstraction. By implementing the
<code>RuntimeAuthenticator</code>trait, developers cab bring their own transaction
deserialization and authorization logic. Even better, we allow rollups to
support several different <code>Authenticator</code> implementations simultaneously. This
allows developers to retain backward compatibility with legacy transaction
formats, without compromising on support for their native functionality.</p>
<h2 id="step-3-sequencing"><a class="header" href="#step-3-sequencing">Step 3: Sequencing</a></h2>
<p>Once a user has signed a transaction, we need to broadcast it to all full nodes
of the rollup.</p>
<p>Since a primary design goal is to inherit the security of the underlying
blockchain, we want to ensure that users are always able to fall back on the
censorship resistance of the L1 if necessary. At the same time, we don't expect
users to interact directly with the underlying blockchain in the normal case.
The underlying blockchain will charge fees in its own token, and we don't need
or want users of the rollup to be thinking about exchange rates and L1 gas
limits.</p>
<p>We also need to protect the rollup from spam. In a standard blockchain, spam is
handled by ensuring that everyone pays for the computation that the network does
on their behalf. Transactions with invalid signatures are filtered out at the
peer-to-peer layer and never get included in blocks. This means that an attacker
wanting to spam the rollup has no asymmetric advantage. He can send invalid
transactions to the few nodes he happens to be directly connected to, but they
will just disconnect. The only way to get the <em>entire blockchain network</em> to
process a transaction is to provide a valid signature and pay enough gas fees to
cover the cost of execution.</p>
<p>In a rollup, things are different. Rollups <em>inherit</em> the consensus of an
underlying blockchain <em>which doesn't know about the transaction validity rules
of the rollup</em>. Since the underlying chain doesn't know the rules, it can't
enforce them. So, we need to be prepared to deal with the fact that the rollup's
ledger is <em>dirty</em>. This is bad news, because checking transaction signatures is
expensive - especially in zero-knowledge. If we aren't careful, an attacker
could flood the rollup's ledger with malformed transactions and force the entire
network to pay to check thousands of invalid signatures.</p>
<p>This is where the sequencer comes in. Sequencers accept transactions from users
and bundle them into <code>Blob</code>s, which get posted onto the L1. At the rollup level,
we force all sequencers to register by locking up some tokens - and we ignore
any transactions which aren't posted by a registered sequencer. If a sequencer's
bundle includes any transactions which have invalid signatures, we slash his
deposit and remove him from the registry. This solves two problems at once.
<em>Users</em> don't need to worry about obtaining tokens to pay for inclusion on the
DA layer, and <em>the rollup</em> gets builtin spam protection.</p>
<p>Unfortunately, this setup also gives sequencers a lot of power. Since the
sequencer handles transactions before they've gone through the DA layer's
consensus mechanism, he can re-order transactions - and potentially even halt
the rollup by refusing to publish new transactions.</p>
<p>To mitigate this power, we need to put a couple of safeguards in the protocol.</p>
<p>First, we allow anyone to register as a sequencer depositing tokens into the
sequencer registry. This is a significant departure from most existing rollups,
which rely on a single trusted sequencer.</p>
<p>Second, we allow sequencers to register <em>without sending a transaction through
an existing sequencer</em>. Specifically, we add a rule that the rollup will
consider up to <code>K</code> extra blobs from unregisterd sequencers in each rollup block.
If any of the first <code>K</code> "unregistered" blobs conform to a special format, then
the rollup will interpret them as requests to register a new sequencer. By
capping the number of unregistered blobs that we look at, we limit the
usefulness of unregistered blobs as a DOS vector while still ensuring that
honest sequencers can register relatively quickly in case of censorship.</p>
<p>Finally, we try to make sequencing competitive by distributing some of the fees
from each transaction to the sequencer who included it. This incentivizes new
sequencers to register if the quality of service is low.</p>
<hr />
<p>Ok, that was a lot of information. Let's recap.</p>
<p>In the Sovereign SDK, sequencers are middlemen who post transactions onto the DA
layer, but it's the DA layer which ultimately decides on the ordering of
transactions. Anyone can register as a sequencer, but sequencers expose
themselves to slashing if they include transactions with invalid signatures (or
certain other kinds of obvious spam).</p>
<p>That covers a huge chunk of sequencing. But there are still two topics we
haven't touched on: stateful validation, and soft confirmations.</p>
<h3 id="stateful-validation"><a class="header" href="#stateful-validation">Stateful Validation</a></h3>
<p>Up to this point, we've been talking about transactions as if they're always
either valid or invalid for all time, regardless of what's happening on the
rollup. But in the real world (especially when there are many sequencers),
that's not the case. To give just one example, it's entirely possible for an
account to burn through all of its funds with a single transaction, leaving
nothing to pay gas with the next time around. So, if two sequencers publish
blobs at about the same time, it's very possible that the first blob will cause
some tranasactions in the second one to become invalid.</p>
<p>This complicates our analysis. Previously, we assumed that a sequencer was
malicious if he caused any invalid transactions to be processed. That meant that
we could safely slash his deposit and move on whenever we encountered a
validation error. But now, we can't make that assumption. Otherwise, sequencers
would have to be extremely conservative about which transactions they included -
since a malicious (or confused) user could potentially cause a sequencer to get
slashed by sending conflicting transactions to two different sequencers at the
same time.</p>
<p>On the other hand, we don't want to let sequencers get away with including
transactions that they <em>know</em> are invalid. Otherwise, a malicious sequencer
could include invalid transactions "for free", causing the rollup to do a bunch
of wasted computation.</p>
<p>We address these issues by splitting transasction validation into two
categories. Stateless validation (i.e. signature checks) happens first, and
transactions which fail stateless validation are invalid <em>forever</em>. If a
sequencer includes a transaction which is statelessly invalid, then we know he's
malicious. After a transaction has passed stateless validation, we proceed to
make some stateful checks (i.e. checking that the transaction isn't a duplicate,
and that the account has enough funds to pay for gas). If these checks fail, we
charge the sequencer a small fee - just enough to cover the cost of the
validatoin.</p>
<p>This ensures that sequencers are incentivized to do their best to filter out
invalid transactions, and that the rollup never does any computation without
getting paid for it, without being unfairly punitive to sequencers.</p>
<h3 id="soft-confirmations"><a class="header" href="#soft-confirmations">Soft Confirmations</a></h3>
<p>Now that we've talked about the minimum requirements for sequencer, we move on
to soft-confirmations.</p>
<p>One of the biggest selling points of rollups today is the ability to tell users
the outcome of the tranaction instantly. Under the hood, this experience is
enabled by giving a single trusted sequencer a "lock" on the rollup state.
Because he holds the lock, the sequencer can run a local simulation to determine
the exact effect of a transaction <em>before</em> he posts it on the DA layer.</p>
<p>Unfortunately, this introduces a load bearing point of centralization. If the
centralized sequencer becomes unavailable (or is malicious), the rollup halts
and users have little recourse.</p>
<p>On existing rollups, this issue is somewhat mitigated by providing an "inbox" on
the DA layer where users can send special "forced withdrawal" transactions.
However, in most existing rollups these "forced" transactions are significantly
less powerful than ordinary ones. (Users are often limited to only withdrawing
funds) and the delay period before they are processed is long.</p>
<p>In the Sovereign SDK, we try to do better. Unfortunately, there's no way to
enable soft confirmations without giving some entity a lock on (some subset of)
the rollup state. So, this is exactly what we do. We allow rollup deployers to
specify some special "preferred sequencer", which has a partial lock on the
rollup state.</p>
<p>In order to protect users in case of a malicious sequencer, though, we make a
few additional changes to the rollup.</p>
<p>First, we separate the rollup state into two subsets, "user" space and "kernel"
space. The kernel state of the rollup is maintained programatically, and it
depends directly on the headers of the latest DA layer blocks. Inside of the
protected kernel state, the rollup maintains a list of all the blobs that have
appeared on the DA layer, and the block number in which they appeared.</p>
<p>Second, we prevent access to the kernel state of the rollup during transaction
execution. This prevents users from creating transactions that could
accidentally invalidate soft-confirmations given by the sequencer, as well as
preventing the sequencer from deleting forced transactions before they can be
processsed.</p>
<p>Finally, we add two new invariants:</p>
<ol>
<li>
<p>Every blob which appears on the (canonical) DA chain will be processed within
some fixed number of blocks</p>
</li>
<li>
<p>All "forced" (non-preferred) transactions will be processed in the order they
appeared on the DA layer</p>
</li>
</ol>
<p>To help enforce these invariants, we add a concept of a "visible" slot number.
The visible slot number is a nondecreasing integer which represents block number
that the preferred sequencer observed when he started building his current
bundle. Any "forced" blobs which appear on the DA layer are processed when the
visible slot number advances beyond the number of the <em>real</em> slot in which they
appeared.</p>
<p>Inside the rollup, we enforce that...</p>
<ul>
<li>
<p>The visible slot number never lags behind the real slot number by more than
some constant <code>K</code> slots</p>
<ul>
<li>This ensures that "forced" transactions are always processed in a reasonable
time frame</li>
</ul>
</li>
<li>
<p>The visible slot number increments by <em>at least</em> one every time the preferred
sequencer succesfully submits a blob. The sequencer may increment the virtual
slot by more than one, but the maximum increment is bounded by a small
constant (say, 10).</p>
</li>
<li>
<p>The visible slot number is never greater than the current (real) slot number</p>
</li>
<li>
<p>Transactions may only access information about the DA layer that was known at
the time of their <em>virtual</em> slot's creation. Otherwise, users could write
transactions whose outcome couldn't be predicted, making it impossible to give
out soft confirmations. - For example, a user could say
<code>if current_block_hash % 2 == 1 { do_something() }</code>, which has a different
outcome depending on exactly which block it gets included in. Since the rollup
sequencer is not the L1 block proposer, he doesn't know what block the
transaction will get included in! By limiting transactions to accessing
historical information, we avoid this issue.</p>
</li>
</ul>
<p>What all of this means in practice is that...</p>
<ul>
<li>The visible state never changes unless either the preferred sequencer submits
a batch, or a timeout occurs (i.e. the visible slot lags too far). This
ensures that the preferred sequencer always knows the exact state that he's
building on top of.</li>
<li>An honest sequencer wants to keep the virtual slot number as close to the real
slot number as possible. This way, he has more buffer to absorb downtime
without the state changing. This reduces the risk of soft-confirmations being
invalidated.</li>
<li>Honest sequencers can always give accurate soft confirmations, unless the DA
layer experiences a liveness failure lasting more than <code>K</code> slots.</li>
<li>Transactions can access information about the underlying blockchain with the
best latency that doesn't invalidate soft confirmations.</li>
</ul>
<h3 id="handling-preferred-sequencer-failure"><a class="header" href="#handling-preferred-sequencer-failure">Handling Preferred Sequencer Failure</a></h3>
<p>With the current design, the Sovereign SDK supports soft confirmations while
providing a reasonably powerful forced transaction mechanism. We also provide
some limited protection from a malicious sequencer. If the sequencer is
malicious, he can - at worst - delay transaction processing by some constant
number of blocks. He can't prevent forced transactions from being processed, and
he can't selectively delay transactions.</p>
<p>We also provide some limited protection if the preferred sequencer commits a
slashable offense. In this case, the rollup enters "recovery mode", where it
reverts to standard "based" sequencing (where all sequencer are equal). In this
mode, it advances the virtual slot number two-at-a-time until the rollup is
caught up, at which point the rollup behaves as if there had never been a
preferred sequencer.</p>
<p>In the future, we may also add slashing if the preferred sequencer gives
"soft-confirmations" which turn out to be invalid, but this requires some
additional design work.</p>
<h2 id="step-4-execution"><a class="header" href="#step-4-execution">Step 4: Execution</a></h2>
<p>Once a transaction is sequenced, the rollup needs to process it.</p>
<p>At a high level, a Sovereign SDK transaction goes through the following
sequence:</p>
<ol>
<li>
<p>(Stateless) Deserialization: Decoding the bytes of the transaction into
meaningful components (signature, ChainID, etc)</p>
</li>
<li>
<p>(Stateful) Pre-validation: Checking that the address which is claiming to
have authorized the transaction exists and retrieving its preferences for
authorization. For example, if the address is a multisig, fetch the set of
public keys and the minimum number of signatures.</p>
</li>
<li>
<p>(Usually Stateless) Authentication: Checking that the transaction is
authorized. For example, checking that the signatures are valid.</p>
</li>
<li>
<p>(Stateful) Authorization: Matching the results of the authentication and
pre-validation steps to decide whether to execute. This step also reserves
the funds to pay for gas used during transaction execution. --- State changes
up to this point are irreversable. State changes beyond this point are either
committed or reverted together</p>
</li>
<li>
<p>(Stateful) Pre-dispatch hook: This hook allows <em>all</em> modules to inspect the
transaction (and their own state) and do initialization before the
transaction is executed. For example, a wallet module might use this hook to
check the user's balance and store it for later retrieval. This hook may
abort the transaction and revert any state changes by returning an <code>Error</code>.</p>
</li>
<li>
<p>(Stateful) Execution: The transaction is dispatched to a <em>single</em> target
module for execution. That module may invoke other modules if necessary
during execution. If this call returns an error, all state changes from step
5 onward are reverted.</p>
</li>
<li>
<p>(Stateful) Post-dispatch hook: This hook allows <em>all</em> modules to inspect
their state and revert the transaction if necessary. If this call returns an
error, all state changes from step 5 onward are reverted.</p>
</li>
<li>
<p>(Stateful) Post-execution: After transaction execution, any unused gas is
refunded to the payer</p>
</li>
</ol>
<p>As described in the "Sequencing" documentation, sequencers are slashed if any of
the two stateless steps fail. If either of the stateful steps prior to execution
fail, the sequencer is penalized - but just enough to cover the cost of the work
that has been done. If the transaction fails during execution, the costs are
paid by the user (or whichever entity is sponsoring the gas cost of the
transaction.)</p>
<p>For more details on execution, see [TODO]</p>
<h2 id="step-5-proving"><a class="header" href="#step-5-proving">Step 5: Proving</a></h2>
<p>Once a transaction is executed, all of the rollup <em>full nodes</em> know the result
instantly. Light clients, on the other hand need proof. In this section, we'll
describe the different kinds of proof that the Sovereign SDK offers.</p>
<h3 id="zero-knowledge-proofs"><a class="header" href="#zero-knowledge-proofs">Zero-Knowledge Proofs</a></h3>
<p>The most powerful configuration for a rollup is zero-knowledge mode. In this
mode, light clients can trustlessly sync the chain with near-zero overhead and
only minutes of lag behind the chain tip. This enables fast and trustless
bridging between rollups, and between the rollup and the execution environment
of its DA layer (if applicable).</p>
<p>In the Sovereign SDK, proving is asynchronous (meaning that we post raw
<em>transactions</em> on the DA layer - so that full nodes can compute the rollup state
even before a proof is generated). This means that light clients have a view of
the state that lags a little bit behind full nodes.</p>
<h4 id="proof-statements"><a class="header" href="#proof-statements">Proof Statements</a></h4>
<p>All zero-knowledge proofs have the form, "I know of an input such that...". In
our case, the full statement is:</p>
<blockquote>
<p>I know of a DA layer block with hash X (where X is a public input to the
proof) and a rollup state root Y (where Y is another public input) such that
the rollup transitions to state Z (another public input) when you apply its
transaction processing rules.</p>
</blockquote>
<p>To check this proof, a client of the rollup needs to check that the input block
hash X corresponds to the next DA layer block, and that the input state root Y
corresponds to the current rollup state. If so, the client can advance its view
of the state from Y to Z.</p>
<p>This works great for a single block. But if a client needs to validate the
entire history of the rollup, checking proofs of each block would get expensive.
To alleviate this problem, we use recursive proofs to compress multiple block
proofs into one. (A nice property of zero-knowledge proofs is that the work to
verify a proof is roughly constant - so checking this recursive "aggregate"
proof is no more expensive than checking the proof of a single block.)</p>
<p>Each <code>AggregateProof</code> is a statement of the form:</p>
<blockquote>
<p>I know of a (previous) valid <code>AggregateProof</code> starting from <code>A</code> (the genesis
block hash, a public input) with state root <code>B</code> (the rollup's genesis state, a
public input) and ending at block hash <code>C</code> with state root <code>D</code>. And, I know of
a sequence of valid proofs such that...</p>
<ul>
<li>For each proof, the block header has the property that <code>header.prev_hash</code> is
the hash of the previous header</li>
<li>For each proof, the input state root is the output root of the previous
root.</li>
<li>The block header from the first proof has <code>prev_hash == C</code></li>
<li>The first proof has has input state root <code>D</code></li>
<li>The final proof in the chain has block hash <code>A</code> and output root <code>B</code> (where
<code>A</code> and <code>B</code> are public inputs)</li>
</ul>
</blockquote>
<h4 id="incentives"><a class="header" href="#incentives">Incentives</a></h4>
<p>Generating zero-knowledge proofs is expensive. So, if we want proofs to be
generated, we need to incentivize proof creation in protocol, preferrably using
the gas fees that users are already paying.</p>
<p>In a standard blockchain, the goal of transaction fees markets is to maximize
consumer surplus. They achieve this by allocating a scarce resource (blockspace)
to the people who value it most. Analysis shows that EIP-1559 is extremely good
at solving this optimization problem in the setting where supply is fixed and
demand varies rapidly. EIP-1559 adjusts the price of blockspace to the exact
price level at which demand matches supply.</p>
<p>In zk-rollups, we have a slightly different setup. Our supply of blockspace is
not constant. Instead, it's possible to invest more money in proving hardware in
order to increase the rollup's throughput. However, bringing more prover
capacity online takes time. Deals have to be negotiated, hardware provisioned,
etc. So, in the short term, we model prover capacity as being fixed - and we use
EIP-1559 to adjust demand to fit that target.</p>
<p>In the long run, we want to adjust the gas limit to reflect the actual capacity
of available provers. (Note that this is not yet fully implemented). To
facilitate this, we will track the rollup's gas usage and proving throughput
(measured in gas per second) over time. If rollup blocks are full and provers
are able to keep up, we will gradually increase the gas limit until blocks are
no longer full or provers start to fall behind.</p>
<p>This still leaves one problem... how do we incentivize provers to bring more
hardware online? After all, adding more hardware increases the gas limit, which
increases the supply of blockspace. This causes congestion (and fees) to fall,
increasing consumer surplus. But provers don't get paid in consumer surplus,
they get paid in fees. So, adding more hardware hurts <em>provers</em> in two ways. It
increases their costs, and it reduces the average fee level. This means that
provers are incentivized to provide as little capacity as possible.</p>
<p>The way we handle this problem is by introducing competition. In Sovereign, we
only reward the <em>first</em> prover to publish a valid proof of a block. Since
proving is almost perfectly parallel, and provers are racing to prove the block
first, a prover which adds slightly more capacity than its rivals experiences a
disproportionate increase in rewards. This should encourage provers to bring as
much capacity as possible.</p>
<p>Since we want to reward provers with funds on the rollup, we need consensus.
(Otherwise, it would be trivial to cause a chain split by creating a fork which
sent some rewards to a different prover.) So, we require provers to post their
proofs on chain. The first prover to post a valid proof of a particular block
gets rewarded with the majority of the <code>base_fee</code>s collected from that block.
This is a deviation from EIP-1559, where all base fees are burned. Intuitively,
our construction is still safe because provers "burn" money in electricity and
hardware costs in order to create proofs. However, we also burn a small
proportion of base fees as insurance in case proving costs ever fall to
negligble levels.</p>
<p>Once a prover has posted his proof on the DA layer, two things happen. First,
full nodes read the proof and, if it's valid reward the prover. If it's invalid,
the prover has his deposit slashed. (Just like a misbehaving sequencer. Also
like sequencers, data posted by un-bonded entities is ignored.) Second, light
clients of the rollup download and verify the proof, learning the state of the
rollup. As an implementation detail, we require proofs which get posted on chain
to be domain separated, so that light clients can download just the proofs from
a rollup without also needing to fetch all of the transaction data.</p>
<h4 id="summary-the-proving-workflow"><a class="header" href="#summary-the-proving-workflow">Summary: The proving workflow</a></h4>
<p>So, putting this all together, the proving workflow looks like this:</p>
<ol>
<li>
<p>A DA layer block is produced at height <code>N</code>. This block contains some rollup
transactions.</p>
</li>
<li>
<p>Full nodes immediately process the transactions and compute a new state.</p>
</li>
<li>
<p>Provers begin generating a proof of block <code>N</code>.</p>
</li>
<li>
<p>(About 15 minutes later) a prover creates a valid proof of block <code>N</code>. In the
meantime, DA layer blocks <code>N+1</code> through <code>N+X</code> have been produced.</p>
<p>a. At this point, full nodes are aware of rollup state <code>N+X</code>, while light
clients are still unaware of <code>N</code></p>
</li>
<li>
<p>The prover creates a new <code>AggregateProof</code>, which...</p>
<p>a. Proves the validity of the proof of block <code>N</code></p>
<p>b. Proves the validity of the previous <code>AggregateProof</code> (which covered the
rollup's history from genesis to block <code>N-1</code>)</p>
<p>c. Optionally proves the validity of proofs of blocks <code>N+1</code>, <code>N+2</code>, ...,
<code>N+X</code>, if such proofs are available. (Note that the <code>AggregateProof</code> must
cover a contiguous range of blocks starting from genesis, but it may cover
any number of blocks subject to that constraint.) For concreteness, suppose
that in this case the prover includes blocks <code>N+1</code> through <code>N+5</code>.</p>
</li>
<li>
<p>The prover posts the new <code>AggregateProof</code> onto the DA layer at some height -
call it <code>N+30</code>. At this point, full nodes are aware of state <code>N+30</code> (which
includes a reward for the prover), and light clients are aware of state
<code>N+5</code>. At some point in the future, a proof of <code>N+30</code> will be generated, at
which point light clients will become aware of the prover's reward.</p>
</li>
</ol>
<h3 id="optimistic-proofs"><a class="header" href="#optimistic-proofs">Optimistic Proofs</a></h3>
<p>For some rollups, generating a full zero-knowledge proof is too expensive. For
these applications, the Sovereign SDK offers Optimistic Mode, which allows
developers to trade some light-client latency for lower costs. With a zk-rollup,
light clients have a view of the state which lags behind by about 15 minutes
(the time it takes to generate a) zero- knowledge proof. However, at the end of
those 15 minutes, light clients know the state with cryptographic certainty.</p>
<p>In an optimistic rollup, light clients have a different experience. They get
some indication of the new rollup state very quickly (usually in the very next
block), but they need to wait much longer (usually about a day) to be sure that
their new view is correct. And, even in this case, clients only have
"cryptoeconomic" certainty about the new state.</p>
<h4 id="proving-setup"><a class="header" href="#proving-setup">Proving Setup</a></h4>
<p>In an optimistic rollup, the "proofs" checked by light clients are not (usually)
proofs at all. Instead, they are simple attestations. Attesters stake tokens on
claims like "the state of the rollup at height <code>N</code> is <code>X</code>", and anyone who
successfully challenges a claim gets to keep half of the staked tokens. (The
other half are burned to prevent an attester from lying about the state and then
challenging himself from another account and keeping his tokens). In exchange,
for their role in the process, attesters are rewarded with some portion of the
rollup's gas fees. This compensates attesters for the opportunity cost of
locking their capital.</p>
<p>This mechanism explains why light clients can know the state quickly with <em>some</em>
confidence right away, but they take time to reach full certainty. Once they've
seen an attestation to a state, clients know that either the state is correct,
or the attester is going to lose some amount of capital. As time goes by and no
one challenges the assertion, their confidence grows until it reaches (near)
certainty. (The point at which clients are certain about the outcome is usually
called the "finality period" or "finality delay".)</p>
<p>The previous generation of optimistic rollups (including Optimism and Arbitrum)
relies on running an on-chain bisection game over an execution trace to resolve
disputes about the rollup state. This requires $log_2(n)$ rounds of interaction,
where <code>n</code> is the length of the trace (i.e. a few hundred million). To handle the
possibility of congestion or censorship, rollups need to set the timeout period
of messages conservatively - which means that a dispute could take up to a week
to resolve.</p>
<p>In the Sovereign SDK, we resolve disputes by generating a zero-knowledge proof
of the outcome of the disputed block. Since this only requires one round of
interaction, we don't need the same challenge delay. However, we do need to
account for the fact that proving is a heavy process. Generating a proof might
take a few hours, and proving services might be experiencing congestion. To
minimize the risk, we plan to set the finality period conservatively at first
(about one day) and reduce it over time as we gain confidence.</p>
<p>Otherwise, the overall proving setup is quite similar to that of a zk-rollup.
Just as in zk-rollups, proofs (and attestations) are posted onto the DA layer so
that we have consensus about who to reward and who to slash. And, just like a
zk-rollup, optimistic proofs/attestations are posted into a separate "namespace"
on the DA layer (if possible) so that light clients can avoid downloading
transaction data. The only other significant distinction between optimistic and
zk rollups in Sovereign is that optimistic rollups use block-level proofs to
resolve disputes instead of generating aggregate proofs which go all the way to
genesis.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>In the Sovereign SDK, we try to provide security, flexibility, and performance
<em>in that order</em>.</p>
<p>As a contributor, it's your job to maintain that hierarchy. Security must always
come first. And in blockchain, security is mostly about incentives. Especially
in blockchain, you get what you incentivize. If your rollup under-prices some
valuable resource, you'll get spam. If you under pay for some service, that
service won't be provided reliably.</p>
<p>This is why incentive management is so deeply baked into the SDK. Every step -
from sequencing to proving to execution to finality - needs to be carefully
orchestrated to keep the incentives of the participants in balance.</p>
<p>Once the setup is secure, our next priority is enabling the broadest set of use
cases. We try to provide maximum flexibility, and abstract as much functionality
as possible into reusable components. You can read more about how we achieve
flexibility at the level of Rust code in the <a href="sdk-contributors/./abstractions.html">abstractions</a>
chapter.</p>
<p>Finally, we optimize performance. This means eliminating redundant computation,
carefully managing state access patterns, and considering the strengths and
weaknesses of zero-knowledge proofs systems.</p>
<p>Happy hacking!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="main-abstractions"><a class="header" href="#main-abstractions">Main Abstractions</a></h1>
<blockquote>
<p>This document provides an overview of the major abstractions offered by the
SDK.</p>
<ul>
<li>Rollup Interface (STF + DA service + DA verifier)</li>
<li>sov-modules (<code>Runtime</code>, <code>Module</code>, stf-blueprint w/ account abstraction,
state abstractions)</li>
<li>sov-sequencer</li>
<li>sov-db</li>
<li>Rockbound</li>
</ul>
</blockquote>
<p>One of the most important principles in the Sovereign SDK is modularity. We
believe strongly in separating rollups into their component parts and
communicating through abstract interfaces. This allows us to iterate more
quickly (since components are unaware of the implementation details of other
components), and it also allows us to reuse components in contexts which are
often quite different from the ones in which they were orginally designed.</p>
<p>In this chapter, we'll give a brief overview of the core abstractions of the
Sovereign SDK</p>
<h2 id="native-vs-zk-execution"><a class="header" href="#native-vs-zk-execution">Native vs. ZK Execution</a></h2>
<p>Perhaps the most fundamental abstraction in Sovereign is the separation between
<code>"native"</code> code execution (which computes a new rollup state) and zero-knowledge
<em>verification</em> of that state. Native execution is the experience you're used to.
In native execution, you have full access to networking, disk, etc. In native
mode, you typically trust data that you read from your own database, but not
data that comes over the network.</p>
<p>Zero-knowledge execution looks similar. You write normal-looking Rust code to do
CPU and memory operations - but under the hood, the environment is alien. In
zero-knowledge execution, disk and network operations are impossible. Instead,
all input is received from the (untrusted) machine generating the proof via a
special syscall. So if you make a call that looks like a network access, you
might not get a response from <code>google.com</code>. Instead, the prover will pick some
arbitrary bytes to give back to you. The bytes might correspond to an actual
response (i.e. if the prover is honest and made the network request for you) -
but they might also be specially crafted to deceive you. So, in zero-knowledge
mode, great care must be taken to avoid relying on unverified data from the
prover.</p>
<p>In the Sovereign SDK, we try to share code between the <code>"native"</code> full node
implementation and the zero-knowledge environment to the greatest extent
possible. This minimizes surface area for bugs. However, a full node necessarily
needs a lot of logic which is unnecessary (and undesirable) to execute in
zero-knowledge. In the SDK, such code is gated behind a <code>cargo</code> feature called
<code>"native"</code>. This code includes RPC implementations, as well as logic to
pre-process some data into formats which are easier for the zero-knowledge code
to verify.</p>
<h2 id="the-rollup-interface"><a class="header" href="#the-rollup-interface">The Rollup Interface</a></h2>
<p>If you squint hard enough, a zk-rollup is made of three separate components.
There's an underlying blockchain ("Data Availability layer"), a set of
transaction execution rules ("a State Transition Function") and a zero-knowledge
proof system (a "ZKVM" for zero-knowledge virtual machine). In the abstract, it
seems like it should be possible to take the same transaction processing logic
(i.e. the EVM) and deploy it on top of many different DA layers. Similarly, you
<em>should</em> be able to take the same execution logic and compile it down to several
different proof systems - in the same way that you can take the same code an run
it on Risc0 or SP1.</p>
<p>Unfortunately, separating these components can be tricky in practice. For
example, the OP Stack relies on an Ethereum smart contract to enforce its
censorship resistance guarantees - so, you can't easily take an OP stack rollup
and deploy it on a non-EVM chain.</p>
<p>In the Sovereign SDK, flexibility is a primary design goal. So we take care to
codify this separation of concerns into the framework from the very beginning.
With Sovereign, it's possible to run any <code>State Transition Function</code> alongside
any <code>Da Service</code> on top of any (rust-compatible) proof system and get a
functional rollup. The <code>rollup-interface</code> crate is what makes this possible.
Every other crate in the SDK depends on it, because it defines the core
abstractions that are shared between all SDK rollups.</p>
<p><img src="sdk-contributors/../assets/dependency-graph.png" alt="A digram showing how the rollup interface supports the entire Sovereign SDK" /></p>
<p>Inside of the rollup interface, the <code>native</code> vs zero-knowledge distinction
appears in numerous places. For example, the <code>DA layer</code> abstraction has two
components - a <code>DaService</code>, which runs as part of <code>native</code> full node execution
and provides methods for fetching data from the underlying blockchain; and
<code>DaVerifier</code>, which runs in zero-knowledge and verifies that the data being
executed matches the provided DA block header.</p>
<h3 id="how-it-works-1"><a class="header" href="#how-it-works-1">How it Works</a></h3>
<p>Essentially, the Sovereign SDK is just a generic function that does this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn run_rollup&lt;Da: DaService, Zk: Zkvm, Stf: StateTransitionFunction&gt;(self, da: Da, zkvm: Zk, business_logic: Stf) {
	loop {
		// Run some `native` code to get the data for execution
		let (block_data, block_header) = da.get_next_block();
		let (input_state, input_state_root) = self.db.get_state();
		// Run some zero-knowledge code to execute the block
		let proof = zkvm.prove(|| {
			// Check that the inputs match the provided commitments
			if !da.verify(block_data, block_header) || !input_state.verify(input_state_root) {
				panic!()
			};
			// Make the data commitments part of the public proof
			output!(block_header.hash(), input_state_root)
			let output_state_root = business_logic.run(block_data, input_state);
			// Add the output root to the public proof
			output!(output_state_root)
		});
		// Publish the proof onto the DA layer
		da.publish(proof);
	}
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, most of the heavy lifting is done by the DA layer, the <code>Zkvm</code>
and the rollup's business logic. The full node implementation is basically just
glue holding these components together.</p>
<h3 id="da"><a class="header" href="#da">DA</a></h3>
<p>As discussed above, the role of the DA layer is to order and publish data. To
integrate with the Sovereign SDK, a DA layer needs to provide implementations of
two core traits: <code>DaService</code> and <code>DaVerifier</code>.</p>
<h4 id="da-service"><a class="header" href="#da-service">DA Service</a></h4>
<p>The <code>DaService</code> trait is usually just a thin wrapper around a DA layer's
standard RPC client. This trait provides standardized methods for fetching data,
generating merkle proofs, and publishing data. Because it interacts with the
network, correct execution of this trait is <em>not</em> provable in zero-knowledge.</p>
<p>Instead, the work of verifying of the data provided by the <code>DaService</code> is
offloaded to the <code>DaVerifier</code> trait. Since the <code>DaService</code> runs only in <code>native</code>
code, its implementation is less concerned about efficiency than zero-knowledge
code. It's also easier to patch, since updating the <code>DaService</code> does <em>not</em>
require any light clients or bridges to update.</p>
<p>The <code>DaService</code> is the only component of the SDK responsible for publishing and
fetching data. The SDK's node does not currently have a peer-to-peer network of
its own. This dramatically simplifies the full node and reduces bandwidth
requirements.</p>
<h3 id="da-verifier"><a class="header" href="#da-verifier">DA Verifier</a></h3>
<p>The <code>DaVerifier</code> is the zero-knowledge-provable counterpart of the <code>DaService</code>.
It is responsible for checking that the (untrusted) private inputs to a proof
match the public commitment <em>as efficiently as possible</em>. It's common for the
<code>DaVerifier</code> to offload some work to the <code>DaService</code> (i.e. as computing extra
metadata) in order to reduce the amount of computation required by the
<code>DaVerifier</code>.</p>
<p>At the level of <code>Rust</code> code, we encode the relationship between the <code>DaVerifier</code>
and the <code>DaService</code> using a helper trait called <code>DaSpec</code> - which specifies the
types on which both interfaces operate.</p>
<h4 id="zero-knowledge-virtual-machine-zkvm"><a class="header" href="#zero-knowledge-virtual-machine-zkvm">Zero Knowledge Virtual Machine ("<code>Zkvm</code>")</a></h4>
<p>The <code>Zkvm</code> traits make a zk-snark system (like <code>Risc0</code> or <code>Sp1</code>) compatible with
the Sovereign SDK. Like the <code>DA layer</code>, we separate <code>Zkvm</code> traits into a
<code>native</code> and zk version, plus a shared helper.</p>
<p>The <code>ZkvmHost</code> trait describes how a <code>native</code> computer executes an <code>elf</code> file
(generated from <code>Rust</code> code) and generates a zero-knowledge proof. It also
describes how the <code>native</code> machine passes private inputs (the "witness") into
the execution.</p>
<p>The <code>ZkvmGuest</code> trait describes how a program running in zero-knowledge mode
accepts inputs from the host machine.</p>
<p>Finally, the <code>ZkVerifier</code> trait describes how a proof generated by the host is
verified. This trait is implemented by both the <code>Host</code> and the <code>Guest</code>, which is
how we represent that proofs must be verifiable <code>native</code>ly and recursively (i.e.
inside another SNARK.)</p>
<h4 id="state-transition"><a class="header" href="#state-transition">State Transition</a></h4>
<p>A <code>StateTransitionFunction</code> ("STF") is a trait which describes:</p>
<ol>
<li>
<p>How to initialize a rollup's state at genesis</p>
</li>
<li>
<p>How to apply the data from the DA layer to generate a new state</p>
</li>
</ol>
<p>In other words, the implementation of <code>StateTransitionFunction</code> is what defines
the rollup's "business logic".</p>
<p>In the Sovereign SDK, we define a generic full node which can run any STF. As
long as your logic implements the interface, we should be able to run it.</p>
<p>However, implementing the business logic of a rollup is <em>extremely</em> complicated.
While it's relatively easy to roll your own implementation of the <code>Da</code> or <code>Zkvm</code>
traits, building a secure STF from scratch is a massive undertaking. It's so
complex, in fact, that we assume no one will ever do it - andthe vast majority
of the Sovereign SDK's code is devoted to providing a generic implementation of
an STF that developers can customize. (This STF is what we call the Sovereign
module system, or sov-modules).</p>
<p>So if no one is ever going to implement the <code>StateTransitionFunction</code> interface,
why bother maintaining it at all? One reason is for flexibility. Just because we
don't expect anyone to roll their own STF doesn't mean that they won't. But a
bigger motivation is to keep concerns separate. By hiding the implementation
details of the rollup behind the STF interface, we build a firm abstraction
barrier between it and the full node. This means that we're free to make
breaking changes on either side of the wall (either in the node, or in the STF)
without worrying about breaking the other component.</p>
<h2 id="sov-modules"><a class="header" href="#sov-modules">Sov Modules</a></h2>
<p>Outside of the rollup interface, the most important abstraction is
<code>sov-modules</code>. <code>sov-modules</code> is a pre-built STF with pluggable... modules. It
does the heavy lifting of implementing a secure STF so that you can focus on the
core logic of your application.</p>
<h3 id="the-runtime"><a class="header" href="#the-runtime">The Runtime</a></h3>
<p>At the heart of any sov-modules rollup is the <code>Runtime</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// An example runtime similar to the one used in our "standard" demo rollup
pub struct Runtime&lt;S: Spec&gt; {
    /// The Bank module implements fungible tokens, which are needed to charge `gas`
    pub bank: sov_bank::Bank&lt;S&gt;,
    /// The Sequencer Registry module is where we track which addresses can send batches to the rollup
    pub sequencer_registry: sov_sequencer_registry::SequencerRegistry&lt;S&gt;,
    /// The Prover Incentives module is where we reward provers who do useful work
    pub prover_incentives: sov_prover_incentives::ProverIncentives&lt;S&gt;,
    /// The Accounts module implements identities on the rollup. All of the other modules rely on it
	/// to link cryptographic keys to logical accounts
    pub accounts: sov_accounts::Accounts&lt;S&gt;,
	/// The NFT module provides an implementation of a non-fungible token standard. It's totally optional.
    pub nft: sov_nft_module::NonFungibleToken&lt;S&gt;,
    #[cfg_attr(feature = "native", cli_skip)]
    /// The EVM module lets the rollup run Ethereum smart contracts. It's totally optional.
    pub evm: sov_evm::Evm&lt;S, Da&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>At the highest level, a runtime is "just" a collection of all the modules which
are included in your rollup. Its job is to take <code>Transaction</code>s and dispatch them
to the appropriate module for execution.</p>
<p>Pretty much all rollups built with the <code>sov-modules</code> include the bank, the
sequencer registry, and the accounts module in their <code>Runtime</code>. They also
usually include one of <code>sov_prover_incentives</code> (if they're a zk-rollup) or
<code>sov_attester_incentives</code> (if they're an Optimistic rollup).</p>
<p>You may also have noticed that the <code>Runtime</code> is generic over a <code>Spec</code>. This
<code>Spec</code> describe the core types (addresses, hashers, cryptography) used by the
rollup and the DA layer. Making your runtime generic over a Spec means that you
can easily change DA layers, or swap any of the core primitives of your rollup.
For example, a rollup can trivially switch from Ed25519 to secp256k1 for its
signature scheme by changing the implementation of its <code>Spec</code> trait.</p>
<h3 id="modules"><a class="header" href="#modules">Modules</a></h3>
<p>"Modules" are the things that process transactions. For example, the <code>Bank</code>
module lets users transfer tokens to each other. And the <code>EVM</code> module implements
a full Ethereum Virtual Machine that can process any valid Ethereum transaction.</p>
<p>A <code>Module</code> is just a rust <code>struct</code> that implements two traits called <code>Module</code>
and <code>ModuleInfo</code>.</p>
<h4 id="the-module-trait"><a class="header" href="#the-module-trait">The <code>Module</code> trait</a></h4>
<p>The <code>Module</code> trait is like a simplified version of the
<code>StateTransitionFunction</code>. It describes how to initialize the module at the
rollup's genesis, and how the module processes <code>CallMessage</code>s received from
users (i.e. how it processes transactions)</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait Module {
	// -- Some associated type definitions are omitted here --
	/// Module defined argument to the call method.
    type CallMessage: Debug;

    /// Genesis is called when a rollup is deployed and can be used to set initial state values in the module.
    fn genesis(
        &amp;self,
        _config: &amp;Self::Config,
        _working_set: &amp;mut WorkingSet&lt;Self::Spec&gt;,
    ) -&gt; Result&lt;(), ModuleError&gt;;

    /// Processes a transaction, updating the rollup state.
    fn call(&amp;self,
        _message: Self::CallMessage,
        _context: &amp;Context&lt;Self::Spec&gt;,
        _state: &amp;mut impl TxState&lt;S&gt;,
    ) -&gt; Result&lt;CallResponse, ModuleError&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>You'll notice that the <code>call</code> function takes three arguments: an associated
<code>CallMessage</code> type, a <code>Context</code>, and a <code>WorkingSet</code>.</p>
<ul>
<li>
<p>The <code>CallMessage</code> type is the deserialized content of the user's transaction -
and the module can pick any type to be its <code>CallMessage</code>. In most cases,
modules use an <code>enum</code> with one variant for each action a user might want to
take. For example, the <code>Bank::CallMessage</code> type has variants for minting,
transferring, and burning tokens.</p>
</li>
<li>
<p>The <code>Context</code> type is relatively straightforward. It simply contains the
address of the sequencer, who published the transaction, the identity of the
transaction's signer, and the current block height.</p>
</li>
<li>
<p>The <code>TxState</code> is the most interesting of the three, but it needs a little bit
of explanation. In the Sovereign SDK, the rust <code>struct</code> which implements a
<code>Module</code> doesn't actually contain any state. Rather than holding actual
values, the module simply defines the <em>structure</em> of some items in state. All
of the actual state of the rollup is stored in the <code>State</code> object, which is
in-memory layer on top of the rollup's database (in native mode) or merkle
tree (in zk mode). The <code>State</code> abstraction handles commit/revert semantics for
you, as well as taking responsibility for caching, deduplication, and
automatic witness generation/checking. It also provides utilities for charging
<code>gas</code> and emitting <code>event</code>s.</p>
</li>
</ul>
<p>The <code>Accounts</code> module provides a good example of a standard <code>Module</code> trait
implementation.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub enum CallMessage&lt;S: Spec&gt; {
    /// Updates a public key for the corresponding Account.
    /// The sender must be in possession of the new key.
    UpdatePublicKey(
        /// The new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::PublicKey,
        /// A valid signature from the new public key
        &lt;S::CryptoSpec as CryptoSpec&gt;::Signature,
    ),
}

impl&lt;S: Spec&gt; sov_modules_api::Module for Accounts&lt;S&gt; {
	// -- Some items ommitted here --
    fn call(
        &amp;self,
        msg: Self::CallMessage,
        context: &amp;Context&lt;S&gt;,
        working_set: &amp;mut WorkingSet&lt;S&gt;,
    ) -&gt; Result&lt;sov_modules_api::CallResponse, Error&gt; {
        match msg {
            call::CallMessage::UpdatePublicKey(new_pub_key, sig) =&gt; {
				// Find the account of the sender
				let pub_key = self.public_keys.get(context.sender(), working_set)?;
				let account = self.accounts.get(&amp;pub_key, working_set);
				// Update the public key
				self.accounts.set(&amp;new_pub_key, &amp;account, working_set);
				self.public_keys
					.set(context.sender(), &amp;new_pub_key, working_set);
				Ok(Default::default())
            }
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<h4 id="the-moduleinfo-trait"><a class="header" href="#the-moduleinfo-trait">The <code>ModuleInfo</code> trait</a></h4>
<p>The <code>ModuleInfo</code> trait describes how the module interacts with the broader
module <em>system</em>. Each module has a unique ID and stores its state under a unique
<code>prefix</code> of the global key-value store provided by <code>sov-modules</code></p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ModuleInfo {
    /// Returns id of the module.
    fn id(&amp;self) -&gt; &amp;ModuleId;

    /// Returns the prefix where module state is stored.
    fn prefix(&amp;self) -&gt; ModulePrefix;

    /// Returns addresses of all the other modules this module is dependent on
    fn dependencies(&amp;self) -&gt; Vec&lt;&amp;ModuleId&gt;;
}
<span class="boring">}</span></code></pre></pre>
<p>Unlike the <code>Module</code> trait, its incredibly rare for developers to implement
<code>ModuleInfo</code> by hand. Instead, it's strongly recommended to derive the
<code>ModuleInfo</code> using our handy macro. A typical usage looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(ModuleInfo, Clone)]
pub struct Bank&lt;S: sov_modules_api::Spec&gt; {
    /// The id of the sov-bank module.
    #[id]
    pub(crate) id: ModuleId,

    /// The gas configuration of the sov-bank module.
    #[gas]
    pub(crate) gas: BankGasConfig&lt;S::Gas&gt;,

    /// A mapping of [`TokenId`]s to tokens in the sov-bank.
    #[state]
    pub(crate) tokens: sov_modules_api::StateMap&lt;TokenId, Token&lt;S&gt;&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>This code automatically generates a unique ID for the bank module and stores it
in the field of the module called <code>id</code>. It also initializes the <code>StateMap</code>
"<code>tokens</code>" so that any keys stored in the map will be prefixed the with module's
<code>prefix</code>. This prevents collisions in case a different module also declares a
<code>StateMap</code> where the keys are <code>TokenId</code>s.</p>
<h3 id="module-state"><a class="header" href="#module-state">Module State</a></h3>
<p>The Sovereign SDK provides three core abstractions for managing module state. A
<code>StateMap&lt;K, V&gt;</code> maps arbitrary keys of type <code>K</code> to arbitrary values of type
<code>V</code>. A <code>StateValue&lt;V&gt;</code> stores a value of type <code>V</code>. And a <code>StateVec&lt;V&gt;</code> store an
arbitrary length vector of type <code>V</code>. All three types require their arguments to
be serializable, since the values are stored in a merkle tree under the hood.</p>
<p>All three abstractions support changing the underlying encoding scheme but
default to <code>Borsh</code> if no alternative is specified. To override the default,
simply add an extra type parameter which implements the <code>StateCodec</code> trait. (i.e
you might write <code>StateValue&lt;Da::BlockHeader, BcsCodec&gt;</code> to use the <code>Bcs</code>
serialization scheme for block headers, since your library for DA layer types
might only support serde-compatible serializers).</p>
<p>All state values are accessed through <code>TxState</code>. For example, you always write
<code>my_state_value.get(&amp;mut state)</code> to fetch a value. It's also important to
remember that modifying a value that you read from state doesn't have any effect
unless you call <code>my_value.set(new, &amp;mut working_set)</code>.</p>
<h4 id="merkle-tree-layout"><a class="header" href="#merkle-tree-layout">Merkle Tree Layout</a></h4>
<p><code>sov-modules</code> currently uses a generic
<a href="https://github.com/penumbra-zone/jmt">Jellyfish Merkle Tree</a> for its
authenticated key-value store. (Generic because it can be configured to use any
32-byte hash function). In the near future, this JMT will be replaced with the
<a href="https://sovereign.mirror.xyz/jfx_cJ_15saejG9ZuQWjnGnG-NfahbazQH98i1J3NN8">Nearly Optimal Merkle Tree</a>
that is currently under development.</p>
<p>In the current implementation, the SDK implements storage by generating a unique
(human-readable) key for each <code>StateValue</code>, using the hash of that key as a path
in the merkle tree. For <code>StateMap</code>s, the serialization of the key is appended to
that path. And for <code>StateVec</code>s, the index of the value is appended to the path.</p>
<p>For example, consider the following module:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Suppose we're in the file my_crate/lib.rs
#[derive(ModuleInfo, Clone)]
pub struct Example&lt;S: sov_modules_api::Spec&gt; {
    #[id]
    pub(crate) id: ModuleId,
    #[state]
    pub(crate) some_value: sov_modules_api::StateValue&lt;u8&gt;,
    #[state]
    pub(crate) some_vec: sov_modules_api::StateVec&lt;u64&gt;,
    #[state]
    pub(crate) some_map: sov_modules_api::StateMap&lt;String, String&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The value of <code>some_value</code> would be stored at the path
<code>hash(b"my_crate/Example/some_value")</code>. The value of the key "hello" in
<code>some_map</code> would be stored at <code>hash(b"my_crate/Example/some_map/hello")</code> (where
<code>hello</code> represents the borsh encoding of the string "hello") etc.</p>
<p>However, this layout may change in future to provide better locality. For more
details... ask Preston, I guess.</p>
<h4 id="exotic-state-variants"><a class="header" href="#exotic-state-variants">Exotic State Variants</a></h4>
<p>In addition to the standard state store, we support two other kinds of state:</p>
<p><code>KernelStateValue</code>s or (maps/vecs) act identically to regular <code>StateValues</code>, but
they're stored in a separate merkle tree which is more tightly access
controlled. This mechanism allows the rollup to store data that is inaccessible
during transaction execution, which is necessary to enable soft-confirmations
without sacrificing censorship resistance. For more details, see the section on
soft-confirmations in the <a href="sdk-contributors/./transaction-lifecycle.html">transaction lifecycle</a>
documentation. The global "state root" returned by the <code>sov-modules</code> from the
<code>StateTransitionFunction</code> implementation is the hash of the kernel state root
with the regular state root. We do our best to hide this detail from users of
the SDK, though. Merkle proofs are automatically generated against the global
root, so users don't need to worry about which state trie there values are in.</p>
<p><code>AccessoryStateValue</code> or (map/vec) types are similar to <code>Kernel</code> types except
that their values are not <em>readable</em> from inside the state transition function
at all. Under the hood, these value are stored in the rollup's database <em>but not
in either merkle tree</em>. This is useful for creating data that will be served via
RPC but never accessed again during execution - for example, the transaction
receipts from an Ethereum block.</p>
<h3 id="the-stf-blueprint"><a class="header" href="#the-stf-blueprint">The STF Blueprint</a></h3>
<p>The last key component of a <code>sov-modules</code> rollup is the <code>stf-blueprint</code>. This
"blueprint" provides a generic implementation of a <code>StateTransitionFunction</code> in
terms of a <code>Runtime</code> (described above) and a <code>Kernel</code> (which provides
security-critical functionality like censorship resistance in a way that's
isolated from the transaction execution logic).</p>
<p>The STF blueprint implements the following high-level workflow:</p>
<ol>
<li>Take all of the new data <code>Blob</code>s read from the DA layer and send them to the
<code>Kernel</code>. The <code>Kernel</code> will return a list of deserialized <code>Batch</code>es of
transactions as well as the current <code>gas</code> price. (A "<code>Batch</code>" is a "<code>Blob</code>"
sent by a registered sequencer that has been succesfully deserialized into a
list of <code>Transaction</code>s)</li>
</ol>
<ul>
<li>Note that the list of <code>Batch</code>es returned by the <code>Kernel</code> does <em>not</em>
necessarily correspond exactly to the incoming <code>Blob</code>s. The <code>Kernel</code> might
decide to ignore some Blobs, or to store some in its internal state for
"deferred" execution. It might also add some <code>Batch</code>es saved from a previous
slot.</li>
</ul>
<ol start="2">
<li>
<p>Run the <code>begin_slot</code> hook, allowing modules to execute any initialization
logic</p>
</li>
<li>
<p>For each batch initialize the sequencer reward to zero and run the
<code>begin_batch</code> hook. Apply the transactions, rewarding or penalizing the
sequencer as appropriate. Finally, run the <code>end_batch</code> hook</p>
</li>
<li>
<p>Run the <code>end_slot</code> hook to allow modules to execute any final logic.</p>
</li>
<li>
<p>Compute the state change set and state root based on the transactions that
were executed.</p>
</li>
<li>
<p>Execute the <code>finalize</code> hook, which allows modules to compute any summary
information from the change set and make it available via RPC.</p>
</li>
</ol>
<p>For more details on the process of applying individual transactions, see the
<a href="sdk-contributors/./transaction-lifecycle.html">transaction lifecycle</a> document.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="sequencer-registration-via-forced-inclusion"><a class="header" href="#sequencer-registration-via-forced-inclusion">Sequencer Registration via Forced Inclusion</a></h1>
<p>Forced inclusion is a strategic mechanism in rollups designed to circumvent
sequencers that censor user transactions. It allows users to directly submit
transaction batches to the <a href="./da-layer.html">Data Availability Layer</a> instead of
going through a sequencer.</p>
<p>The Sovereign SDK supports this feature under specific conditions and
guidelines. Crucially, only "Register Sequencer" transactions are accepted for
forced inclusion; all other types will be ignored. For more details, see the
<a href="forced-sequencer-registration.html#rules">Rules</a> section.</p>
<h2 id="usage"><a class="header" href="#usage">Usage</a></h2>
<p>The Sovereign SDK limits the number of batches from unregistered sequencers
processed per rollup slot. This measure limits the use of this mechanism as a
denial-of-service (DOS) attack vector.</p>
<h3 id="process-for-forced-registration"><a class="header" href="#process-for-forced-registration">Process for Forced Registration</a></h3>
<ol>
<li>Create a batch containing a valid "Register Sequencer" transaction.</li>
<li>Submit the batch to the Data Availability layer.</li>
<li>Rollup nodes collect and execute the transaction.</li>
<li>If the transaction complies with all rules, the user is registered as a
sequencer and can submit regular transaction batches.</li>
</ol>
<h2 id="rules"><a class="header" href="#rules">Rules</a></h2>
<p>To ensure forced inclusion requests are processed correctly, the following rules
apply:</p>
<ul>
<li><strong>Transaction Limit</strong>: Only the first transaction in each batch is taken into
account. Any additional transactions will be discarded.</li>
<li><strong>Transaction Type</strong>: The transaction must be a "Register Sequencer"
transaction.</li>
<li><strong>Transaction Construction</strong>: The transaction must be properly formatted and
comply with standard transaction rules.</li>
<li><strong>Financial Requirements</strong>: Users must have enough funds to cover:
<ul>
<li>Pre-execution checks (including signature validation, deserialization and
transaction type checks).</li>
<li>Transaction execution costs.</li>
<li>A bond required for sequencer registration.</li>
</ul>
</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="gas-specification"><a class="header" href="#gas-specification">Gas Specification</a></h1>
<p>This document contains a detailed specification of the way gas is handled within
Sovereign's SDK. We use <code>&lt;., .&gt;</code> to denote the scalar product of two
multidimensional quantities.</p>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Gas is an ubiquitous concept in the blockchain space. It is a measure of the
computational effort required to perform an operation as part of a transaction
execution context. This is used to prevent the network from getting spammed by
regulating the use of computational resources by each participant in the
network.</p>
<h2 id="high-level-overview"><a class="header" href="#high-level-overview">High level overview</a></h2>
<p>We have drawn a lot of inspiration from the
<a href="https://ethereum.org/en/developers/docs/gas/">Ethereum gas model</a> in our gas
mechanism design. Given that Ethereum's gas is well understood and widely used
in the crypto industry, we believe that this will help users onboard more easily
while providing strong security guarantees out-of-the box. We have deliberately
chosen to tweak some concepts that were ill-suited to the rollups built using
Sovereing's SDK. In particular, sorted decreasing order of importance:</p>
<ul>
<li>We are using multidimensional gas units and prices.</li>
<li>We plan to using a dynamic gas target. Otherwise, the rollups built with
Sovereign's SDK follow the <a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559</a>
specification by default.</li>
<li>Rollup transactions specify a <code>max_fee</code>, <code>max_priority_fee_bips</code>, and
<em>optional gas limit</em> <code>gas_limit</code>. The semantics of these quantities roughtly
match their definition in the
<a href="https://eips.ethereum.org/EIPS/eip-1559">EIP-1559 specification</a>.</li>
<li>Transaction rewards are decomposed into <code>base_fee</code> and <code>priority_fee</code>. The
<code>base_fee</code> <em>is only partially burnt by default</em>, the remaining amount is used
<em>to reward provers/attesters</em>. The <code>priority_fee</code> is used to reward the <em>block
sequencers</em>.</li>
<li>We are charging gas for every storage access within the module system by
default.</li>
<li>Customers of the SDK will have access to wrappers that allow to charge gas for
hash computation and signature checks.</li>
</ul>
<h2 id="a-design-for-multidimensional-gas"><a class="header" href="#a-design-for-multidimensional-gas">A design for multidimensional gas</a></h2>
<p>Sovereign SDK's rollups use multidimensional gas units and prices. For example,
this allows developers to take into account the differences between native and
zero-knowledge computational costs for the same operation. Indeed:</p>
<ul>
<li>Hashing is orders of magnitude more expensive when performed inside a
zero-knowledge circuit. The cost of proving the correct computation of two
different Hash may also vary much more than the cost of computing the hash
itself (<code>Poseidon</code> or <code>MiMc</code> vs <code>Sha2</code>).</li>
<li>Accessing a storage cell for the first time is much more expensive in <code>zk</code>
mode than in <code>native</code> mode. But <em>hot</em> storage accesses are practically free in
zero-knowledge.</li>
</ul>
<p>In the Sovereign SDK, we currently meter consumption in two dimensions - compute
and memory.</p>
<p>We have chosen to follow the
<a href="https://ethresear.ch/t/multidimensional-eip-1559/11651">multi-dimensional EIP-1559</a>
design for the gas pricing adjustment formulas. In essence:</p>
<ul>
<li>We are performing the gas price updates for each dimension separately. In
other words, each dimension follows a separate uni-dimensional EIP-1559 gas
price adjustment formula.</li>
<li>The gas price adjustment formula uses a <code>gas_target</code> reference, which is a
uni-dimensional gas unit that is compared to the gas consumed <code>gas_used</code>. The
<code>gas_price</code> is then adjusted to regulate the gas throughtput to get as close
as possible to the <code>gas_target</code>. We have the following invariant:
<code>0 &lt;= gas_used_slot &lt;= 2 * gas_target</code>.</li>
<li><em>Contrarily to Ethereum</em>, we are planning to design a dynamic <code>gas_target</code>.
The value of the <code>gas_target</code> will vary slowly to follow the evolution of the
rollup metrics we have described above. That way, Sovereign rollups can
account for major technological improvements in computation (such as zk-proof
generation throughtput), or storage cost.</li>
<li>Every transaction has to specify a scalar <code>max_fee</code> which is the maximum
amount of <em>gas tokens</em> that can be used to execute a given transaction.
Similarly, users have to specify a <code>max_priority_fee_per_gas</code> expressed in
basis points which can be used to reward the transaction sequencer.</li>
<li>The final sequencer reward is:
<code>seq_reward = min(max_fee - &lt;base_fee, gas_price&gt;, max_priority_fee_per_gas * &lt;base_fee, gas_price&gt;)</code>.</li>
<li>Users can provide an optional <code>gas_limit</code> field which is a maximum amount of
gas to be used for the transaction. This quantity is converted to a
uni-dimensional <code>remaining_funds</code> quantity by taking the scalar product with
the current <code>gas_price</code>.</li>
<li>If users provide the <code>gas_limit</code>, the rollup checks that
<code>&lt;gas_limit, current_gas_price&gt; &lt;= max_fee</code> (ie, the scalar product with the
current <code>gas_price</code>). If the check fails, the associated transaction is not
executed and the rollup raises a
<code>ReserveGasErrorReason::CurrentGasPriceTooHigh</code> error.</li>
</ul>
<h2 id="charging-gas-for-state-accesses"><a class="header" href="#charging-gas-for-state-accesses">Charging gas for state accesses.</a></h2>
<p>State accessors such as the <code>WorkingSet</code> or the <code>PreExecWorkingSet</code> charge some
gas whenever state is modified. If these accessors run out of gas, they return a
<code>StateAccessorError</code> and the execution gets reverted (or the sequencer is
penalized). Some state accessors - like <code>StateCheckpoint</code>, the <code>TxScratchpad</code> or
the <code>ApiStateAccessor</code> - don't charge for gas for state accesses. In that case,
the access methods return a <code>Result&lt;T, Infallible&gt;</code> type which can be unwrapped
safely using <code>unwrap_infallible</code>.</p>
<p>For now, we are enforcing simple cached access patterns - we are refunding some
gas if the value that is accessed/modified is <em>hot</em> (ie has been already
accessed and is cached).</p>
<h2 id="gas-rewards"><a class="header" href="#gas-rewards">Gas rewards.</a></h2>
<p>The gas consumed during transaction execution is used to reward both
provers/attesters and block sequencers. The <code>base_fee</code>, ie the total amount of
gas consumed by the transaction execution is partially burnt (the amount to burn
is specified by the <code>PERCENT_BASE_FEE_TO_BURN</code> constant), and the remaining
portion is locked in a reward pool to be redeemed by provers/attesters. The
<code>priority_fee</code> is also partially burnt and used to reward block sequencers.</p>
<h2 id="additional-data-structures-that-can-be-used-to-charge-gas"><a class="header" href="#additional-data-structures-that-can-be-used-to-charge-gas">Additional data structures that can be used to charge gas.</a></h2>
<p>We have a couple of additional data structures that can be used to charge gas.
These are:</p>
<ul>
<li><code>MeteredHasher</code>: a wrapper structure that can be used to charge gas for hash
computation.</li>
<li><code>MeteredSignature</code>: a wrapper structure that can be used to charge gas for
signature checks.</li>
<li><code>MeteredBorshDeserialize</code>: a supertrait that can be used to charge gas for
structures implementing <code>BorshDeserialize</code>.</li>
</ul>
<h2 id="structure-of-the-implementation"><a class="header" href="#structure-of-the-implementation">Structure of the implementation</a></h2>
<p>The core of the gas implementation is located within the <code>sov-modules-api</code> crate
in the following modules/files:</p>
<ul>
<li><code>module-system/sov-modules-api/src/common/gas.rs</code>: contains the implementation
of the <code>Gas</code> and <code>GasMeter</code> traits. These are the core interfaces that are
consumed by the API. The <code>Gas</code> trait defines the way users can interact with
multidimensional gas units. The <code>GasMeter</code> is the interface implemented by
every data structure that contains or consumes gas (such as the <code>WorkingSet</code>
which contains a <code>TxGasMeter</code>, or the <code>PreExecWorkingSet</code> that may contain a
<code>SequencerStakeMeter</code>).</li>
<li><code>module-system/sov-modules-api/src/common/hash.rs</code>: contains the
implementation of the <code>MeteredHasher</code> which is a wrapper structure that can be
used to charge gas for hash computation.</li>
<li><code>module-system/sov-modules-api/src/transaction.rs</code>: contains the
representation of the transaction type that is used within the SDK. These
structures contain the <code>max_fee</code>, <code>max_priority_fee_bips</code> and <code>gas_limit</code>
fields that represent the maximum amount of gas tokens to use for the
transaction, the maximum priority fee to pay the sequencer (in basis points),
and an optionnal multidimensional gas limit (ie the maximum amount of gas to
be consumed for this transaction).</li>
</ul>
<p>Outside of the <code>sov-modules-api</code>, within the module system:</p>
<ul>
<li><code>module-system/module-implementations/sov-chain-state/src/gas.rs</code>:
<code>compute_base_fee_per_gas</code> contains the implementation of the gas price update
which follows our modified version of the <code>EIP-1559</code>. The gas price is updated
within the <code>ChainState</code>'s module lifecycle hooks
(<code>ChainState::begin_slot_hook</code> updates the gas price,
<code>ChainState::end_slot_hook</code> updates the gas consumed by the transaction).</li>
<li><code>module-system/module-implementations/sov-sequencer-registry/src/capabilities.rs</code>:
contains the implementationn of the <code>SequencerStakeMeter</code> which is the data
structure used to meter the sequencer stake before the transaction's execution
starts.</li>
</ul>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            MathJax.Hub.Register.StartupHook('End', function() {
                window.setTimeout(window.print, 100);
            });
        });
        </script>

    </div>
    </body>
</html>
